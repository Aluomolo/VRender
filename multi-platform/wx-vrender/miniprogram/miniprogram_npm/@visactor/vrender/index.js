module.exports = (function() {
var __MODS__ = {};
var __DEFINE__ = function(modId, func, req) { var m = { exports: {}, _tempexports: {} }; __MODS__[modId] = { status: 0, func: func, req: req, m: m }; };
var __REQUIRE__ = function(modId, source) { if(!__MODS__[modId]) return require(source); if(!__MODS__[modId].status) { var m = __MODS__[modId].m; m._exports = m._tempexports; var desp = Object.getOwnPropertyDescriptor(m, "exports"); if (desp && desp.configurable) Object.defineProperty(m, "exports", { set: function (val) { if(typeof val === "object" && val !== m._exports) { m._exports.__proto__ = val.__proto__; Object.keys(val).forEach(function (k) { m._exports[k] = val[k]; }); } m._tempexports = val }, get: function () { return m._tempexports; } }); __MODS__[modId].status = 1; __MODS__[modId].func(__MODS__[modId].req, m, m.exports); } return __MODS__[modId].m.exports; };
var __REQUIRE_WILDCARD__ = function(obj) { if(obj && obj.__esModule) { return obj; } else { var newObj = {}; if(obj != null) { for(var k in obj) { if (Object.prototype.hasOwnProperty.call(obj, k)) newObj[k] = obj[k]; } } newObj.default = obj; return newObj; } };
var __REQUIRE_DEFAULT__ = function(obj) { return obj && obj.__esModule ? obj.default : obj; };
__DEFINE__(1689069767668, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.version = void 0, require("reflect-metadata"), require("./modules"), 
exports.version = "0.12.1", __exportStar(require("./container"), exports), __exportStar(require("./core/global"), exports), 
__exportStar(require("./graphic"), exports), __exportStar(require("./modules"), exports), 
__exportStar(require("./create"), exports), __exportStar(require("./event"), exports), 
__exportStar(require("./interface"), exports), __exportStar(require("./render"), exports), 
__exportStar(require("./canvas"), exports), __exportStar(require("./core"), exports), 
__exportStar(require("./picker"), exports), __exportStar(require("./kits"), exports), 
__exportStar(require("./animate"), exports), __exportStar(require("./resource-loader/loader"), exports), 
__exportStar(require("./common/text"), exports), __exportStar(require("./common/bezier-utils"), exports), 
__exportStar(require("./common/bounds-context"), exports), __exportStar(require("./common/seg-context"), exports), 
__exportStar(require("./common/custom-path2d"), exports), __exportStar(require("./common/segment"), exports), 
__exportStar(require("./common/canvas-utils"), exports), __exportStar(require("./common/contribution-provider"), exports), 
__exportStar(require("./common/generator"), exports), __exportStar(require("./common/utils"), exports), 
__exportStar(require("./common/shape/arc"), exports), __exportStar(require("./common/shape/rect"), exports), 
__exportStar(require("./common/path-svg"), exports), __exportStar(require("./common/render-curve"), exports), 
__exportStar(require("./common/render-area"), exports), __exportStar(require("./common/render-command-list"), exports), 
__exportStar(require("./common/sort"), exports), __exportStar(require("./common/morphing-utils"), exports), 
__exportStar(require("./common/split-path"), exports), __exportStar(require("./common/enums"), exports), 
__exportStar(require("./animate/default-ticker"), exports);
//# sourceMappingURL=index.js.map
}, function(modId) {var map = {"./modules":1689069767669,"./container":1689069767702,"./core/global":1689069767671,"./graphic":1689069767757,"./create":1689069767940,"./event":1689069767712,"./interface":1689069767948,"./render":1689069767850,"./canvas":1689069767852,"./core":1689069768002,"./picker":1689069767864,"./kits":1689069767862,"./animate":1689069767728,"./resource-loader/loader":1689069767743,"./common/text":1689069767760,"./common/bezier-utils":1689069767693,"./common/bounds-context":1689069767682,"./common/seg-context":1689069767690,"./common/custom-path2d":1689069767681,"./common/segment":1689069767688,"./common/canvas-utils":1689069767755,"./common/contribution-provider":1689069767672,"./common/generator":1689069767711,"./common/utils":1689069767736,"./common/shape/arc":1689069767686,"./common/shape/rect":1689069767825,"./common/path-svg":1689069767684,"./common/render-curve":1689069767818,"./common/render-area":1689069767821,"./common/render-command-list":1689069767687,"./common/sort":1689069767841,"./common/morphing-utils":1689069767739,"./common/split-path":1689069767738,"./common/enums":1689069767685,"./animate/default-ticker":1689069767946}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767669, function(require, module, exports) {


var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.layerService = exports.pickerService = exports.graphicService = exports.transformUtil = exports.graphicUtil = exports.global = void 0;

const core_modules_1 = __importDefault(require("./core/core-modules")), render_modules_1 = __importDefault(require("./render/render-modules")), pick_modules_1 = __importDefault(require("./picker/pick-modules")), graphic_module_1 = __importDefault(require("./graphic/graphic-service/graphic-module")), plugin_modules_1 = __importDefault(require("./plugins/plugin-modules")), modules_1 = __importDefault(require("./core/contributions/modules")), modules_2 = __importDefault(require("./render/contributions/modules")), modules_3 = __importDefault(require("./picker/contributions/modules")), modules_4 = __importDefault(require("./canvas/contributions/modules")), constants_1 = require("./core/constants"), global_picker_service_1 = require("./picker/global-picker-service"), application_1 = require("./application"), constants_2 = require("./graphic/constants"), constants_3 = require("./core/constants"), container_1 = require("./container"), constants_4 = require("./constants");

container_1.container.load(core_modules_1.default), container_1.container.load(graphic_module_1.default), 
container_1.container.load(render_modules_1.default), container_1.container.load(pick_modules_1.default), 
container_1.container.load(plugin_modules_1.default), (0, modules_1.default)(container_1.container), 
(0, modules_2.default)(container_1.container), (0, modules_3.default)(container_1.container), 
(0, modules_4.default)(container_1.container), exports.global = container_1.container.get(constants_4.Global), 
application_1.application.global = exports.global, exports.graphicUtil = container_1.container.get(constants_3.GraphicUtil), 
application_1.application.graphicUtil = exports.graphicUtil, exports.transformUtil = container_1.container.get(constants_3.TransformUtil), 
application_1.application.transformUtil = exports.transformUtil, exports.graphicService = container_1.container.get(constants_2.GraphicService), 
application_1.application.graphicService = exports.graphicService, exports.pickerService = container_1.container.get(global_picker_service_1.GlobalPickerService), 
exports.layerService = container_1.container.get(constants_1.LayerService), application_1.application.layerService = exports.layerService;
//# sourceMappingURL=modules.js.map
}, function(modId) { var map = {"./core/core-modules":1689069767670,"./render/render-modules":1689069767748,"./picker/pick-modules":1689069767839,"./graphic/graphic-service/graphic-module":1689069767854,"./plugins/plugin-modules":1689069767855,"./core/contributions/modules":1689069767857,"./render/contributions/modules":1689069767891,"./picker/contributions/modules":1689069767905,"./canvas/contributions/modules":1689069767934,"./core/constants":1689069767747,"./picker/global-picker-service":1689069767843,"./application":1689069767703,"./graphic/constants":1689069767744,"./container":1689069767702,"./constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767670, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), global_1 = require("./global"), graphic_utils_1 = require("./graphic-utils"), layer_service_1 = require("./layer-service"), window_1 = require("./window"), constants_1 = require("./constants"), constants_2 = require("../constants");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(global_1.DefaultGlobal).toSelf().inSingletonScope(), bind(constants_2.Global).toService(global_1.DefaultGlobal), 
    bind(window_1.DefaultWindow).to(window_1.DefaultWindow), bind(window_1.Window).toService(window_1.DefaultWindow), 
    bind(graphic_utils_1.DefaultGraphicUtil).toSelf().inSingletonScope(), bind(constants_1.GraphicUtil).toService(graphic_utils_1.DefaultGraphicUtil), 
    bind(graphic_utils_1.DefaultTransformUtil).toSelf().inSingletonScope(), bind(constants_1.TransformUtil).toService(graphic_utils_1.DefaultTransformUtil), 
    bind(layer_service_1.DefaultLayerService).toSelf().inSingletonScope(), bind(constants_1.LayerService).toService(layer_service_1.DefaultLayerService);
}));
//# sourceMappingURL=core-modules.js.map
}, function(modId) { var map = {"./global":1689069767671,"./graphic-utils":1689069767677,"./layer-service":1689069767705,"./window":1689069767746,"./constants":1689069767747,"../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767671, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultGlobal = void 0;

const inversify_1 = require("inversify"), contribution_provider_1 = require("../common/contribution-provider"), tapable_1 = require("../tapable"), constants_1 = require("../constants"), defaultEnv = "browser";

let DefaultGlobal = class {
    get env() {
        return this._env;
    }
    get devicePixelRatio() {
        return this._env || this.setEnv("browser"), this.envContribution.getDevicePixelRatio();
    }
    get supportEvent() {
        return this._env || this.setEnv("browser"), this.envContribution.supportEvent;
    }
    get supportsTouchEvents() {
        return this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents;
    }
    get supportsPointerEvents() {
        return this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents;
    }
    get supportsMouseEvents() {
        return this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents;
    }
    get applyStyles() {
        return this._env || this.setEnv("browser"), this.envContribution.applyStyles;
    }
    constructor(contributions) {
        this.contributions = contributions, this.hooks = {
            onSetEnv: new tapable_1.SyncHook([ "lastEnv", "env", "global" ])
        }, this.measureTextMethod = "native";
    }
    bindContribution(params) {
        this.contributions.getContributions().forEach((contribution => {
            contribution.configure(this, params);
        }));
    }
    setEnv(env, params) {
        (params && !0 === params.force || this._env !== env) && (this.deactiveCurrentEnv(), 
        this.activeEnv(env, params));
    }
    deactiveCurrentEnv() {
        this.envContribution && this.envContribution.release();
    }
    activeEnv(env, params) {
        const lastEnv = this._env;
        this._env = env, this.bindContribution(params), this.envParams = params, this.hooks.onSetEnv.call(lastEnv, env, this);
    }
    setActiveEnvContribution(contribution) {
        this.envContribution = contribution;
    }
    createCanvas(params) {
        return this._env || this.setEnv("browser"), this.envContribution.createCanvas(params);
    }
    createOffscreenCanvas(params) {
        return this._env || this.setEnv("browser"), this.envContribution.createOffscreenCanvas(params);
    }
    releaseCanvas(canvas) {
        return this._env || this.setEnv("browser"), this.envContribution.releaseCanvas(canvas);
    }
    addEventListener(type, listener, options) {
        return this._env || this.setEnv("browser"), this.envContribution.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
        return this._env || this.setEnv("browser"), this.envContribution.removeEventListener(type, listener, options);
    }
    dispatchEvent(event) {
        return this._env || this.setEnv("browser"), this.envContribution.dispatchEvent(event);
    }
    getRequestAnimationFrame() {
        return this._env || this.setEnv("browser"), this.envContribution.getRequestAnimationFrame();
    }
    getCancelAnimationFrame() {
        return this._env || this.setEnv("browser"), this.envContribution.getCancelAnimationFrame();
    }
    getElementById(str) {
        return this._env || this.setEnv("browser"), this.envContribution.getElementById ? this.envContribution.getElementById(str) : null;
    }
    getRootElement() {
        return this._env || this.setEnv("browser"), this.envContribution.getRootElement ? this.envContribution.getRootElement() : null;
    }
    getDocument() {
        return this._env || this.setEnv("browser"), this.envContribution.getDocument ? this.envContribution.getDocument() : null;
    }
    mapToCanvasPoint(event, domElement) {
        return this._env || this.setEnv("browser"), this.envContribution.mapToCanvasPoint ? this.envContribution.mapToCanvasPoint(event, domElement) : null;
    }
    loadImage(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadImage(url);
    }
    loadSvg(str) {
        return this._env || this.setEnv("browser"), this.envContribution.loadSvg(str);
    }
    loadJson(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadJson(url);
    }
    loadArrayBuffer(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadArrayBuffer(url);
    }
    loadBlob(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadBlob(url);
    }
};

DefaultGlobal = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(constants_1.EnvContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultGlobal), 
exports.DefaultGlobal = DefaultGlobal;
//# sourceMappingURL=global.js.map
}, function(modId) { var map = {"../common/contribution-provider":1689069767672,"../tapable":1689069767673,"../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767672, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.bindContributionProvider = exports.ContributionProvider = void 0, exports.ContributionProvider = Symbol("ContributionProvider");

class ContributionProviderCache {
    constructor(serviceIdentifier, container) {
        this.serviceIdentifier = serviceIdentifier, this.container = container;
    }
    getContributions() {
        return this.caches || (this.caches = [], this.container && this.caches.push(...this.container.getAll(this.serviceIdentifier))), 
        this.caches;
    }
}

function bindContributionProvider(bind, id) {
    bind(exports.ContributionProvider).toDynamicValue((({container: container}) => new ContributionProviderCache(id, container))).inSingletonScope().whenTargetNamed(id);
}

exports.bindContributionProvider = bindContributionProvider;
//# sourceMappingURL=contribution-provider.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767673, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./SyncHook"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./SyncHook":1689069767674}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767674, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.SyncHook = void 0;

const Hook_1 = require("./Hook");

class SyncHook extends Hook_1.Hook {
    call(...args) {
        this.taps.map((t => t.fn)).forEach((cb => cb(...args)));
    }
}

exports.SyncHook = SyncHook;
//# sourceMappingURL=SyncHook.js.map

}, function(modId) { var map = {"./Hook":1689069767675}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767675, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Hook = void 0;

class Hook {
    constructor(args, name) {
        this._args = args, this.name = name, this.taps = [];
    }
    tap(options, fn) {
        this._tap("sync", options, fn);
    }
    unTap(options, fn) {
        const name = "string" == typeof options ? options.trim() : options.name;
        name && (this.taps = this.taps.filter((tap => tap.name !== name && (!fn || tap.fn === fn))));
    }
    _parseOptions(type, options, fn) {
        let _options;
        if ("string" == typeof options) _options = {
            name: options.trim()
        }; else if ("object" != typeof options || null === options) throw new Error("Invalid tap options");
        if ("string" != typeof _options.name || "" === _options.name) throw new Error("Missing name for tap");
        return _options = Object.assign({
            type: type,
            fn: fn
        }, _options), _options;
    }
    _tap(type, options, fn) {
        this._insert(this._parseOptions(type, options, fn));
    }
    _insert(item) {
        let before;
        "string" == typeof item.before ? before = new Set([ item.before ]) : Array.isArray(item.before) && (before = new Set(item.before));
        let stage = 0;
        "number" == typeof item.stage && (stage = item.stage);
        let i = this.taps.length;
        for (;i > 0; ) {
            i--;
            const x = this.taps[i];
            this.taps[i + 1] = x;
            const xStage = x.stage || 0;
            if (before) {
                if (before.has(x.name)) {
                    before.delete(x.name);
                    continue;
                }
                if (before.size > 0) continue;
            }
            if (!(xStage > stage)) {
                i++;
                break;
            }
        }
        this.taps[i] = item;
    }
}

exports.Hook = Hook;
//# sourceMappingURL=Hook.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767676, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Global = exports.EnvContribution = void 0, exports.EnvContribution = Symbol.for("EnvContribution"), 
exports.Global = Symbol.for("Global");
//# sourceMappingURL=constants.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767677, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultTransformUtil = exports.DefaultGraphicUtil = void 0;

const inversify_1 = require("inversify"), textMeasure_contribution_1 = require("./contributions/textMeasure/textMeasure-contribution"), contribution_provider_1 = require("../common/contribution-provider"), util_1 = require("../canvas/util"), config_1 = require("../graphic/config"), vutils_1 = require("@visactor/vutils"), constants_1 = require("../constants");

let DefaultGraphicUtil = class {
    constructor(contributions, global) {
        this.contributions = contributions, this.global = global, this.configured = !1, 
        this.global.hooks.onSetEnv.tap("graphic-util", ((lastEnv, env, global) => {
            this.configured = !1, this.configure(global, env);
        }));
    }
    get textMeasure() {
        return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;
    }
    configure(global, env) {
        if (this.configured) return;
        const canvas = (0, util_1.wrapCanvas)({
            nativeCanvas: global.createCanvas({
                width: 100,
                height: 100
            })
        });
        this.canvas = canvas, this.context = canvas.getContext("2d"), this.contributions.getContributions().forEach((contribution => {
            contribution.configure(this, env);
        })), this.configured = !0;
    }
    bindTextMeasure(tm) {
        this._textMeasure = tm;
    }
    measureText(text, tc, method = "native") {
        var _a;
        this.configure(this.global, this.global.env);
        const m = this.global.measureTextMethod;
        this.global.measureTextMethod = method;
        const data = {
            width: this._textMeasure.measureTextWidth(text, tc),
            height: null !== (_a = tc.fontSize) && void 0 !== _a ? _a : config_1.DefaultTextStyle.fontSize
        };
        return this.global.measureTextMethod = m, data;
    }
    createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
        return this.configure(this.global, this.global.env), new vutils_1.TextMeasure(Object.assign({
            defaultFontParams: {
                fontFamily: config_1.DefaultTextStyle.fontFamily,
                fontSize: config_1.DefaultTextStyle.fontSize
            },
            getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas),
            getTextBounds: void 0,
            specialCharSet: "-/: .,@%'\"~" + vutils_1.TextMeasure.ALPHABET_CHAR_SET + vutils_1.TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
        }, null != option ? option : {}), textSpec);
    }
};

var TransformMode;

DefaultGraphicUtil = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(textMeasure_contribution_1.TextMeasureContribution)), __param(1, (0, 
inversify_1.inject)(constants_1.Global)), __metadata("design:paramtypes", [ Object, Object ]) ], DefaultGraphicUtil), 
exports.DefaultGraphicUtil = DefaultGraphicUtil, function(TransformMode) {
    TransformMode[TransformMode.transform = 0] = "transform", TransformMode[TransformMode.matrix = 1] = "matrix";
}(TransformMode || (TransformMode = {}));

const _matrix = new vutils_1.Matrix;

let DefaultTransformUtil = class {
    constructor() {
        this.matrix = new vutils_1.Matrix;
    }
    init(origin) {
        return this.mode = TransformMode.transform, this.originTransform = origin, this.matrix.reset(), 
        this;
    }
    fromMatrix(source, target) {
        return this.mode = TransformMode.matrix, this.outSourceMatrix = source, this.outTargetMatrix = target, 
        this;
    }
    scaleMatrix(sx, sy, center) {
        const sMatrix = this.outSourceMatrix;
        if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), 
        this.outTargetMatrix.reset(), center) {
            const {x: x, y: y} = center;
            this.outTargetMatrix.translate(x, y), this.outTargetMatrix.scale(sx, sy), this.outTargetMatrix.translate(-x, -y);
        } else this.outTargetMatrix.scale(sx, sy);
        return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), 
        this;
    }
    scale(sx, sy, center) {
        return this.mode === TransformMode.matrix ? this.scaleMatrix(sx, sy, center) : this;
    }
    translateMatrix(dx, dy) {
        const sMatrix = this.outSourceMatrix;
        return _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), 
        this.outTargetMatrix.reset(), this.outTargetMatrix.translate(dx, dy), this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), 
        this;
    }
    translate(dx, dy) {
        return this.mode === TransformMode.matrix ? this.translateMatrix(dx, dy) : this;
    }
    simplify(target) {
        return this.mode === TransformMode.matrix ? this.simplifyMatrix(target) : this;
    }
    simplifyMatrix(target) {
        return this;
    }
};

DefaultTransformUtil = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", []) ], DefaultTransformUtil), 
exports.DefaultTransformUtil = DefaultTransformUtil;
//# sourceMappingURL=graphic-utils.js.map
}, function(modId) { var map = {"./contributions/textMeasure/textMeasure-contribution":1689069767678,"../common/contribution-provider":1689069767672,"../canvas/util":1689069767701,"../graphic/config":1689069767680,"../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767678, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultTextMeasureContribution = exports.TextMeasureContribution = void 0;

const inversify_1 = require("inversify"), AtextMeasure_1 = require("./AtextMeasure");

exports.TextMeasureContribution = Symbol.for("TextMeasureContribution");

let DefaultTextMeasureContribution = class extends AtextMeasure_1.ATextMeasure {};

DefaultTextMeasureContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultTextMeasureContribution), 
exports.DefaultTextMeasureContribution = DefaultTextMeasureContribution;
//# sourceMappingURL=textMeasure-contribution.js.map

}, function(modId) { var map = {"./AtextMeasure":1689069767679}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767679, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ATextMeasure = void 0;

const inversify_1 = require("inversify"), config_1 = require("../../../graphic/config");

let ATextMeasure = class {
    configure(service, env) {
        this.canvas = service.canvas, this.context = service.context, service.bindTextMeasure(this);
    }
    measureTextWidth(text, options) {
        if (!this.context) return this.estimate(text, options).width;
        this.context.setTextStyleWithoutAlignBaseline(options);
        return this.context.measureText(text).width;
    }
    estimate(text, {fontSize: fontSize = config_1.DefaultTextAttribute.fontSize}) {
        let eCharLen = 0, cCharLen = 0;
        for (let i = 0; i < text.length; i++) text.charCodeAt(i) < 128 ? eCharLen++ : cCharLen++;
        return {
            width: ~~(.8 * eCharLen * fontSize + cCharLen * fontSize),
            height: fontSize
        };
    }
    measureTextPixelHeight(text, options) {
        var _a;
        if (!this.context) return null !== (_a = options.fontSize) && void 0 !== _a ? _a : config_1.DefaultTextStyle.fontSize;
        this.context.setTextStyleWithoutAlignBaseline(options);
        const textMeasure = this.context.measureText(text);
        return Math.abs(textMeasure.actualBoundingBoxAscent - textMeasure.actualBoundingBoxDescent);
    }
    measureTextBoundHieght(text, options) {
        var _a;
        if (!this.context) return null !== (_a = options.fontSize) && void 0 !== _a ? _a : config_1.DefaultTextStyle.fontSize;
        this.context.setTextStyleWithoutAlignBaseline(options);
        const textMeasure = this.context.measureText(text);
        return Math.abs(textMeasure.fontBoundingBoxAscent - textMeasure.fontBoundingBoxDescent);
    }
    measureText(text, options) {
        return this.context ? (this.context.setTextStyleWithoutAlignBaseline(options), this.context.measureText(text)) : this.estimate(text, options);
    }
    clipText(text, options, width) {
        if (0 === text.length) return {
            str: "",
            width: 0
        };
        let length = this.measureTextWidth(text, options);
        return length <= width ? {
            str: text,
            width: length
        } : (length = this.measureTextWidth(text[0], options), length > width ? {
            str: "",
            width: 0
        } : this._clipText(text, options, width, 0, text.length - 1));
    }
    _clipText(text, options, width, leftIdx, rightIdx) {
        const middleIdx = Math.floor((leftIdx + rightIdx) / 2), subText = text.substring(0, middleIdx + 1), strWidth = this.measureTextWidth(subText, options);
        let length;
        if (strWidth > width) {
            if (subText.length <= 1) return {
                str: "",
                width: 0
            };
            const str = text.substring(0, middleIdx);
            return length = this.measureTextWidth(str, options), length <= width ? {
                str: str,
                width: length
            } : this._clipText(text, options, width, leftIdx, middleIdx);
        }
        if (strWidth < width) {
            if (middleIdx >= text.length - 1) return {
                str: text,
                width: this.measureTextWidth(text, options)
            };
            const str = text.substring(0, middleIdx + 2);
            return length = this.measureTextWidth(str, options), length >= width ? {
                str: subText,
                width: strWidth
            } : this._clipText(text, options, width, middleIdx, rightIdx);
        }
        return {
            str: subText,
            width: strWidth
        };
    }
    clipTextWithSuffix(text, options, width, suffix) {
        if ("" === suffix) return this.clipText(text, options, width);
        if (0 === text.length) return {
            str: "",
            width: 0
        };
        const length = this.measureTextWidth(text, options);
        if (length <= width) return {
            str: text,
            width: length
        };
        const suffixWidth = this.measureTextWidth(suffix, options);
        if (suffixWidth > width) return {
            str: "",
            width: 0
        };
        width -= suffixWidth;
        const data = this._clipText(text, options, width, 0, text.length - 1);
        return data.str += suffix, data.width += suffixWidth, data;
    }
};

ATextMeasure = __decorate([ (0, inversify_1.injectable)() ], ATextMeasure), exports.ATextMeasure = ATextMeasure;
//# sourceMappingURL=AtextMeasure.js.map

}, function(modId) { var map = {"../../../graphic/config":1689069767680}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767680, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultRichTextIconAttribute = exports.DefaultImageAttribute = exports.DefaultRichTextAttribute = exports.DefaultTextAttribute = exports.DefaultSymbolAttribute = exports.DefaultRect3dAttribute = exports.DefaultRectAttribute = exports.DefaultPolygonAttribute = exports.DefaultPathAttribute = exports.DefaultLineAttribute = exports.DefaultGlyphAttribute = exports.DefaultGroupAttribute = exports.DefaultCircleAttribute = exports.DefaultAreaAttribute = exports.DefaultArcAttribute = exports.rewriteProto = exports.addAttributeToPrototype = exports.DefaultAttribute = exports.DefaultStyle = exports.DefaultTextStyle = exports.DefaultStrokeStyle = exports.DefaultFillStyle = exports.DefaultTransform = void 0;

const vutils_1 = require("@visactor/vutils"), custom_path2d_1 = require("../common/custom-path2d");

exports.DefaultTransform = {
    x: 0,
    y: 0,
    z: 0,
    dx: 0,
    dy: 0,
    dz: 0,
    scrollX: 0,
    scrollY: 0,
    scaleX: 1,
    scaleY: 1,
    scaleZ: 1,
    angle: 0,
    alpha: 0,
    beta: 0,
    anchor: [ 0, 0 ],
    anchor3d: [ 0, 0 ],
    postMatrix: new vutils_1.Matrix
}, exports.DefaultFillStyle = {
    fillOpacity: 1,
    fill: !1,
    shadowBlur: 0,
    shadowColor: "black",
    shadowOffsetX: 0,
    shadowOffsetY: 0
};

const commonStroke = {
    strokeOpacity: 1,
    lineDash: [],
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: "butt",
    lineJoin: "miter",
    miterLimit: 10,
    strokeBoundsBuffer: 2,
    stroke: !1
};

function addAttributeToPrototype(obj, c, keys) {
    keys.forEach((key => {
        c.prototype[key] = obj[key];
    }));
}

function rewriteProto(obj, c) {
    Object.setPrototypeOf(obj, c);
}

exports.DefaultStrokeStyle = Object.assign({
    outerBorder: Object.assign(Object.assign({}, commonStroke), {
        distance: 0
    }),
    innerBorder: Object.assign(Object.assign({}, commonStroke), {
        distance: 0
    })
}, commonStroke), exports.DefaultTextStyle = {
    text: "",
    maxLineWidth: 1 / 0,
    textAlign: "left",
    textBaseline: "alphabetic",
    fontSize: 16,
    fontFamily: "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
    fontWeight: "",
    ellipsis: "…",
    fontVariant: "",
    fontStyle: "",
    lineHeight: void 0,
    underline: 0,
    lineThrough: 0,
    scaleIn3d: !1
}, exports.DefaultStyle = Object.assign(Object.assign({
    opacity: 1,
    background: null,
    texture: null,
    textureColor: "black",
    textureSize: 10,
    texturePadding: 2,
    backgroundMode: 0,
    blur: 0,
    cursor: null
}, exports.DefaultFillStyle), exports.DefaultStrokeStyle), exports.DefaultAttribute = Object.assign(Object.assign({
    strokeSeg: null,
    pickable: !0,
    childrenPickable: !0,
    visible: !0,
    zIndex: 0,
    layout: null,
    boundsPadding: 0,
    pickMode: "accurate",
    customPickShape: null,
    boundsMode: "accurate",
    keepDirIn3d: !0
}, exports.DefaultStyle), exports.DefaultTransform), exports.addAttributeToPrototype = addAttributeToPrototype, 
exports.rewriteProto = rewriteProto, exports.DefaultArcAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    startAngle: 0,
    endAngle: vutils_1.pi2,
    innerRadius: 0,
    outerRadius: 1,
    cornerRadius: 0,
    padRadius: 0,
    padAngle: 0,
    cap: !1,
    forceShowCap: !1
}), exports.DefaultAreaAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    points: [],
    segments: [],
    curveType: "linear",
    clipRange: 1
}), exports.DefaultCircleAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    radius: 1,
    startAngle: 0,
    endAngle: vutils_1.pi2
}), exports.DefaultGroupAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    width: 0,
    height: 0,
    cornerRadius: 0,
    path: [],
    clip: !1,
    visibleAll: !0
}), exports.DefaultGlyphAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    path: "",
    width: 0,
    height: 0,
    cornerRadius: 0,
    clip: !1
}), exports.DefaultLineAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    points: [],
    segments: [],
    curveType: "linear",
    clipRange: 1,
    clipRangeByDimension: "default"
}), exports.DefaultPathAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    path: new custom_path2d_1.CustomPath2D,
    customPath: () => {
        console.warn("空函数");
    }
}), exports.DefaultPolygonAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    points: [],
    cornerRadius: 0
}), exports.DefaultRectAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    width: 0,
    height: 0,
    strokeBoundsBuffer: 0,
    cornerRadius: 0
}), exports.DefaultRect3dAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    width: 0,
    height: 0,
    cornerRadius: 0,
    length: 0
}), exports.DefaultSymbolAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    symbolType: "circle",
    size: 10,
    keepDirIn3d: !0
}), exports.DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, exports.DefaultAttribute), exports.DefaultTextStyle), {
    strokeBoundsBuffer: 0,
    keepDirIn3d: !0
}), exports.DefaultRichTextAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {
    width: 300,
    height: 300,
    ellipsis: !0,
    wordBreak: "break-word",
    verticalDirection: "top",
    textAlign: "left",
    textBaseline: "top",
    layoutDirection: "horizontal",
    textConfig: [],
    maxHeight: void 0,
    maxWidth: void 0,
    singleLine: !1
}), exports.DefaultImageAttribute = Object.assign(Object.assign({
    repeatX: "no-repeat",
    repeatY: "no-repeat",
    image: "",
    width: 0,
    height: 0
}, exports.DefaultAttribute), {
    fill: !0
}), exports.DefaultRichTextIconAttribute = Object.assign(Object.assign({}, exports.DefaultImageAttribute), {
    backgroundShowMode: "never",
    backgroundWidth: 0,
    backgroundHeight: 0,
    textAlign: "left",
    textBaseline: "middle",
    direction: "horizontal",
    margin: 0,
    id: "",
    width: 20,
    height: 20,
    backgroundFill: "rgba(101, 117, 168, 0.1)",
    backgroundFillOpacity: 1,
    backgroundStroke: !1,
    backgroundStrokeOpacity: 1,
    backgroundRadius: 4,
    opacity: 1
});
//# sourceMappingURL=config.js.map

}, function(modId) { var map = {"../common/custom-path2d":1689069767681}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767681, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CustomPath2D = void 0;

const bounds_context_1 = require("./bounds-context"), path_1 = require("./segment/curve/path"), path_svg_1 = require("./path-svg"), vutils_1 = require("@visactor/vutils"), enums_1 = require("./enums"), arc_1 = require("./shape/arc"), render_command_list_1 = require("./render-command-list"), segment_1 = require("./segment");

class CustomPath2D extends path_1.CurvePath {
    constructor(ctx) {
        super(), this.commandList = [], ctx && (this._ctx = ctx), this._boundsContext = new bounds_context_1.BoundsContext(this.bounds);
    }
    setCtx(ctx) {
        this._ctx = ctx;
    }
    moveTo(x, y) {
        return this.commandList.push([ path_svg_1.enumCommandMap.M, x, y ]), this._ctx && this._ctx.moveTo(x, y), 
        this;
    }
    lineTo(x, y) {
        return this.commandList.push([ path_svg_1.enumCommandMap.L, x, y ]), this._ctx && this._ctx.lineTo(x, y), 
        this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        return this.commandList.push([ path_svg_1.enumCommandMap.Q, aCPx, aCPy, aX, aY ]), 
        this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY), this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        return this.commandList.push([ path_svg_1.enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ]), 
        this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;
    }
    arcTo(aX1, aY1, aX2, aY2, aRadius) {
        return this.commandList.push([ path_svg_1.enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius ]), 
        this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius), this;
    }
    ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
        return this.commandList.push([ path_svg_1.enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise ]), 
        this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise), 
        this;
    }
    rect(x, y, w, h) {
        return this.commandList.push([ path_svg_1.enumCommandMap.R, x, y, w, h ]), this._ctx && this._ctx.rect(x, y, w, h), 
        this;
    }
    arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        return this.commandList.push([ path_svg_1.enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise ]), 
        this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise), 
        this;
    }
    closePath() {
        return this.commandList.push([ path_svg_1.enumCommandMap.Z ]), this._ctx && this._ctx.closePath(), 
        this;
    }
    addCurve(curve) {
        this.curves.push(curve);
    }
    clear() {
        this.transformCbList = null, this.commandList.length = 0, this.curves.length = 0;
    }
    toString() {
        if (!this.toStringCbList) {
            const list = [];
            list[path_svg_1.enumCommandMap.M] = cmd => `M${cmd[1]} ${cmd[2]}`, list[path_svg_1.enumCommandMap.L] = cmd => `L${cmd[1]} ${cmd[2]}`, 
            list[path_svg_1.enumCommandMap.Q] = cmd => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`, 
            list[path_svg_1.enumCommandMap.C] = cmd => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`, 
            list[path_svg_1.enumCommandMap.A] = cmd => {
                const bezierPathList = [];
                (0, arc_1.addArcToBezierPath)(bezierPathList, cmd[4], cmd[5], cmd[1], cmd[2], cmd[3], cmd[3]);
                let path = "";
                for (let i = 0; i < bezierPathList.length; i += 6) path += `C${bezierPathList[i]} ${bezierPathList[i + 1]} ${bezierPathList[i + 2]} ${bezierPathList[i + 3]} ${bezierPathList[i + 4]} ${bezierPathList[i + 5]}`;
                return path;
            }, list[path_svg_1.enumCommandMap.Z] = cmd => "Z", this.toStringCbList = list;
        }
        const list = this.toStringCbList;
        let path = "";
        return this.commandList.forEach((c => {
            path += list[c[0]](c);
        })), path;
    }
    fromString(str, x, y, sX, sY) {
        this.clear();
        const commandStrList = (0, path_svg_1.parseSvgPath)(str);
        return this._runCommandStrList(commandStrList, x, y, sX, sY), this._updateBounds(), 
        this;
    }
    fromLine(line) {
        const {points: points, curveType: curveType, clipRangeByDimension: clipRangeByDimension} = line.attribute;
        if (!points) return;
        const cache = (0, segment_1.calcLineCache)(points, curveType);
        "x" === clipRangeByDimension ? this.direction = enums_1.Direction.ROW : "y" === clipRangeByDimension ? this.direction = enums_1.Direction.COLUMN : "auto" === clipRangeByDimension && (this.direction = cache.direction), 
        this.curves = cache.curves;
    }
    fromCustomPath2D(path, x, y, sX, sY) {
        return this.clear(), this._runCommandList(path.commandList, x, y, sX, sY), this._updateBounds(), 
        this;
    }
    transform(x, y, sx, sy) {
        const commandList = this.commandList;
        if (!this.transformCbList) {
            const list = [];
            list[path_svg_1.enumCommandMap.M] = this.moveToTransform, list[path_svg_1.enumCommandMap.L] = this.lineToTransform, 
            list[path_svg_1.enumCommandMap.Q] = this.quadraticCurveToTransform, list[path_svg_1.enumCommandMap.C] = this.bezierCurveToTransform, 
            list[path_svg_1.enumCommandMap.AT] = this.arcToTransform, list[path_svg_1.enumCommandMap.E] = this.ellipseTransform, 
            list[path_svg_1.enumCommandMap.R] = this.rectTransform, list[path_svg_1.enumCommandMap.A] = this.arcTransform, 
            list[path_svg_1.enumCommandMap.Z] = this.closePathTransform, this.transformCbList = list;
        }
        commandList.forEach((cmd => {
            this.transformCbList[cmd[0]](cmd, x, y, sx, sy);
        })), this._updateBounds();
    }
    moveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
    }
    lineToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
    }
    quadraticCurveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y;
    }
    bezierCurveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, 
        cmd[5] = cmd[5] * sx + x, cmd[6] = cmd[6] * sy + y;
    }
    arcToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, 
        cmd[5] = cmd[5] * (sx + sy) / 2;
    }
    ellipseTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
    }
    rectTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
    }
    arcTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * (sx + sy) / 2;
    }
    closePathTransform() {}
    _runCommandStrList(commandStrList, l = 0, t = 0, sX = 1, sY = 1) {
        let current, tempX, tempY, tempControlX, tempControlY, previous = null, x = 0, y = 0, controlX = 0, controlY = 0;
        for (let i = 0, len = commandStrList.length; i < len; ++i) {
            switch (current = commandStrList[i], 1 === sX && 1 === sY || (current = scale(current, sX, sY)), 
            current[0]) {
              case "l":
                x += current[1], y += current[2], this.lineTo(x + l, y + t);
                break;

              case "L":
                x = current[1], y = current[2], this.lineTo(x + l, y + t);
                break;

              case "h":
                x += current[1], this.lineTo(x + l, y + t);
                break;

              case "H":
                x = current[1], this.lineTo(x + l, y + t);
                break;

              case "v":
                y += current[1], this.lineTo(x + l, y + t);
                break;

              case "V":
                y = current[1], this.lineTo(x + l, y + t);
                break;

              case "m":
                x += current[1], y += current[2], this.moveTo(x + l, y + t);
                break;

              case "M":
                x = current[1], y = current[2], this.moveTo(x + l, y + t);
                break;

              case "c":
                tempX = x + current[5], tempY = y + current[6], controlX = x + current[3], controlY = y + current[4], 
                this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t), 
                x = tempX, y = tempY;
                break;

              case "C":
                x = current[5], y = current[6], controlX = current[3], controlY = current[4], this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
                break;

              case "s":
                tempX = x + current[3], tempY = y + current[4], controlX = 2 * x - controlX, controlY = 2 * y - controlY, 
                this.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t), 
                controlX = x + current[1], controlY = y + current[2], x = tempX, y = tempY;
                break;

              case "S":
                tempX = current[3], tempY = current[4], controlX = 2 * x - controlX, controlY = 2 * y - controlY, 
                this.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t), 
                x = tempX, y = tempY, controlX = current[1], controlY = current[2];
                break;

              case "q":
                tempX = x + current[3], tempY = y + current[4], controlX = x + current[1], controlY = y + current[2], 
                this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, 
                y = tempY;
                break;

              case "Q":
                tempX = current[3], tempY = current[4], this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t), 
                x = tempX, y = tempY, controlX = current[1], controlY = current[2];
                break;

              case "t":
                tempX = x + current[1], tempY = y + current[2], null === previous[0].match(/[QqTt]/) ? (controlX = x, 
                controlY = y) : "t" === previous[0] ? (controlX = 2 * x - tempControlX, controlY = 2 * y - tempControlY) : "q" === previous[0] && (controlX = 2 * x - controlX, 
                controlY = 2 * y - controlY), tempControlX = controlX, tempControlY = controlY, 
                this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, 
                y = tempY, controlX = x + current[1], controlY = y + current[2];
                break;

              case "T":
                tempX = current[1], tempY = current[2], controlX = 2 * x - controlX, controlY = 2 * y - controlY, 
                this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, 
                y = tempY;
                break;

              case "a":
                (0, arc_1.drawArc)(this, x + l, y + t, [ current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t ]), 
                x += current[6], y += current[7];
                break;

              case "A":
                (0, arc_1.drawArc)(this, x + l, y + t, [ current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t ]), 
                x = current[6], y = current[7];
                break;

              case "z":
              case "Z":
                this.closePath();
            }
            previous = current;
        }
    }
    _runCommandList(commandList, l = 0, t = 0, sX = 1, sY = 1) {
        if (0 !== l || 0 !== t || 1 !== sX || 1 !== sY) for (let i = 0, len = commandList.length; i < len; ++i) {
            const current = commandList[i].slice();
            switch (current[0]) {
              case path_svg_1.enumCommandMap.L:
                this.lineToTransform(current, l, t, sX, sY);
                break;

              case path_svg_1.enumCommandMap.M:
                this.moveToTransform(current, l, t, sX, sY);
                break;

              case path_svg_1.enumCommandMap.C:
                this.bezierCurveToTransform(current, l, t, sX, sY);
                break;

              case path_svg_1.enumCommandMap.Q:
                this.quadraticCurveToTransform(current, l, t, sX, sY);
                break;

              case path_svg_1.enumCommandMap.A:
                this.arcToTransform(current, l, t, sX, sY);
                break;

              case path_svg_1.enumCommandMap.E:
                this.ellipseTransform(current, l, t, sX, sY);
                break;

              case path_svg_1.enumCommandMap.R:
                this.rectTransform(current, l, t, sX, sY);
                break;

              case path_svg_1.enumCommandMap.AT:
                this.arcToTransform(current, l, t, sX, sY);
                break;

              case path_svg_1.enumCommandMap.Z:
                this.closePath();
            }
        } else this.commandList = commandList.map((entry => entry.slice()));
    }
    _updateBounds() {
        this.bounds.clear(), (0, render_command_list_1.renderCommandList)(this.commandList, this._boundsContext);
    }
    release() {
        this.commandList = [], this._boundsContext = null, this._ctx = null;
    }
    getLength() {
        if (this.direction === enums_1.Direction.COLUMN) {
            if (!this.curves.length) return 0;
            const sc = this.curves[0], ec = this.curves[this.curves.length - 1];
            return (0, vutils_1.abs)(sc.p0.y - ec.p1.y);
        }
        if (this.direction === enums_1.Direction.ROW) {
            if (!this.curves.length) return 0;
            const sc = this.curves[0], ec = this.curves[this.curves.length - 1];
            return (0, vutils_1.abs)(sc.p0.x - ec.p1.x);
        }
        return this.curves.reduce(((l, c) => l + c.getLength()), 0);
    }
    getAttrAt(distance) {
        if (!this.curves) return {
            pos: {
                x: 0,
                y: 0
            },
            angle: 0
        };
        let curve, _dis = 0;
        for (let i = 0; i < this.curves.length; i++) {
            curve = this.curves[i];
            const cl = curve.getLength(this.direction);
            if (_dis + cl >= distance) break;
            _dis += cl;
        }
        const t = (distance - _dis) / curve.getLength(this.direction);
        return {
            pos: curve.getPointAt(t),
            angle: curve.getAngleAt(t)
        };
    }
}

exports.CustomPath2D = CustomPath2D;

const temp = [ "l", 0, 0, 0, 0, 0, 0, 0 ];

function scale(current, sX, sY) {
    const c = temp[0] = current[0];
    if ("a" === c || "A" === c) temp[1] = sX * current[1], temp[2] = sY * current[2], 
    temp[3] = current[3], temp[4] = current[4], temp[5] = current[5], temp[6] = sX * current[6], 
    temp[7] = sY * current[7]; else if ("h" === c || "H" === c) temp[1] = sX * current[1]; else if ("v" === c || "V" === c) temp[1] = sY * current[1]; else for (let i = 1, n = current.length; i < n; ++i) temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
    return temp;
}
}, function(modId) { var map = {"./bounds-context":1689069767682,"./segment/curve/path":1689069767683,"./path-svg":1689069767684,"./enums":1689069767685,"./shape/arc":1689069767686,"./render-command-list":1689069767687,"./segment":1689069767688}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767682, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BoundsContext = void 0;

const vutils_1 = require("@visactor/vutils"), circleThreshold = vutils_1.tau - 1e-8;

class BoundsContext {
    constructor(bounds) {
        this.init(bounds);
    }
    init(bounds) {
        this.bounds = bounds;
    }
    arc(cx, cy, r, sa, ea, ccw) {
        if (Math.abs(ea - sa) > circleThreshold) return this.bounds.add(cx - r, cy - r), 
        void this.bounds.add(cx + r, cy + r);
        let s, i, x, y, xmin = 1 / 0, xmax = -1 / 0, ymin = 1 / 0, ymax = -1 / 0;
        function update(a) {
            x = r * Math.cos(a), y = r * Math.sin(a), x < xmin && (xmin = x), x > xmax && (xmax = x), 
            y < ymin && (ymin = y), y > ymax && (ymax = y);
        }
        if (update(sa), update(ea), ea !== sa) if ((sa %= vutils_1.tau) < 0 && (sa += vutils_1.tau), 
        (ea %= vutils_1.tau) < 0 && (ea += vutils_1.tau), ea < sa && (ccw = !ccw, s = sa, 
        sa = ea, ea = s), ccw) for (ea -= vutils_1.tau, s = sa - sa % vutils_1.halfPi, i = 0; i < 4 && s > ea; ++i, 
        s -= vutils_1.halfPi) update(s); else for (s = sa - sa % vutils_1.halfPi + vutils_1.halfPi, 
        i = 0; i < 4 && s < ea; ++i, s += vutils_1.halfPi) update(s);
        this.bounds.add(cx + xmin, cy + ymin), this.bounds.add(cx + xmax, cy + ymax);
    }
    arcTo(x1, y1, x2, y2, radius) {
        throw new Error("不支持arcTo");
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.bounds.add(cp1x, cp1y), this.bounds.add(cp2x, cp2y), this.bounds.add(x, y);
    }
    closePath() {}
    ellipse() {
        throw new Error("不支持ellipse");
    }
    lineTo(x, y) {
        this.bounds.add(x, y);
    }
    moveTo(x, y) {
        this.bounds.add(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
        this.bounds.add(cpx, cpy), this.bounds.add(x, y);
    }
    rect(x, y, w, h) {
        this.bounds.add(x, y), this.bounds.add(x + w, y + h);
    }
    clear() {
        this.bounds.clear();
    }
    release(...params) {}
}

exports.BoundsContext = BoundsContext;
//# sourceMappingURL=bounds-context.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767683, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CurvePath = void 0;

const vutils_1 = require("@visactor/vutils");

class CurvePath {
    constructor() {
        this.curves = [], this.bounds = new vutils_1.AABBBounds;
    }
    getCurveLengths() {
        return this.curves.map((curve => curve.getLength()));
    }
    getPointAt(t) {
        return {
            x: 0,
            y: 0
        };
    }
    getLength() {
        return 0;
    }
    getBounds() {
        return this.bounds;
    }
}

exports.CurvePath = CurvePath;
//# sourceMappingURL=path.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767684, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.parseSvgPath = exports.enumCommandMap = void 0;

const rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi, commandLengths = {
    m: 2,
    l: 2,
    h: 1,
    v: 1,
    c: 6,
    s: 4,
    q: 4,
    t: 2,
    a: 7,
    M: 2,
    L: 2,
    H: 1,
    V: 1,
    C: 6,
    S: 4,
    Q: 4,
    T: 2,
    A: 7
};

let currPath, coordsStr, commandChar, coordStr, coordNumber, standardCommandLen;

function parseSvgPath(str) {
    if (!str) return [];
    const paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
    if (null === paths) return [];
    let currCommandData, coordsStrArr;
    const result = [];
    for (let i = 0, len = paths.length; i < len; i++) if (currPath = paths[i], coordsStr = currPath.slice(1), 
    commandChar = currPath[0], currCommandData = [ commandChar ], coordsStrArr = coordsStr.match(rePathCommand), 
    null !== coordsStrArr) {
        for (let i = 0, len = coordsStrArr.length; i < len; i++) coordStr = coordsStrArr[i], 
        coordNumber = parseFloat(coordStr), Number.isNaN(coordNumber) || currCommandData.push(coordNumber);
        if (standardCommandLen = commandLengths[commandChar], currCommandData.length - 1 > standardCommandLen) {
            let subCommand;
            for (let i = 1, len = currCommandData.length; i < len; i += standardCommandLen) {
                subCommand = [ commandChar ];
                for (let j = i, subLen = i + standardCommandLen; j < subLen; j++) subCommand.push(currCommandData[j]);
                result.push(subCommand);
            }
        } else result.push(currCommandData);
    } else result.push(currCommandData);
    return result;
}

exports.enumCommandMap = {
    A: 0,
    AT: 1,
    C: 2,
    Z: 3,
    E: 4,
    L: 5,
    M: 6,
    Q: 7,
    R: 8
}, exports.parseSvgPath = parseSvgPath;
//# sourceMappingURL=path-svg.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767685, function(require, module, exports) {


var UpdateTag, IContainPointMode, AttributeUpdateType, AnimateStatus, AnimateMode, AnimateStepType, Direction, CurveTypeEnum, BaseRenderContributionTime;

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseRenderContributionTime = exports.CurveTypeEnum = exports.Direction = exports.AnimateStepType = exports.AnimateMode = exports.AnimateStatus = exports.AttributeUpdateType = exports.IContainPointMode = exports.UpdateTag = void 0, 
function(UpdateTag) {
    UpdateTag[UpdateTag.NONE = 0] = "NONE", UpdateTag[UpdateTag.UPDATE_BOUNDS = 1] = "UPDATE_BOUNDS", 
    UpdateTag[UpdateTag.UPDATE_SHAPE = 2] = "UPDATE_SHAPE", UpdateTag[UpdateTag.CLEAR_SHAPE = 253] = "CLEAR_SHAPE", 
    UpdateTag[UpdateTag.UPDATE_SHAPE_AND_BOUNDS = 3] = "UPDATE_SHAPE_AND_BOUNDS", UpdateTag[UpdateTag.INIT = 51] = "INIT", 
    UpdateTag[UpdateTag.CLEAR_BOUNDS = 254] = "CLEAR_BOUNDS", UpdateTag[UpdateTag.UPDATE_GLOBAL_MATRIX = 32] = "UPDATE_GLOBAL_MATRIX", 
    UpdateTag[UpdateTag.CLEAR_GLOBAL_MATRIX = 223] = "CLEAR_GLOBAL_MATRIX", UpdateTag[UpdateTag.UPDATE_LOCAL_MATRIX = 16] = "UPDATE_LOCAL_MATRIX", 
    UpdateTag[UpdateTag.CLEAR_LOCAL_MATRIX = 239] = "CLEAR_LOCAL_MATRIX", UpdateTag[UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX";
}(UpdateTag = exports.UpdateTag || (exports.UpdateTag = {})), function(IContainPointMode) {
    IContainPointMode[IContainPointMode.GLOBAL = 1] = "GLOBAL", IContainPointMode[IContainPointMode.LOCAL = 16] = "LOCAL", 
    IContainPointMode[IContainPointMode.GLOBAL_ACCURATE = 3] = "GLOBAL_ACCURATE", IContainPointMode[IContainPointMode.LOCAL_ACCURATE = 48] = "LOCAL_ACCURATE";
}(IContainPointMode = exports.IContainPointMode || (exports.IContainPointMode = {})), 
function(AttributeUpdateType) {
    AttributeUpdateType[AttributeUpdateType.INIT = 0] = "INIT", AttributeUpdateType[AttributeUpdateType.DEFAULT = 1] = "DEFAULT", 
    AttributeUpdateType[AttributeUpdateType.STATE = 2] = "STATE", AttributeUpdateType[AttributeUpdateType.ANIMATE_BIND = 10] = "ANIMATE_BIND", 
    AttributeUpdateType[AttributeUpdateType.ANIMATE_PLAY = 11] = "ANIMATE_PLAY", AttributeUpdateType[AttributeUpdateType.ANIMATE_START = 12] = "ANIMATE_START", 
    AttributeUpdateType[AttributeUpdateType.ANIMATE_UPDATE = 13] = "ANIMATE_UPDATE", 
    AttributeUpdateType[AttributeUpdateType.ANIMATE_END = 14] = "ANIMATE_END", AttributeUpdateType[AttributeUpdateType.TRANSLATE = 20] = "TRANSLATE", 
    AttributeUpdateType[AttributeUpdateType.TRANSLATE_TO = 21] = "TRANSLATE_TO", AttributeUpdateType[AttributeUpdateType.SCALE = 22] = "SCALE", 
    AttributeUpdateType[AttributeUpdateType.SCALE_TO = 23] = "SCALE_TO", AttributeUpdateType[AttributeUpdateType.ROTATE = 24] = "ROTATE", 
    AttributeUpdateType[AttributeUpdateType.ROTATE_TO = 25] = "ROTATE_TO";
}(AttributeUpdateType = exports.AttributeUpdateType || (exports.AttributeUpdateType = {})), 
function(AnimateStatus) {
    AnimateStatus[AnimateStatus.INITIAL = 0] = "INITIAL", AnimateStatus[AnimateStatus.RUNNING = 1] = "RUNNING", 
    AnimateStatus[AnimateStatus.PAUSED = 2] = "PAUSED", AnimateStatus[AnimateStatus.END = 3] = "END";
}(AnimateStatus = exports.AnimateStatus || (exports.AnimateStatus = {})), function(AnimateMode) {
    AnimateMode[AnimateMode.NORMAL = 0] = "NORMAL", AnimateMode[AnimateMode.SET_ATTR_IMMEDIATELY = 1] = "SET_ATTR_IMMEDIATELY";
}(AnimateMode = exports.AnimateMode || (exports.AnimateMode = {})), function(AnimateStepType) {
    AnimateStepType.wait = "wait", AnimateStepType.from = "from", AnimateStepType.to = "to", 
    AnimateStepType.customAnimate = "customAnimate";
}(AnimateStepType = exports.AnimateStepType || (exports.AnimateStepType = {})), 
function(Direction) {
    Direction[Direction.ROW = 1] = "ROW", Direction[Direction.COLUMN = 2] = "COLUMN";
}(Direction = exports.Direction || (exports.Direction = {})), function(CurveTypeEnum) {
    CurveTypeEnum[CurveTypeEnum.CubicBezierCurve = 0] = "CubicBezierCurve", CurveTypeEnum[CurveTypeEnum.QuadraticBezierCurve = 1] = "QuadraticBezierCurve", 
    CurveTypeEnum[CurveTypeEnum.ArcCurve = 2] = "ArcCurve", CurveTypeEnum[CurveTypeEnum.LineCurve = 3] = "LineCurve", 
    CurveTypeEnum[CurveTypeEnum.EllipseCurve = 4] = "EllipseCurve", CurveTypeEnum[CurveTypeEnum.MoveCurve = 5] = "MoveCurve";
}(CurveTypeEnum = exports.CurveTypeEnum || (exports.CurveTypeEnum = {})), function(BaseRenderContributionTime) {
    BaseRenderContributionTime[BaseRenderContributionTime.beforeFillStroke = 0] = "beforeFillStroke", 
    BaseRenderContributionTime[BaseRenderContributionTime.afterFillStroke = 1] = "afterFillStroke";
}(BaseRenderContributionTime = exports.BaseRenderContributionTime || (exports.BaseRenderContributionTime = {}));
//# sourceMappingURL=enums.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767686, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.addArcToBezierPath = exports.drawArc = exports.bezier = exports.segments = void 0;

const vutils_1 = require("@visactor/vutils");

function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
    const th = (0, vutils_1.degreeToRadian)(rotateX), sin_th = Math.sin(th), cos_th = Math.cos(th), px = cos_th * (ox - x) * .5 + sin_th * (oy - y) * .5, py = cos_th * (oy - y) * .5 - sin_th * (ox - x) * .5;
    let pl = px * px / ((rx = Math.abs(rx)) * rx) + py * py / ((ry = Math.abs(ry)) * ry);
    pl > 1 && (pl = Math.sqrt(pl), rx *= pl, ry *= pl);
    const a00 = cos_th / rx, a01 = sin_th / rx, a10 = -sin_th / ry, a11 = cos_th / ry, x0 = a00 * ox + a01 * oy, y0 = a10 * ox + a11 * oy, x1 = a00 * x + a01 * y, y1 = a10 * x + a11 * y;
    let sfactor_sq = 1 / ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) - .25;
    sfactor_sq < 0 && (sfactor_sq = 0);
    let sfactor = Math.sqrt(sfactor_sq);
    sweep === large && (sfactor = -sfactor);
    const xc = .5 * (x0 + x1) - sfactor * (y1 - y0), yc = .5 * (y0 + y1) + sfactor * (x1 - x0), th0 = Math.atan2(y0 - yc, x0 - xc);
    let th_arc = Math.atan2(y1 - yc, x1 - xc) - th0;
    th_arc < 0 && 1 === sweep ? th_arc += vutils_1.tau : th_arc > 0 && 0 === sweep && (th_arc -= vutils_1.tau);
    const segs = Math.ceil(Math.abs(th_arc / (vutils_1.halfPi + .001))), result = [];
    for (let i = 0; i < segs; ++i) {
        const th2 = th0 + i * th_arc / segs, th3 = th0 + (i + 1) * th_arc / segs;
        result[i] = [ xc, yc, th2, th3, rx, ry, sin_th, cos_th ];
    }
    return result;
}

function bezier(params) {
    const cx = params[0], cy = params[1], th0 = params[2], th1 = params[3], rx = params[4], ry = params[5], sin_th = params[6], cos_th = params[7], a00 = cos_th * rx, a01 = -sin_th * ry, a10 = sin_th * rx, a11 = cos_th * ry, cos_th0 = Math.cos(th0), sin_th0 = Math.sin(th0), cos_th1 = Math.cos(th1), sin_th1 = Math.sin(th1), th_half = .5 * (th1 - th0), sin_th_h2 = Math.sin(.5 * th_half), t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half), x1 = cx + cos_th0 - t * sin_th0, y1 = cy + sin_th0 + t * cos_th0, x3 = cx + cos_th1, y3 = cy + sin_th1, x2 = x3 + t * sin_th1, y2 = y3 - t * cos_th1;
    return [ a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3 ];
}

function drawArc(context, x, y, coords) {
    const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);
    for (let i = 0; i < seg.length; ++i) {
        const bez = bezier(seg[i]);
        context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
    }
}

exports.segments = segments, exports.bezier = bezier, exports.drawArc = drawArc;

const addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry) => {
    const delta = Math.abs(endAngle - startAngle), len = 4 * Math.tan(delta / 4) / 3, dir = endAngle < startAngle ? -1 : 1, c1 = Math.cos(startAngle), s1 = Math.sin(startAngle), c2 = Math.cos(endAngle), s2 = Math.sin(endAngle), x1 = c1 * rx + cx, y1 = s1 * ry + cy, x4 = c2 * rx + cx, y4 = s2 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;
    bezierPath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
};

exports.addArcToBezierPath = addArcToBezierPath;
//# sourceMappingURL=arc.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767687, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.renderCommandList = void 0;

const commandFuncs = [ (command, context, x, y, sx, sy, z) => context.arc(command[1] * sx + x, command[2] * sy + y, command[3] * (sx + sy) / 2, command[4], command[5], command[6], z), (command, context, x, y, sx, sy, z) => context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * (sx + sy) / 2, z), (command, context, x, y, sx, sy, z) => context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z), (command, context, x, y) => context.closePath(), (command, context, x, y, sx, sy) => context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]), (command, context, x, y, sx, sy, z) => context.lineTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.moveTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z), (command, context, x, y, sx, sy, z) => context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z) ];

function renderCommandList(commandList, context, x = 0, y = 0, sx = 1, sy = 1, z) {
    for (let i = 0; i < commandList.length; i++) {
        const command = commandList[i];
        commandFuncs[command[0]](command, context, x, y, sx, sy, z);
    }
}

exports.renderCommandList = renderCommandList;
//# sourceMappingURL=render-command-list.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767688, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.calcLineCache = void 0;

const linear_1 = require("./linear"), basis_1 = require("./basis"), monotone_1 = require("./monotone"), step_1 = require("./step"), linear_closed_1 = require("./linear-closed");

function calcLineCache(points, curveType, params) {
    switch (curveType) {
      case "linear":
      default:
        return (0, linear_1.genLinearSegments)(points, params);

      case "basis":
        return (0, basis_1.genBasisSegments)(points, params);

      case "monotoneX":
        return (0, monotone_1.genMonotoneXSegments)(points, params);

      case "monotoneY":
        return (0, monotone_1.genMonotoneYSegments)(points, params);

      case "step":
        return (0, step_1.genStepSegments)(points, .5, params);

      case "stepBefore":
        return (0, step_1.genStepSegments)(points, 0, params);

      case "stepAfter":
        return (0, step_1.genStepSegments)(points, 1, params);

      case "linearClosed":
        return (0, linear_closed_1.genLinearClosedSegments)(points, params);
    }
}

__exportStar(require("./linear"), exports), __exportStar(require("./linear-closed"), exports), 
__exportStar(require("./basis"), exports), __exportStar(require("./monotone"), exports), 
__exportStar(require("./step"), exports), __exportStar(require("./curve/curve-context"), exports), 
exports.calcLineCache = calcLineCache;
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./linear":1689069767689,"./basis":1689069767696,"./monotone":1689069767697,"./step":1689069767698,"./linear-closed":1689069767699,"./curve/curve-context":1689069767700}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767689, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.genLinearTypeSegments = exports.genLinearSegments = exports.Linear = void 0;

const vutils_1 = require("@visactor/vutils"), seg_context_1 = require("../seg-context"), common_1 = require("./common"), enums_1 = require("../enums");

class Linear {
    constructor(context, startPoint) {
        this.context = context, startPoint && (this.startPoint = startPoint);
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._point = 0, this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), 
        this._line = 1 - this._line;
    }
    point(p) {
        const x = p.x, y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined) : this.context.moveTo(x, y);
            break;

          case 1:
            this._point = 2;

          default:
            this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined);
        }
        this._lastDefined = p.defined;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}

function genLinearSegments(points, params = {}) {
    const {direction: direction, startPoint: startPoint} = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    const segContext = new seg_context_1.SegContext("linear", null != direction ? direction : (0, 
    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);
    return genLinearTypeSegments(new Linear(segContext, startPoint), points), segContext;
}

function genLinearTypeSegments(path, points) {
    return (0, common_1.genCurveSegments)(path, points, 1);
}

exports.Linear = Linear, exports.genLinearSegments = genLinearSegments, exports.genLinearTypeSegments = genLinearTypeSegments;
//# sourceMappingURL=linear.js.map

}, function(modId) { var map = {"../seg-context":1689069767690,"./common":1689069767695,"../enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767690, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ReflectSegContext = exports.SegContext = void 0;

const vutils_1 = require("@visactor/vutils"), enums_1 = require("./enums"), cubic_bezier_1 = require("./segment/curve/cubic-bezier"), line_1 = require("./segment/curve/line");

class SegContext {
    get endX() {
        return this._lastX;
    }
    get endY() {
        return this._lastY;
    }
    constructor(curveType, direction) {
        this.init(curveType, direction);
    }
    init(curveType, direction) {
        this._lastX = this._lastY = this._startX = this._startY = 0, this.curveType = curveType, 
        this.direction = direction, this.curves = [];
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined) {
        const curve = new cubic_bezier_1.CubicBezierCurve(new vutils_1.Point(this._lastX, this._lastY), new vutils_1.Point(cp1x, cp1y), new vutils_1.Point(cp2x, cp2y), new vutils_1.Point(x, y));
        curve.defined = defined, this.curves.push(curve), this._lastX = x, this._lastY = y;
    }
    closePath() {
        if (this.curves.length < 2) return;
        const lastCurve = this.curves[this.curves.length - 1];
        this.lineTo(this._startX, this._startY, lastCurve.defined);
    }
    ellipse() {
        throw new Error("SegContext不支持调用ellipse");
    }
    lineTo(x, y, defined) {
        const curve = this.addLinearCurve(x, y, defined);
        this.curves.push(curve), this._lastX = x, this._lastY = y;
    }
    moveTo(x, y) {
        return this._lastX = this._startX = x, this._lastY = this._startY = y, this;
    }
    quadraticCurveTo(cpx, cpy, x, y) {
        throw new Error("SegContext不支持调用quadraticCurveTo");
    }
    clear() {
        this.curves = [], this.length = NaN;
    }
    tryUpdateLength(direction) {
        return this.getLength(direction);
    }
    addLinearCurve(x, y, defined) {
        const curve = new line_1.LineCurve(new vutils_1.Point(this._lastX, this._lastY), new vutils_1.Point(x, y));
        return curve.defined = defined, curve;
    }
    getPointAt(t) {
        throw new Error("暂未实现");
    }
    getCurveLengths() {
        return [];
    }
    getLength(direction) {
        if (direction === enums_1.Direction.COLUMN) {
            if (!this.curves.length) return 0;
            const sc = this.curves[0], ec = this.curves[this.curves.length - 1];
            return (0, vutils_1.abs)(sc.p0.y - ec.p1.y);
        }
        if (direction === enums_1.Direction.ROW) {
            if (!this.curves.length) return 0;
            const sc = this.curves[0], ec = this.curves[this.curves.length - 1];
            return (0, vutils_1.abs)(sc.p0.x - ec.p1.x);
        }
        return Number.isFinite(this.length) || (this.length = this.curves.reduce(((l, c) => l + c.getLength()), 0)), 
        this.length;
    }
}

exports.SegContext = SegContext;

class ReflectSegContext extends SegContext {
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined) {
        return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y, x, defined);
    }
    lineTo(x, y, defined) {
        return super.lineTo(y, x, defined);
    }
    moveTo(x, y) {
        return super.moveTo(y, x);
    }
    clear() {
        return super.clear();
    }
}

exports.ReflectSegContext = ReflectSegContext;
//# sourceMappingURL=seg-context.js.map
}, function(modId) { var map = {"./enums":1689069767685,"./segment/curve/cubic-bezier":1689069767691,"./segment/curve/line":1689069767694}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767691, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CubicBezierCurve = exports.divideCubic = void 0;

const vutils_1 = require("@visactor/vutils"), base_1 = require("./base"), enums_1 = require("../../enums"), bezier_utils_1 = require("../../bezier-utils");

function divideCubic(curve, t) {
    const {p0: p0, p1: p1, p2: p2, p3: p3} = curve, pt = (0, bezier_utils_1.cubicPointAt)(p0, p1, p2, p3, t), c1 = vutils_1.PointService.pointAtPP(p0, p1, t), c2 = vutils_1.PointService.pointAtPP(p1, p2, t), c3 = vutils_1.PointService.pointAtPP(p2, p3, t), c12 = vutils_1.PointService.pointAtPP(c1, c2, t), c23 = vutils_1.PointService.pointAtPP(c2, c3, t);
    return [ new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c3, p3) ];
}

exports.divideCubic = divideCubic;

class CubicBezierCurve extends base_1.Curve {
    constructor(p0, p1, p2, p3) {
        super(), this.type = enums_1.CurveTypeEnum.CubicBezierCurve, this.p0 = p0, this.p1 = p1, 
        this.p2 = p2, this.p3 = p3;
    }
    _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
    }
    getPointAt(t) {
        if (!1 !== this.defined) return (0, bezier_utils_1.cubicPointAt)(this.p0, this.p1, this.p2, this.p3, t);
        throw new Error("defined为false的点不能getPointAt");
    }
    calcLength() {
        return this._validPoint() ? (0, bezier_utils_1.cubicLength)(this.p0, this.p1, this.p2, this.p3, 0) : 60;
    }
    calcProjLength(direction) {
        return direction === enums_1.Direction.ROW ? (0, vutils_1.abs)(this.p0.x - this.p3.x) : direction === enums_1.Direction.COLUMN ? (0, 
        vutils_1.abs)(this.p0.y - this.p3.y) : 0;
    }
    getAngleAt(t) {
        const minT = (0, vutils_1.max)(t - .01, 0), maxT = (0, vutils_1.min)(t + .01, 1), minP = this.getPointAt(minT), maxP = this.getPointAt(maxT);
        return (0, vutils_1.atan2)(maxP.y - minP.y, maxP.x - minP.x);
    }
}

exports.CubicBezierCurve = CubicBezierCurve;
//# sourceMappingURL=cubic-bezier.js.map

}, function(modId) { var map = {"./base":1689069767692,"../../enums":1689069767685,"../../bezier-utils":1689069767693}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767692, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Curve = void 0;

class Curve {
    getLength(direction) {
        return null != direction ? this.calcProjLength(direction) : (Number.isFinite(this.length) || (this.length = this.calcLength()), 
        this.length);
    }
}

exports.Curve = Curve;
//# sourceMappingURL=base.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767693, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.cubicPointAt = exports.cubicCalc = exports.cubicLength = exports.snapLength = void 0;

const vutils_1 = require("@visactor/vutils");

function snapLength(xArr, yArr) {
    let totalLength = 0;
    const count = xArr.length;
    for (let i = 0; i < count; i++) {
        const x = xArr[i], y = yArr[i], nextX = xArr[(i + 1) % count], nextY = yArr[(i + 1) % count];
        totalLength += vutils_1.PointService.distanceNN(x, y, nextX, nextY);
    }
    return totalLength / 2;
}

function cubicLength(p0, p1, p2, p3, iterationCount) {
    return snapLength([ p0.x, p1.x, p2.x, p3.x ], [ p0.y, p1.y, p2.y, p3.y ]);
}

function cubicCalc(p0, p1, p2, p3, t) {
    const one = 1 - t;
    return one * one * one * p0 + 3 * p1 * t * one * one + 3 * p2 * t * t * one + p3 * t * t * t;
}

function cubicPointAt(p0, p1, p2, p3, t) {
    const x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t), y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);
    return new vutils_1.Point(x, y);
}

exports.snapLength = snapLength, exports.cubicLength = cubicLength, exports.cubicCalc = cubicCalc, 
exports.cubicPointAt = cubicPointAt;
//# sourceMappingURL=bezier-utils.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767694, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LineCurve = exports.divideLinear = void 0;

const vutils_1 = require("@visactor/vutils"), base_1 = require("./base"), enums_1 = require("../../enums");

function divideLinear(curve, t) {
    const {p0: p0, p1: p1} = curve, c1 = vutils_1.PointService.pointAtPP(p0, p1, t);
    return [ new LineCurve(p0, c1), new LineCurve(c1, p1) ];
}

exports.divideLinear = divideLinear;

class LineCurve extends base_1.Curve {
    constructor(p0, p1) {
        super(), this.type = enums_1.CurveTypeEnum.LineCurve, this.p0 = p0, this.p1 = p1;
    }
    getPointAt(t) {
        if (!1 !== this.defined) return vutils_1.PointService.pointAtPP(this.p0, this.p1, t);
        throw new Error("defined为false的点不能getPointAt");
    }
    getAngleAt(t) {
        return null == this.angle && (this.angle = (0, vutils_1.atan2)(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), 
        this.angle;
    }
    _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
    }
    calcLength() {
        return this._validPoint() ? vutils_1.PointService.distancePP(this.p0, this.p1) : 60;
    }
    calcProjLength(direction) {
        return direction === enums_1.Direction.ROW ? (0, vutils_1.abs)(this.p0.x - this.p1.x) : direction === enums_1.Direction.COLUMN ? (0, 
        vutils_1.abs)(this.p0.y - this.p1.y) : 0;
    }
}

exports.LineCurve = LineCurve;
//# sourceMappingURL=line.js.map

}, function(modId) { var map = {"./base":1689069767692,"../../enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767695, function(require, module, exports) {


function genCurveSegments(path, points, step = 1) {
    let defined0 = !1;
    for (let i = 0, n = points.length; i <= n; i++) i >= n === defined0 && ((defined0 = !defined0) ? path.lineStart() : path.lineEnd()), 
    defined0 && path.point(points[i]);
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.genCurveSegments = void 0, exports.genCurveSegments = genCurveSegments;
//# sourceMappingURL=common.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767696, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.genBasisSegments = exports.genBasisTypeSegments = exports.Basis = exports.point = void 0;

const vutils_1 = require("@visactor/vutils"), linear_1 = require("./linear"), common_1 = require("./common"), seg_context_1 = require("../seg-context"), enums_1 = require("../enums");

function point(curveClass, x, y, defined) {
    curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined);
}

exports.point = point;

class Basis {
    constructor(context, startPoint) {
        this.context = context, this.startPoint = startPoint;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
        if (2 === this._point) point(this, 6 * this._x1 - (this._x0 + 4 * this._x1), 6 * this._y1 - (this._y0 + 4 * this._y1), !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), 
        this._line = 1 - this._line;
    }
    point(p) {
        const x = p.x, y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2) : this.context.moveTo(x, y);
            break;

          case 1:
            this._point = 2;
            break;

          default:
            point(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
        }
        this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._lastDefined1 = this._lastDefined2, 
        this._lastDefined2 = p.defined;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}

function genBasisTypeSegments(path, points) {
    return (0, common_1.genCurveSegments)(path, points, 2);
}

function genBasisSegments(points, params = {}) {
    const {direction: direction, startPoint: startPoint} = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    if (points.length < 3 - Number(!!startPoint)) return (0, linear_1.genLinearSegments)(points, params);
    const segContext = new seg_context_1.SegContext("basis", null != direction ? direction : (0, 
    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);
    return genBasisTypeSegments(new Basis(segContext, startPoint), points), segContext;
}

exports.Basis = Basis, exports.genBasisTypeSegments = genBasisTypeSegments, exports.genBasisSegments = genBasisSegments;
//# sourceMappingURL=basis.js.map

}, function(modId) { var map = {"./linear":1689069767689,"./common":1689069767695,"../seg-context":1689069767690,"../enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767697, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.genMonotoneYSegments = exports.genMonotpneYTypeSegments = exports.genMonotoneXSegments = exports.genMonotpneXTypeSegments = exports.MonotoneY = exports.MonotoneX = void 0;

const vutils_1 = require("@visactor/vutils"), linear_1 = require("./linear"), common_1 = require("./common"), seg_context_1 = require("../seg-context"), enums_1 = require("../enums");

function sign(x) {
    return x < 0 ? -1 : 1;
}

function slope3(curveClass, x2, y2) {
    const h0 = curveClass._x1 - curveClass._x0, h1 = x2 - curveClass._x1, s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0)), s1 = (y2 - curveClass._y1) / (h1 || Number(h0 < 0 && -0)), p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), .5 * Math.abs(p)) || 0;
}

function slope2(curveClass, t) {
    const h = curveClass._x1 - curveClass._x0;
    return h ? (3 * (curveClass._y1 - curveClass._y0) / h - t) / 2 : t;
}

function point(curveClass, t0, t1, defined) {
    const x0 = curveClass._x0, y0 = curveClass._y0, x1 = curveClass._x1, y1 = curveClass._y1, dx = (x1 - x0) / 3;
    curveClass.context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1, defined);
}

class MonotoneX {
    constructor(context, startPoint) {
        this.context = context, this.startPoint = startPoint;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
        switch (this._point) {
          case 2:
            this.context.lineTo(this._x1, this._y1, !1 !== this._lastDefined2);
            break;

          case 3:
            point(this, this._t0, slope2(this, this._t0), !1 !== this._lastDefined2);
        }
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), 
        this._line = 1 - this._line;
    }
    point(p) {
        let t1 = NaN;
        const x = p.x, y = p.y;
        if (x !== this._x1 || y !== this._y1) {
            switch (this._point) {
              case 0:
                this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2) : this.context.moveTo(x, y);
                break;

              case 1:
                this._point = 2;
                break;

              case 2:
                this._point = 3, point(this, slope2(this, t1 = slope3(this, x, y)), t1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
                break;

              default:
                point(this, this._t0, t1 = slope3(this, x, y), !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
            }
            this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._t0 = t1, 
            this._lastDefined1 = this._lastDefined2, this._lastDefined2 = !1 !== p.defined;
        }
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}

exports.MonotoneX = MonotoneX;

class MonotoneY extends MonotoneX {
    constructor(context, startPoint) {
        super(context, startPoint);
    }
    point(p) {
        return super.point({
            y: p.x,
            x: p.y,
            defined: p.defined
        });
    }
}

function genMonotpneXTypeSegments(path, points) {
    return (0, common_1.genCurveSegments)(path, points, 2);
}

function genMonotoneXSegments(points, params = {}) {
    const {direction: direction, startPoint: startPoint} = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    if (points.length < 3 - Number(!!startPoint)) return (0, linear_1.genLinearSegments)(points, params);
    const segContext = new seg_context_1.SegContext("monotoneX", null != direction ? direction : (0, 
    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);
    return genMonotpneXTypeSegments(new MonotoneX(segContext, startPoint), points), 
    segContext;
}

function genMonotpneYTypeSegments(path, points) {
    return (0, common_1.genCurveSegments)(path, points, 2);
}

function genMonotoneYSegments(points, params = {}) {
    const {direction: direction, startPoint: startPoint} = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    if (points.length < 3 - Number(!!startPoint)) return (0, linear_1.genLinearSegments)(points, params);
    const segContext = new seg_context_1.ReflectSegContext("monotoneY", null != direction ? direction : (0, 
    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);
    return genMonotpneYTypeSegments(new MonotoneY(segContext, startPoint), points), 
    segContext;
}

exports.MonotoneY = MonotoneY, exports.genMonotpneXTypeSegments = genMonotpneXTypeSegments, 
exports.genMonotoneXSegments = genMonotoneXSegments, exports.genMonotpneYTypeSegments = genMonotpneYTypeSegments, 
exports.genMonotoneYSegments = genMonotoneYSegments;
//# sourceMappingURL=monotone.js.map

}, function(modId) { var map = {"./linear":1689069767689,"./common":1689069767695,"../seg-context":1689069767690,"../enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767698, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.genStepTypeSegments = exports.genStepSegments = exports.Step = void 0;

const vutils_1 = require("@visactor/vutils"), seg_context_1 = require("../seg-context"), common_1 = require("./common"), enums_1 = require("../enums");

class Step {
    constructor(context, t = .5, startPoint) {
        this.context = context, this._t = t, this.startPoint = startPoint;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
        0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, !1 !== this._lastDefined), 
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), 
        this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
    }
    point(p) {
        const x = p.x, y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined) : this.context.moveTo(x, y);
            break;

          case 1:
            this._point = 2;

          default:
            if (this._t <= 0) this.context.lineTo(this._x, y, !1 !== this._lastDefined && !1 !== p.defined), 
            this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined); else {
                const x1 = this._x * (1 - this._t) + x * this._t;
                this.context.lineTo(x1, this._y, !1 !== this._lastDefined && !1 !== p.defined), 
                this.context.lineTo(x1, y, !1 !== this._lastDefined && !1 !== p.defined);
            }
        }
        this._lastDefined = p.defined, this._x = x, this._y = y;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}

function genStepSegments(points, t, params = {}) {
    const {direction: direction, startPoint: startPoint} = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    const segContext = new seg_context_1.SegContext("step", null != direction ? direction : (0, 
    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);
    return genStepTypeSegments(new Step(segContext, t, startPoint), points), segContext;
}

function genStepTypeSegments(path, points) {
    return (0, common_1.genCurveSegments)(path, points, 1);
}

exports.Step = Step, exports.genStepSegments = genStepSegments, exports.genStepTypeSegments = genStepTypeSegments;
//# sourceMappingURL=step.js.map

}, function(modId) { var map = {"../seg-context":1689069767690,"./common":1689069767695,"../enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767699, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.genLinearClosedTypeSegments = exports.genLinearClosedSegments = exports.LinearClosed = void 0;

const vutils_1 = require("@visactor/vutils"), seg_context_1 = require("../seg-context"), common_1 = require("./common"), enums_1 = require("../enums");

class LinearClosed {
    constructor(context, startPoint) {
        this.context = context, startPoint && (this.startPoint = startPoint);
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._point = 0, this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
        this.context.closePath();
    }
    point(p) {
        const x = p.x, y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined) : this.context.moveTo(x, y);
            break;

          case 1:
            this._point = 2;

          default:
            this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined);
        }
        this._lastDefined = p.defined;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}

function genLinearClosedSegments(points, params = {}) {
    const {direction: direction, startPoint: startPoint} = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    const segContext = new seg_context_1.SegContext("linear", null != direction ? direction : (0, 
    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);
    return genLinearClosedTypeSegments(new LinearClosed(segContext, startPoint), points), 
    segContext;
}

function genLinearClosedTypeSegments(path, points) {
    return (0, common_1.genCurveSegments)(path, points, 1);
}

exports.LinearClosed = LinearClosed, exports.genLinearClosedSegments = genLinearClosedSegments, 
exports.genLinearClosedTypeSegments = genLinearClosedTypeSegments;
//# sourceMappingURL=linear-closed.js.map

}, function(modId) { var map = {"../seg-context":1689069767690,"./common":1689069767695,"../enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767700, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CurveContext = void 0;

const vutils_1 = require("@visactor/vutils"), line_1 = require("./line"), cubic_bezier_1 = require("./cubic-bezier");

class CurveContext {
    constructor(path) {
        this.path = path, this._lastX = this._lastY = this._startX = this._startY = 0;
    }
    moveTo(x, y) {
        return this._lastX = this._startX = x, this._lastY = this._startY = y, this;
    }
    lineTo(x, y) {
        const curve = this.addLinearCurve(x, y);
        this.path.curves.push(curve), this._lastX = x, this._lastY = y;
    }
    addLinearCurve(x, y) {
        return new line_1.LineCurve(new vutils_1.Point(this._lastX, this._lastY), new vutils_1.Point(x, y));
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        throw new Error("CurveContext不支持调用quadraticCurveTo");
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        const curve = new cubic_bezier_1.CubicBezierCurve(new vutils_1.Point(this._lastX, this._lastY), new vutils_1.Point(cp1x, cp1y), new vutils_1.Point(cp2x, cp2y), new vutils_1.Point(x, y));
        this.path.curves.push(curve), this._lastX = x, this._lastY = y;
    }
    arcTo(aX1, aY1, aX2, aY2, aRadius) {
        throw new Error("CurveContext不支持调用arcTo");
    }
    ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
        throw new Error("CurveContext不支持调用ellipse");
    }
    rect(x, y, w, h) {
        throw new Error("CurveContext不支持调用rect");
    }
    arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        throw new Error("CurveContext不支持调用arc");
    }
    closePath() {
        this.path.curves.length < 2 || this.lineTo(this._startX, this._startY);
    }
}

exports.CurveContext = CurveContext;
//# sourceMappingURL=curve-context.js.map

}, function(modId) { var map = {"./line":1689069767694,"./cubic-bezier":1689069767691}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767701, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.containStroke = exports.contain = exports.cubicExtrema = exports.cubicRootAt = exports.transformPoint = exports.containLineStroke = exports.containArcStroke = exports.containCubicStroke = exports.containQuadStroke = exports.normalizeRadian = exports.cubicProjectPoint = exports.quadraticProjectPoint = exports.quadraticExtremum = exports.quadraticRootAt = exports.cubicAt = exports.quadraticAt = exports.isNumber = exports.vec2Equals = exports.wrapContext = exports.wrapCanvas = void 0;

const vutils_1 = require("@visactor/vutils"), path_svg_1 = require("../common/path-svg"), container_1 = require("../container"), application_1 = require("../application"), constants_1 = require("./constants");

function wrapCanvas(params) {
    return container_1.container.getNamed(constants_1.CanvasFactory, application_1.application.global.env)(params);
}

function wrapContext(canvas, dpr) {
    return container_1.container.getNamed(constants_1.Context2dFactory, application_1.application.global.env)(canvas, dpr);
}

exports.wrapCanvas = wrapCanvas, exports.wrapContext = wrapContext;

const EPSILON_NUMERIC = 1e-4, THREE_SQRT = Math.sqrt(3), ONE_THIRD = 1 / 3;

function isAroundZero(val) {
    return val > -EPSILON && val < EPSILON;
}

function isNotAroundZero(val) {
    return val > EPSILON || val < -EPSILON;
}

function vec2Equals(d1, d2) {
    return Math.abs(d1[0] - d2[0]) + Math.abs(d1[1] - d2[1]) < 1e-10;
}

function isNumber(data) {
    return "number" == typeof data && Number.isFinite(data);
}

exports.vec2Equals = vec2Equals, exports.isNumber = isNumber;

const _v0 = [ 0, 0 ], _v1 = [ 0, 0 ], _v2 = [ 0, 0 ];

function distanceSquare(v1, v2) {
    return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}

function quadraticAt(p0, p1, p2, t) {
    const onet = 1 - t;
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}

function cubicAt(p0, p1, p2, p3, t) {
    const onet = 1 - t;
    return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}

function quadraticRootAt(p0, p1, p2, val, roots) {
    const a = p0 - 2 * p1 + p2, b = 2 * (p1 - p0), c = p0 - val;
    let n = 0;
    if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
            const t1 = -c / b;
            t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
        }
    } else {
        const disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
            const t1 = -b / (2 * a);
            t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
        } else if (disc > 0) {
            const discSqrt = Math.sqrt(disc), t1 = (-b + discSqrt) / (2 * a), t2 = (-b - discSqrt) / (2 * a);
            t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
        }
    }
    return n;
}

function quadraticExtremum(p0, p1, p2) {
    const divider = p0 + p2 - 2 * p1;
    return 0 === divider ? .5 : (p0 - p1) / divider;
}

function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
    let t = 0, interval = .005, d = 1 / 0;
    _v0[0] = x, _v0[1] = y;
    for (let _t = 0; _t < 1; _t += .05) {
        _v1[0] = quadraticAt(x0, x1, x2, _t), _v1[1] = quadraticAt(y0, y1, y2, _t);
        const d1 = distanceSquare(_v0, _v1);
        d1 < d && (t = _t, d = d1);
    }
    d = 1 / 0;
    for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) {
        const prev = t - interval, next = t + interval;
        _v1[0] = quadraticAt(x0, x1, x2, prev), _v1[1] = quadraticAt(y0, y1, y2, prev);
        const d1 = distanceSquare(_v1, _v0);
        if (prev >= 0 && d1 < d) t = prev, d = d1; else {
            _v2[0] = quadraticAt(x0, x1, x2, next), _v2[1] = quadraticAt(y0, y1, y2, next);
            const d2 = distanceSquare(_v2, _v0);
            next <= 1 && d2 < d ? (t = next, d = d2) : interval *= .5;
        }
    }
    return out && (out[0] = quadraticAt(x0, x1, x2, t), out[1] = quadraticAt(y0, y1, y2, t)), 
    Math.sqrt(d);
}

function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
    let prev, next, d1, d2, t = 0, interval = .005, d = 1 / 0;
    _v0[0] = x, _v0[1] = y;
    for (let _t = 0; _t < 1; _t += .05) _v1[0] = cubicAt(x0, x1, x2, x3, _t), _v1[1] = cubicAt(y0, y1, y2, y3, _t), 
    d1 = distanceSquare(_v0, _v1), d1 < d && (t = _t, d = d1);
    d = 1 / 0;
    for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) prev = t - interval, 
    next = t + interval, _v1[0] = cubicAt(x0, x1, x2, x3, prev), _v1[1] = cubicAt(y0, y1, y2, y3, prev), 
    d1 = distanceSquare(_v1, _v0), prev >= 0 && d1 < d ? (t = prev, d = d1) : (_v2[0] = cubicAt(x0, x1, x2, x3, next), 
    _v2[1] = cubicAt(y0, y1, y2, y3, next), d2 = distanceSquare(_v2, _v0), next <= 1 && d2 < d ? (t = next, 
    d = d2) : interval *= .5);
    return out && (out[0] = cubicAt(x0, x1, x2, x3, t), out[1] = cubicAt(y0, y1, y2, y3, t)), 
    Math.sqrt(d);
}

function normalizeRadian(angle) {
    return (angle %= vutils_1.pi2) < 0 && (angle += vutils_1.pi2), angle;
}

function windingLine(x0, y0, x1, y1, x, y) {
    if (y > y0 && y > y1 || y < y0 && y < y1) return 0;
    if (y1 === y0) return 0;
    const t = (y - y0) / (y1 - y0);
    let dir = y1 < y0 ? 1 : -1;
    1 !== t && 0 !== t || (dir = y1 < y0 ? .5 : -.5);
    const x_ = t * (x1 - x0) + x0;
    return x_ === x ? 1 / 0 : x_ > x ? dir : 0;
}

function containQuadStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
    if (0 === lineWidth) return !1;
    const _l = lineWidth;
    if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) return !1;
    return quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null) <= _l / 2;
}

function containCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
    if (0 === lineWidth) return !1;
    const _l = lineWidth;
    if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) return !1;
    return cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null) <= _l / 2;
}

function containArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
    if (0 === lineWidth) return !1;
    const _l = lineWidth;
    x -= cx, y -= cy;
    const d = Math.sqrt(x * x + y * y);
    if (d - _l > r || d + _l < r) return !1;
    if (Math.abs(startAngle - endAngle) % vutils_1.pi2 < 1e-4) return !0;
    if (anticlockwise) {
        const tmp = startAngle;
        startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);
    } else startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);
    startAngle > endAngle && (endAngle += vutils_1.pi2);
    let angle = Math.atan2(y, x);
    return angle < 0 && (angle += vutils_1.pi2), angle >= startAngle && angle <= endAngle || angle + vutils_1.pi2 >= startAngle && angle + vutils_1.pi2 <= endAngle;
}

function containLineStroke(x0, y0, x1, y1, lineWidth, x, y) {
    if (0 === lineWidth) return !1;
    const _l = lineWidth, _halfL = lineWidth / 2;
    let _a = 0, _b = x0;
    if (y > y0 + _halfL && y > y1 + _halfL || y < y0 - _halfL && y < y1 - _halfL || x > x0 + _halfL && x > x1 + _halfL || x < x0 - _halfL && x < x1 - _halfL) return !1;
    if (x0 === x1) return Math.abs(x - x0) <= _l / 2;
    _a = (y0 - y1) / (x0 - x1), _b = (x0 * y1 - x1 * y0) / (x0 - x1);
    const tmp = _a * x - y + _b;
    return tmp * tmp / (_a * _a + 1) <= _l / 2 * _l / 2;
}

exports.quadraticAt = quadraticAt, exports.cubicAt = cubicAt, exports.quadraticRootAt = quadraticRootAt, 
exports.quadraticExtremum = quadraticExtremum, exports.quadraticProjectPoint = quadraticProjectPoint, 
exports.cubicProjectPoint = cubicProjectPoint, exports.normalizeRadian = normalizeRadian, 
exports.default = windingLine, exports.containQuadStroke = containQuadStroke, exports.containCubicStroke = containCubicStroke, 
exports.containArcStroke = containArcStroke, exports.containLineStroke = containLineStroke;

const globalPoint = {
    x: 0,
    y: 0
};

function transformPoint(pos, ctx, out) {
    const matrix = ctx.currentMatrix.getInverse();
    return (out = out || globalPoint).x = pos.x * matrix.a + pos.y * matrix.c + matrix.e, 
    out.y = pos.x * matrix.b + pos.y * matrix.d + matrix.f, out;
}

exports.transformPoint = transformPoint;

const EPSILON = 1e-4;

function cubicRootAt(p0, p1, p2, p3, val, roots) {
    const a = p3 + 3 * (p1 - p2) - p0, b = 3 * (p2 - 2 * p1 + p0), c = 3 * (p1 - p0), d = p0 - val, A = b * b - 3 * a * c, B = b * c - 9 * a * d, C = c * c - 3 * b * d;
    let n = 0;
    if (isAroundZero(A) && isAroundZero(B)) if (isAroundZero(b)) roots[0] = 0; else {
        const t1 = -c / b;
        t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
    } else {
        const disc = B * B - 4 * A * C;
        if (isAroundZero(disc)) {
            const K = B / A, t1 = -b / a + K, t2 = -K / 2;
            t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
        } else if (disc > 0) {
            const discSqrt = Math.sqrt(disc);
            let Y1 = A * b + 1.5 * a * (-B + discSqrt), Y2 = A * b + 1.5 * a * (-B - discSqrt);
            Y1 = Y1 < 0 ? -Math.pow(-Y1, ONE_THIRD) : Math.pow(Y1, ONE_THIRD), Y2 = Y2 < 0 ? -Math.pow(-Y2, ONE_THIRD) : Math.pow(Y2, ONE_THIRD);
            const t1 = (-b - (Y1 + Y2)) / (3 * a);
            t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
        } else {
            const T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A)), theta = Math.acos(T) / 3, ASqrt = Math.sqrt(A), tmp = Math.cos(theta), t1 = (-b - 2 * ASqrt * tmp) / (3 * a), t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a), t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
            t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2), 
            t3 >= 0 && t3 <= 1 && (roots[n++] = t3);
        }
    }
    return n;
}

function cubicExtrema(p0, p1, p2, p3, extrema) {
    const b = 6 * p2 - 12 * p1 + 6 * p0, a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2, c = 3 * p1 - 3 * p0;
    let n = 0;
    if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
            const t1 = -c / b;
            t1 >= 0 && t1 <= 1 && (extrema[n++] = t1);
        }
    } else {
        const disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) extrema[0] = -b / (2 * a); else if (disc > 0) {
            const discSqrt = Math.sqrt(disc), t1 = (-b + discSqrt) / (2 * a), t2 = (-b - discSqrt) / (2 * a);
            t1 >= 0 && t1 <= 1 && (extrema[n++] = t1), t2 >= 0 && t2 <= 1 && (extrema[n++] = t2);
        }
    }
    return n;
}

function isAroundEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
}

exports.cubicRootAt = cubicRootAt, exports.cubicExtrema = cubicExtrema;

const roots = [ -1, -1, -1 ], extrema = [ -1, -1 ];

function swapExtrema() {
    const tmp = extrema[0];
    extrema[0] = extrema[1], extrema[1] = tmp;
}

function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
    if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) return 0;
    const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
    if (0 === nRoots) return 0;
    let w = 0, nExtrema = -1, y0_ = 0, y1_ = 0;
    for (let i = 0; i < nRoots; i++) {
        const t = roots[i], unit = 0 === t || 1 === t ? .5 : 1;
        cubicAt(x0, x1, x2, x3, t) < x || (nExtrema < 0 && (nExtrema = cubicExtrema(y0, y1, y2, y3, extrema), 
        extrema[1] < extrema[0] && nExtrema > 1 && swapExtrema(), y0_ = cubicAt(y0, y1, y2, y3, extrema[0]), 
        nExtrema > 1 && (y1_ = cubicAt(y0, y1, y2, y3, extrema[1]))), 2 === nExtrema ? t < extrema[0] ? w += y0_ < y0 ? unit : -unit : t < extrema[1] ? w += y1_ < y0_ ? unit : -unit : w += y3 < y1_ ? unit : -unit : t < extrema[0] ? w += y0_ < y0 ? unit : -unit : w += y3 < y0_ ? unit : -unit);
    }
    return w;
}

function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
    if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) return 0;
    const nRoots = quadraticRootAt(y0, y1, y2, y, roots);
    if (0 === nRoots) return 0;
    const t = quadraticExtremum(y0, y1, y2);
    if (t >= 0 && t <= 1) {
        let w = 0;
        const y_ = quadraticAt(y0, y1, y2, t);
        for (let i = 0; i < nRoots; i++) {
            const unit = 0 === roots[i] || 1 === roots[i] ? .5 : 1;
            quadraticAt(x0, x1, x2, roots[i]) < x || (roots[i] < t ? w += y_ < y0 ? unit : -unit : w += y2 < y_ ? unit : -unit);
        }
        return w;
    }
    const unit = 0 === roots[0] || 1 === roots[0] ? .5 : 1;
    return quadraticAt(x0, x1, x2, roots[0]) < x ? 0 : y2 < y0 ? unit : -unit;
}

function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
    if ((y -= cy) > r || y < -r) return 0;
    const tmp = Math.sqrt(r * r - y * y);
    roots[0] = -tmp, roots[1] = tmp;
    const dTheta = Math.abs(startAngle - endAngle);
    if (dTheta < 1e-4) return 0;
    if (dTheta >= vutils_1.pi2 - 1e-4) {
        startAngle = 0, endAngle = vutils_1.pi2;
        const dir = anticlockwise ? 1 : -1;
        return x >= roots[0] + cx && x <= roots[1] + cx ? dir : 0;
    }
    if (startAngle > endAngle) {
        const tmp = startAngle;
        startAngle = endAngle, endAngle = tmp;
    }
    startAngle < 0 && (startAngle += vutils_1.pi2, endAngle += vutils_1.pi2);
    let w = 0;
    for (let i = 0; i < 2; i++) {
        const x_ = roots[i];
        if (x_ + cx > x) {
            let angle = Math.atan2(y, x_), dir = anticlockwise ? 1 : -1;
            angle < 0 && (angle = vutils_1.pi2 + angle), (angle >= startAngle && angle <= endAngle || angle + vutils_1.pi2 >= startAngle && angle + vutils_1.pi2 <= endAngle) && (angle > vutils_1.pi / 2 && angle < 1.5 * vutils_1.pi && (dir = -dir), 
            w += dir);
        }
    }
    return w;
}

function modpi2(radian) {
    return Math.round(radian / vutils_1.pi * 1e8) / 1e8 % 2 * vutils_1.pi;
}

function normalizeArcAngles(angles, anticlockwise) {
    let newStartAngle = modpi2(angles[0]);
    newStartAngle < 0 && (newStartAngle += vutils_1.pi2);
    const delta = newStartAngle - angles[0];
    let newEndAngle = angles[1];
    newEndAngle += delta, !anticlockwise && newEndAngle - newStartAngle >= vutils_1.pi2 ? newEndAngle = newStartAngle + vutils_1.pi2 : anticlockwise && newStartAngle - newEndAngle >= vutils_1.pi2 ? newEndAngle = newStartAngle - vutils_1.pi2 : !anticlockwise && newStartAngle > newEndAngle ? newEndAngle = newStartAngle + (vutils_1.pi2 - modpi2(newStartAngle - newEndAngle)) : anticlockwise && newStartAngle < newEndAngle && (newEndAngle = newStartAngle - (vutils_1.pi2 - modpi2(newEndAngle - newStartAngle))), 
    angles[0] = newStartAngle, angles[1] = newEndAngle;
}

const tmpAngles = [ 0, 0 ];

function containPath(commands, lineWidth, isStroke, x, y) {
    const data = commands, len = commands.length;
    let x1, y1, w = 0, xi = 0, yi = 0, x0 = 0, y0 = 0;
    for (let i = 0; i < len; i++) {
        const command = data[i], isFirst = 0 === i;
        command[0] === path_svg_1.enumCommandMap.M && i > 1 && (isStroke || (w += windingLine(xi, yi, x0, y0, x, y))), 
        isFirst && (xi = command[1], yi = command[2], x0 = xi, y0 = yi);
        const c0 = command[0], c1 = command[1], c2 = command[2], c3 = command[3], c4 = command[4], c5 = command[5], c6 = command[6];
        let startAngle = c4, endAngle = c5;
        tmpAngles[0] = startAngle, tmpAngles[1] = endAngle, normalizeArcAngles(tmpAngles, Boolean(command[6])), 
        startAngle = tmpAngles[0], endAngle = tmpAngles[1];
        const theta = startAngle, dTheta = endAngle - startAngle, anticlockwise = !!(1 - (command[6] ? 0 : 1)), _x = (x - c1) * c3 / c3 + c1;
        switch (c0) {
          case path_svg_1.enumCommandMap.M:
            x0 = c1, y0 = c2, xi = x0, yi = y0;
            break;

          case path_svg_1.enumCommandMap.L:
            if (isStroke) {
                if (containLineStroke(xi, yi, c1, c2, lineWidth, x, y)) return !0;
            } else w += windingLine(xi, yi, c1, c2, x, y) || 0;
            xi = c1, yi = c2;
            break;

          case path_svg_1.enumCommandMap.C:
            if (isStroke) {
                if (containCubicStroke(xi, yi, c1, c2, c3, c4, c5, c6, lineWidth, x, y)) return !0;
            } else w += windingCubic(xi, yi, c1, c2, c3, c4, c5, c6, x, y) || 0;
            xi = c5, yi = c6;
            break;

          case path_svg_1.enumCommandMap.Q:
            if (isStroke) {
                if (containQuadStroke(xi, yi, c1, c2, c3, c4, lineWidth, x, y)) return !0;
            } else w += windingQuadratic(xi, yi, c1, c2, c3, c4, x, y) || 0;
            xi = c3, yi = c4;
            break;

          case path_svg_1.enumCommandMap.A:
            if (x1 = Math.cos(theta) * c3 + c1, y1 = Math.sin(theta) * c3 + c2, isFirst ? (x0 = x1, 
            y0 = y1) : w += windingLine(xi, yi, x1, y1, x, y), isStroke) {
                if (containArcStroke(c1, c2, c3, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) return !0;
            } else w += windingArc(c1, c2, c3, theta, theta + dTheta, anticlockwise, _x, y);
            xi = Math.cos(theta + dTheta) * c3 + c1, yi = Math.sin(theta + dTheta) * c3 + c2;
            break;

          case path_svg_1.enumCommandMap.R:
            if (x0 = xi = c1, y0 = yi = c2, x1 = x0 + c3, y1 = y0 + c4, isStroke) {
                if (containLineStroke(x0, y0, x1, y0, lineWidth, x, y) || containLineStroke(x1, y0, x1, y1, lineWidth, x, y) || containLineStroke(x1, y1, x0, y1, lineWidth, x, y) || containLineStroke(x0, y1, x0, y0, lineWidth, x, y)) return !0;
            } else w += windingLine(x1, y0, x1, y1, x, y), w += windingLine(x0, y1, x0, y0, x, y);
            break;

          case path_svg_1.enumCommandMap.Z:
            if (isStroke) {
                if (containLineStroke(xi, yi, x0, y0, lineWidth, x, y)) return !0;
            } else w += windingLine(xi, yi, x0, y0, x, y);
            xi = x0, yi = y0;
        }
    }
    return isStroke || isAroundEqual(yi, y0) || (w += windingLine(xi, yi, x0, y0, x, y) || 0), 
    0 !== w;
}

function contain(commands, x, y) {
    return containPath(commands, 0, !1, x, y);
}

function containStroke(commands, lineWidth, x, y) {
    return containPath(commands, lineWidth, !0, x, y);
}

exports.contain = contain, exports.containStroke = containStroke;
//# sourceMappingURL=util.js.map
}, function(modId) { var map = {"../common/path-svg":1689069767684,"../container":1689069767702,"../application":1689069767703,"./constants":1689069767704}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767702, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.container = void 0;

const inversify_1 = require("inversify");

exports.container = new inversify_1.Container;
//# sourceMappingURL=container.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767703, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.application = exports.Application = void 0;

class Application {}

exports.Application = Application, exports.application = new Application;
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767704, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Context2dFactory = exports.CanvasFactory = void 0, exports.CanvasFactory = Symbol.for("CanvasFactory"), 
exports.Context2dFactory = Symbol.for("Context2dFactory");
//# sourceMappingURL=constants.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767705, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultLayerService = void 0;

const inversify_1 = require("inversify"), layer_1 = require("./layer"), constants_1 = require("../constants");

let DefaultLayerService = class {
    constructor(global) {
        this.global = global, this.layerMap = new Map;
    }
    getStageLayer(stage) {
        return this.layerMap.get(stage);
    }
    createLayer(stage) {
        const layer = new layer_1.Layer(stage, this.global, stage.window, {
            main: !1
        }), stageLayers = this.layerMap.get(stage) || [];
        return stageLayers.push(layer), this.layerMap.set(stage, stageLayers), layer;
    }
    releaseLayer(stage, layer) {
        layer.release();
        const stageLayers = this.layerMap.get(stage) || [];
        this.layerMap.set(stage, stageLayers.filter((l => l !== layer)));
    }
    layerCount(stage) {
        return (this.layerMap.get(stage) || []).length;
    }
    restLayerCount(stage) {
        return "browser" === this.global.env ? 10 : 0;
    }
};

DefaultLayerService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(constants_1.Global)), __metadata("design:paramtypes", [ Object ]) ], DefaultLayerService), 
exports.DefaultLayerService = DefaultLayerService;
//# sourceMappingURL=layer-service.js.map

}, function(modId) { var map = {"./layer":1689069767706,"../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767706, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Layer = exports.LayerHandlerContribution = void 0;

const application_1 = require("../application"), container_1 = require("../container"), theme_1 = require("../graphic/theme"), group_1 = require("../graphic/group");

exports.LayerHandlerContribution = Symbol.for("LayerHandlerContribution");

class Layer extends group_1.Group {
    get offscreen() {
        return this.layerHandler.offscreen;
    }
    get width() {
        return this.stage ? this.stage.width : 0;
    }
    get height() {
        return this.stage ? this.stage.height : 0;
    }
    get viewWidth() {
        return this.stage ? this.stage.viewWidth : 0;
    }
    get viewHeight() {
        return this.stage ? this.stage.viewHeight : 0;
    }
    get dirtyBound() {
        throw new Error("暂不支持");
    }
    get dpr() {
        return this._dpr;
    }
    constructor(stage, global, window, params) {
        var _a;
        super({}), this.stage = stage, this.global = global, this.window = window, this.main = params.main, 
        this.layerHandler = container_1.container.get(exports.LayerHandlerContribution), 
        this.layerHandler.init(this, window, {
            main: params.main,
            canvasId: params.canvasId,
            width: this.viewWidth,
            height: this.viewHeight,
            zIndex: null !== (_a = params.zIndex) && void 0 !== _a ? _a : 0
        }), this.layer = this, this.subLayers = new Map, this.theme = new theme_1.Theme, 
        this.background = "rgba(0, 0, 0, 0)";
    }
    combineSubLayer(removeIncrementalKey = !0) {
        const subLayers = Array.from(this.subLayers.values()).sort(((a, b) => a.zIndex - b.zIndex));
        this.layerHandler.merge(subLayers.map((l => (l.layer.subLayers.size && l.layer.combineSubLayer(removeIncrementalKey), 
        l.layer.getNativeHandler())))), removeIncrementalKey && subLayers.forEach((l => {
            l.group && (l.group.incremental = 0);
        })), subLayers.forEach((l => {
            application_1.application.layerService.releaseLayer(this.stage, l.layer);
        })), this.subLayers.clear();
    }
    getNativeHandler() {
        return this.layerHandler;
    }
    setStage(stage, layer) {
        super.setStage(stage, this);
    }
    pick(x, y) {
        throw new Error("暂不支持");
    }
    render(params, userParams) {
        var _a;
        const stage = this.stage;
        this.layerHandler.render([ this ], {
            renderService: params.renderService,
            x: stage.x,
            y: stage.y,
            width: this.viewWidth,
            height: this.viewHeight,
            stage: this.stage,
            layer: this,
            background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
            updateBounds: params.updateBounds
        }, userParams);
    }
    resize(w, h) {
        this.layerHandler.resize(w, h);
    }
    resizeView(w, h) {
        this.layerHandler.resizeView(w, h);
    }
    setDpr(dpr) {
        throw new Error("暂不支持");
    }
    afterDraw(cb) {
        throw new Error("暂不支持");
    }
    startAnimate(t) {
        throw new Error("暂不支持");
    }
    setToFrame(t) {
        throw new Error("暂不支持");
    }
    prepare(dirtyBounds, params) {}
    combineTo(target, params) {
        var _a;
        this.offscreen && this.layerHandler.drawTo(target, [ this ], Object.assign({
            background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
            renderService: params.renderService,
            x: this.stage.x,
            y: this.stage.y,
            width: this.viewWidth,
            height: this.viewHeight,
            stage: this.stage,
            layer: this
        }, params));
    }
    release() {
        super.release(), this.layerHandler.release(), this.subLayers && this.subLayers.forEach((l => {
            application_1.application.layerService.releaseLayer(this.stage, l.layer);
        }));
    }
    drawTo(target, params) {
        var _a;
        this.layerHandler.drawTo(target, [ this ], Object.assign({
            background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
            renderService: params.renderService,
            x: this.stage.x,
            y: this.stage.y,
            width: this.viewWidth,
            height: this.viewHeight,
            stage: this.stage,
            layer: this
        }, params));
    }
}

exports.Layer = Layer;
//# sourceMappingURL=layer.js.map

}, function(modId) { var map = {"../application":1689069767703,"../container":1689069767702,"../graphic/theme":1689069767707,"../graphic/group":1689069767708}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767707, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getThemeFromGroup = exports.getTheme = exports.globalTheme = exports.Theme = exports.newThemeObj = void 0;

const vutils_1 = require("@visactor/vutils"), config_1 = require("./config"), defaultThemeObj = {
    arc: config_1.DefaultArcAttribute,
    area: config_1.DefaultAreaAttribute,
    circle: config_1.DefaultCircleAttribute,
    line: config_1.DefaultLineAttribute,
    path: config_1.DefaultPathAttribute,
    symbol: config_1.DefaultSymbolAttribute,
    text: config_1.DefaultTextAttribute,
    rect: config_1.DefaultRectAttribute,
    rect3d: config_1.DefaultRect3dAttribute,
    polygon: config_1.DefaultPolygonAttribute,
    richtext: config_1.DefaultRichTextAttribute,
    richtextIcon: config_1.DefaultRichTextIconAttribute,
    image: config_1.DefaultImageAttribute,
    group: config_1.DefaultGroupAttribute,
    glyph: config_1.DefaultGlyphAttribute
}, themeKeys = Object.keys(defaultThemeObj);

function newThemeObj() {
    return {
        arc: Object.assign({}, defaultThemeObj.arc),
        area: Object.assign({}, defaultThemeObj.area),
        circle: Object.assign({}, defaultThemeObj.circle),
        line: Object.assign({}, defaultThemeObj.line),
        path: Object.assign({}, defaultThemeObj.path),
        symbol: Object.assign({}, defaultThemeObj.symbol),
        text: Object.assign({}, defaultThemeObj.text),
        rect: Object.assign({}, defaultThemeObj.rect),
        rect3d: Object.assign({}, defaultThemeObj.rect3d),
        polygon: Object.assign({}, defaultThemeObj.polygon),
        richtext: Object.assign({}, defaultThemeObj.richtext),
        richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
        image: Object.assign({}, defaultThemeObj.image),
        group: Object.assign({}, defaultThemeObj.group),
        glyph: Object.assign({}, defaultThemeObj.glyph)
    };
}

function combineTheme(out, t, rewrite = !0) {
    t && (rewrite ? Object.keys(t).forEach((k => {
        out[k] ? Object.assign(out[k], t[k]) : out[k] = t[k];
    })) : Object.keys(t).forEach((k => {
        if (out[k]) {
            const outItem = out[k], tItem = t[k];
            Object.keys(t[k]).forEach((kItem => {
                void 0 === outItem[kItem] && (outItem[kItem] = tItem[kItem]);
            }));
        } else out[k] = t[k];
    })));
}

exports.newThemeObj = newThemeObj;

const staticThemePools = new Array(60).fill(0).map((() => newThemeObj()));

class Theme {
    constructor() {
        this._defaultTheme = staticThemePools.pop() || newThemeObj(), this.combinedTheme = this._defaultTheme, 
        this.dirty = !1;
    }
    getTheme(group) {
        if (!group) return this.combinedTheme;
        if (!this.dirty) return this.combinedTheme;
        let parentTheme = {};
        const parentGroup = this.getParentWithTheme(group);
        return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), 
        this.combinedTheme;
    }
    getParentWithTheme(group) {
        for (;group.parent; ) if ((group = group.parent).theme) return group;
        return null;
    }
    applyTheme(group, pt, force = !1) {
        if (this.dirty) {
            const parentGroup = this.getParentWithTheme(group);
            if (parentGroup) {
                const parentTheme = parentGroup.theme;
                (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, !0), this.userTheme ? combineTheme(this.userTheme, parentTheme.userTheme, !1) : this.userTheme = (0, 
                vutils_1.clone)(parentTheme.userTheme), combineTheme(pt, parentTheme.userTheme);
            }
            this.userTheme ? this.doCombine(pt) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, 
            console.warn("未知错误，走到不应该走的区域里")), this.dirty = !1);
        }
        return this.combinedTheme;
    }
    doCombine(parentTheme) {
        const userTheme = this.userTheme, defaultTheme = this._defaultTheme, combinedTheme = this.combinedTheme, parentCommonTheme = parentTheme.common || {}, commonTheme = Object.assign(parentCommonTheme, this.commonTheme);
        themeKeys.forEach((k => {
            var _a, _b;
            userTheme[k] || commonTheme || parentTheme[k] ? combinedTheme[k] = Object.assign({}, defaultTheme[k], null != commonTheme ? commonTheme : {}, null !== (_a = parentTheme[k]) && void 0 !== _a ? _a : {}, null !== (_b = userTheme[k]) && void 0 !== _b ? _b : {}) : combinedTheme[k] = defaultTheme[k];
        })), this.dirty = !1;
    }
    resetTheme(t, g) {
        this.userTheme = t, this.dirty = !0, this.dirtyChildren(g);
    }
    setTheme(t, g) {
        let userTheme = this.userTheme;
        userTheme ? Object.keys(t).forEach((k => {
            userTheme[k] ? Object.assign(userTheme[k], t[k]) : userTheme[k] = Object.assign({}, t[k]);
        })) : userTheme = t, t.common && (this.commonTheme ? Object.assign(this.commonTheme, t.common) : this.commonTheme = t.common), 
        this.userTheme = userTheme, this.dirty = !0, this.dirtyChildren(g);
    }
    dirtyChildren(g) {
        g.forEachChildren((item => {
            item.isContainer && (item.theme && (item.theme.dirty = !0), this.dirtyChildren(item));
        }));
    }
}

function getTheme(graphic, theme) {
    return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme ? (graphic.isContainer, 
    theme) : getThemeFromGroup(graphic) || exports.globalTheme.getTheme();
}

function getThemeFromGroup(graphic) {
    let g;
    if (g = graphic.isContainer ? graphic : graphic.parent, g) {
        for (;g && !g.theme; ) g = g.parent;
        return g ? (g.theme || g.createTheme(), g.theme.getTheme(g)) : exports.globalTheme.getTheme();
    }
    return null;
}

exports.Theme = Theme, exports.globalTheme = new Theme, exports.getTheme = getTheme, 
exports.getThemeFromGroup = getThemeFromGroup;
//# sourceMappingURL=theme.js.map

}, function(modId) { var map = {"./config":1689069767680}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767708, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Group = exports.GroupUpdateAABBBoundsMode = void 0;

const vutils_1 = require("@visactor/vutils"), application_1 = require("../application"), graphic_1 = require("./graphic"), theme_1 = require("./theme"), utils_1 = require("../common/utils"), enums_1 = require("../common/enums"), constants_1 = require("./constants");

var GroupUpdateAABBBoundsMode;

!function(GroupUpdateAABBBoundsMode) {
    GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.LESS_GROUP = 0] = "LESS_GROUP", 
    GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.MORE_GROUP = 1] = "MORE_GROUP";
}(GroupUpdateAABBBoundsMode = exports.GroupUpdateAABBBoundsMode || (exports.GroupUpdateAABBBoundsMode = {}));

class Group extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "group", this.parent = null, this.isContainer = !0, this.numberType = constants_1.GROUP_NUMBER_TYPE, 
        this._childUpdateTag = enums_1.UpdateTag.UPDATE_BOUNDS;
    }
    setMode(mode) {
        "3d" === mode ? this.set3dMode() : this.set2dMode();
    }
    set3dMode() {
        this.in3dMode = !0;
    }
    set2dMode() {
        this.in3dMode = !1;
    }
    setTheme(t) {
        return this.theme || (this.theme = new theme_1.Theme), this.theme.setTheme(t, this);
    }
    createTheme() {
        this.theme || (this.theme = new theme_1.Theme);
    }
    hideAll() {
        this.setAttribute("visible", !1), this.forEachChildren((item => {
            item.isContainer && item.hideAll ? item.hideAll() : item.setAttribute("visible", !1);
        }));
    }
    showAll() {
        this.setAttribute("visible", !0), this.forEachChildren((item => {
            item.isContainer && item.showAll ? item.showAll() : item.setAttribute("visible", !0);
        }));
    }
    containsPoint(x, y, mode) {
        if (mode === enums_1.IContainPointMode.GLOBAL) {
            const point = new vutils_1.Point(x, y);
            return this.parent && this.parent.globalTransMatrix.transformPoint(point, point), 
            this.AABBBounds.contains(point.x, point.y);
        }
        return this.AABBBounds.contains(x, y);
    }
    shouldUpdateAABBBounds() {
        return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & enums_1.UpdateTag.UPDATE_BOUNDS);
    }
    tryUpdateAABBBounds() {
        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
        application_1.application.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
        const selfChange = this.shouldSelfChangeUpdateAABBBounds(), bounds = this.doUpdateAABBBounds();
        return application_1.application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), 
        bounds;
    }
    doUpdateAABBBounds() {
        const attribute = this.attribute, groupTheme = (0, theme_1.getTheme)(this).group;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const bounds = application_1.application.graphicService.updateGroupAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).group, this._AABBBounds, this), {boundsPadding: boundsPadding = groupTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.parent && this.parent.addChildUpdateBoundTag(), 
        this.clearUpdateBoundTag(), this._emitCustomEvent("AAABBBoundsChange"), bounds;
    }
    clearUpdateBoundTag() {
        this._updateTag &= enums_1.UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= enums_1.UpdateTag.CLEAR_BOUNDS;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    addUpdateBoundTag() {
        this._updateTag |= enums_1.UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();
    }
    addChildUpdateBoundTag() {
        this._childUpdateTag & enums_1.UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= enums_1.UpdateTag.UPDATE_BOUNDS, 
        this.parent && this.parent.addChildUpdateBoundTag());
    }
    getTheme() {
        return this.theme.getTheme(this);
    }
    incrementalAppendChild(node) {
        const data = super.appendChild(node);
        return this.stage && data && (data.stage = this.stage, data.layer = this.layer), 
        this.addUpdateBoundTag(), application_1.application.graphicService.onAddIncremental(node, this, this.stage), 
        data;
    }
    incrementalClearChild() {
        super.removeAllChild(), this.addUpdateBoundTag(), application_1.application.graphicService.onClearIncremental(this, this.stage);
    }
    appendChild(node, addStage = !0) {
        const data = super.appendChild(node);
        return addStage && this.stage && data && data.setStage(this.stage, this.layer), 
        this.addUpdateBoundTag(), data;
    }
    insertBefore(newNode, referenceNode) {
        const data = super.insertBefore(newNode, referenceNode);
        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), 
        data;
    }
    insertAfter(newNode, referenceNode) {
        const data = super.insertAfter(newNode, referenceNode);
        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), 
        data;
    }
    insertInto(newNode, idx) {
        const data = super.insertInto(newNode, idx);
        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), 
        data;
    }
    removeChild(child) {
        const data = super.removeChild(child);
        return child.stage = null, application_1.application.graphicService.onRemove(child), 
        this.addUpdateBoundTag(), data;
    }
    removeAllChild() {
        this.forEachChildren((child => {
            application_1.application.graphicService.onRemove(child);
        })), super.removeAllChild(), this.addUpdateBoundTag();
    }
    setStage(stage, layer) {
        this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), 
        this._onSetStage && this._onSetStage(this, stage, layer), application_1.application.graphicService.onSetStage(this, stage), 
        this.forEachChildren((item => {
            item.setStage(stage, this.layer);
        })));
    }
    addUpdatePositionTag() {
        super.addUpdatePositionTag(), this.forEachChildren((g => {
            g.isContainer && g.addUpdateGlobalPositionTag();
        }));
    }
    addUpdateGlobalPositionTag() {
        super.addUpdateGlobalPositionTag(), this.forEachChildren((g => {
            g.isContainer && g.addUpdateGlobalPositionTag();
        }));
    }
    tryUpdateGlobalTransMatrix(clearTag = !0) {
        if (this.shouldUpdateGlobalMatrix()) {
            if (this._globalTransMatrix) {
                if (this.parent) {
                    const m = this.parent.globalTransMatrix;
                    this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
                }
            } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
            this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
        }
        return this._globalTransMatrix;
    }
    shouldUpdateGlobalMatrix() {
        return !!(this._updateTag & enums_1.UpdateTag.UPDATE_GLOBAL_MATRIX);
    }
    _getChildByName(name, deep) {
        return this.find((node => node.name === name), deep);
    }
    createOrUpdateChild(graphicName, attributes, graphicType) {
        let graphic = this._getChildByName(graphicName);
        return graphic ? graphic.setAttributes(attributes) : (graphic = application_1.application.graphicService.creator[graphicType](attributes), 
        graphic.name = graphicName, this.add(graphic)), graphic;
    }
    clone() {
        return new Group(Object.assign({}, this.attribute));
    }
}

exports.Group = Group;
//# sourceMappingURL=group.js.map

}, function(modId) { var map = {"../application":1689069767703,"./graphic":1689069767709,"./theme":1689069767707,"../common/utils":1689069767736,"../common/enums":1689069767685,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767709, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Graphic = exports.GRAPHIC_UPDATE_TAG_KEY = exports.PURE_STYLE_KEY = void 0;

const vutils_1 = require("@visactor/vutils"), node_tree_1 = require("./node-tree"), event_1 = require("../event"), config_1 = require("./config"), application_1 = require("../application"), animate_1 = require("../animate"), interpolate_1 = require("../color-string/interpolate"), custom_path2d_1 = require("../common/custom-path2d"), theme_1 = require("./theme"), loader_1 = require("../resource-loader/loader"), enums_1 = require("../common/enums"), tempMatrix = new vutils_1.Matrix;

exports.PURE_STYLE_KEY = [ "stroke", "opacity", "strokeOpacity", "lineDash", "lineDashOffset", "lineCap", "lineJoin", "miterLimit", "fill", "fillOpacity" ], 
exports.GRAPHIC_UPDATE_TAG_KEY = [ "lineWidth", "lineCap", "lineJoin", "miterLimit", "scaleX", "scaleY", "angle", "anchor" ];

const tempConstantXYKey = [ "x", "y" ], tempConstantScaleXYKey = [ "scaleX", "scaleY" ], tempConstantAngleKey = [ "angle" ], point = new vutils_1.Point;

class Graphic extends node_tree_1.Node {
    static mixin(source) {
        const keys = Object.keys(source);
        for (let i = 0; i < keys.length; ++i) {
            const propertyName = keys[i];
            Object.defineProperty(Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
    }
    get AABBBounds() {
        return this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode);
    }
    get OBBBounds() {
        return this.tryUpdateOBBBounds();
    }
    get globalAABBBounds() {
        return this.tryUpdateGlobalAABBBounds();
    }
    get transMatrix() {
        return this.tryUpdateLocalTransMatrix(!0);
    }
    get globalTransMatrix() {
        return this.tryUpdateGlobalTransMatrix(!0);
    }
    constructor(params = {}) {
        super(), this._AABBBounds = new vutils_1.AABBBounds, this._updateTag = enums_1.UpdateTag.INIT, 
        this.attribute = params, this.valid = this.isValid(), params.background && this.loadImage(params.background, !0);
    }
    setMode(mode) {
        "3d" === mode ? this.set3dMode() : this.set2dMode();
    }
    set3dMode() {
        this.in3dMode = !0;
    }
    set2dMode() {
        this.in3dMode = !1;
    }
    getOffsetXY(attr, includeScroll = !1) {
        const {dx: dx = attr.dx, dy: dy = attr.dy} = this.attribute;
        if (includeScroll && this.parent) {
            const groupTheme = (0, theme_1.getTheme)(this.parent).group, {scrollX: scrollX = groupTheme.scrollX, scrollY: scrollY = groupTheme.scrollY} = this.parent.attribute;
            point.x = dx + scrollX, point.y = dy + scrollY;
        } else point.x = dx, point.y = dy;
        return point;
    }
    tryUpdateAABBBounds(full) {
        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
        if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
        application_1.application.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
        const bounds = this.doUpdateAABBBounds(full);
        return application_1.application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, !0), 
        bounds;
    }
    combindShadowAABBBounds(bounds) {
        if (this.shadowRoot) {
            const b = this.shadowRoot.AABBBounds.clone();
            bounds.union(b);
        }
    }
    tryUpdateGlobalAABBBounds() {
        return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this.AABBBounds.clone(), 
        this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix), 
        this._globalAABBBounds;
    }
    tryUpdateGlobalTransMatrix(clearTag = !0) {
        if (this._globalTransMatrix) {
            if (this.parent) {
                const m = this.parent.globalTransMatrix;
                this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
            }
        } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
        return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;
    }
    shouldUpdateGlobalMatrix() {
        return !0;
    }
    tryUpdateLocalTransMatrix(clearTag = !0) {
        return this._transMatrix || (this._transMatrix = new vutils_1.Matrix), this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), 
        clearTag && this.clearUpdateLocalPositionTag()), this._transMatrix;
    }
    shouldUpdateAABBBounds() {
        return this.shadowRoot ? !!(this._updateTag & enums_1.UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & enums_1.UpdateTag.UPDATE_BOUNDS);
    }
    shouldSelfChangeUpdateAABBBounds() {
        return this.shadowRoot ? !!(this._updateTag & enums_1.UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & enums_1.UpdateTag.UPDATE_BOUNDS);
    }
    shouldUpdateLocalMatrix() {
        return !!(this._updateTag & enums_1.UpdateTag.UPDATE_LOCAL_MATRIX);
    }
    isValid() {
        var _a, _b;
        const attribute = this.attribute;
        return Number.isFinite((null !== (_a = attribute.x) && void 0 !== _a ? _a : 0) + (null !== (_b = attribute.y) && void 0 !== _b ? _b : 0));
    }
    _validNumber(num) {
        return null == num || Number.isFinite(num);
    }
    shouldUpdateShape() {
        return !!(this._updateTag & enums_1.UpdateTag.UPDATE_SHAPE);
    }
    clearUpdateShapeTag() {
        this._updateTag &= enums_1.UpdateTag.CLEAR_SHAPE;
    }
    containsPoint(x, y, mode, picker) {
        if (!picker) return !1;
        if (mode === enums_1.IContainPointMode.GLOBAL) {
            const point = new vutils_1.Point(x, y);
            this.parent && this.parent.globalTransMatrix.transformPoint(point, point), x = point.x, 
            y = point.y;
        }
        return picker.containsPoint(this, {
            x: x,
            y: y
        });
    }
    setAttributes(params, forceUpdateTag = !1, context) {
        (params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params).background && this.loadImage(params.background, !0), 
        this._setAttributes(params, forceUpdateTag, context);
    }
    _setAttributes(params, forceUpdateTag = !1, context) {
        const keys = Object.keys(params);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            this.attribute[key] = params[key];
        }
        this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), 
        this.addUpdatePositionTag(), this.onAttributeUpdate(context);
    }
    setAttribute(key, value, forceUpdateTag, context) {
        var _a;
        const params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            [key]: value
        }, this.attribute, key, context);
        params ? this._setAttributes(params, forceUpdateTag, context) : (0, vutils_1.isNil)(null === (_a = this.normalAttrs) || void 0 === _a ? void 0 : _a[key]) ? (this.attribute[key] = value, 
        this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), 
        this.addUpdatePositionTag(), this.onAttributeUpdate(context)) : this.normalAttrs[key] = value, 
        "background" === key && this.loadImage(value, !0);
    }
    needUpdateTags(keys) {
        for (let i = 0; i < exports.GRAPHIC_UPDATE_TAG_KEY.length; i++) {
            const attrKey = exports.GRAPHIC_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < exports.GRAPHIC_UPDATE_TAG_KEY.length; i++) {
            if (key === exports.GRAPHIC_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    initAttributes(params) {
        const context = {
            type: enums_1.AttributeUpdateType.INIT
        };
        params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params, 
        this.attribute = params, params.background && this.loadImage(params.background, !0), 
        this._updateTag = enums_1.UpdateTag.INIT, this.onAttributeUpdate(context);
    }
    translate(x, y) {
        var _a, _b;
        if (0 === x && 0 === y) return this;
        const context = {
            type: enums_1.AttributeUpdateType.TRANSLATE
        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            x: x,
            y: y
        }, this.attribute, tempConstantXYKey, context);
        params && (x = params.x, y = params.y, delete params.x, delete params.y, this._setAttributes(params));
        const attribute = this.attribute, postMatrix = attribute.postMatrix;
        return postMatrix ? application_1.application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y) : (attribute.x = (null !== (_a = attribute.x) && void 0 !== _a ? _a : config_1.DefaultTransform.x) + x, 
        attribute.y = (null !== (_b = attribute.y) && void 0 !== _b ? _b : config_1.DefaultTransform.y) + y), 
        this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.onAttributeUpdate(context), 
        this;
    }
    translateTo(x, y) {
        const attribute = this.attribute;
        if (attribute.x === x && attribute.y === y) return this;
        const context = {
            type: enums_1.AttributeUpdateType.TRANSLATE_TO
        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            x: x,
            y: y
        }, this.attribute, tempConstantXYKey, context);
        return params ? (this._setAttributes(params, !1, context), this) : (attribute.x = x, 
        attribute.y = y, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.onAttributeUpdate(context), 
        this);
    }
    scale(scaleX, scaleY, scaleCenter) {
        var _a, _b;
        if (1 === scaleX && 1 === scaleY) return this;
        const context = {
            type: enums_1.AttributeUpdateType.SCALE
        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            scaleX: scaleX,
            scaleY: scaleY,
            scaleCenter: scaleCenter
        }, this.attribute, tempConstantScaleXYKey, context);
        params && (scaleX = params.scaleX, scaleY = params.scaleY, delete params.scaleX, 
        delete params.scaleY, this._setAttributes(params));
        const attribute = this.attribute;
        if (scaleCenter) {
            let {postMatrix: postMatrix} = this.attribute;
            postMatrix || (postMatrix = new vutils_1.Matrix, attribute.postMatrix = postMatrix), 
            application_1.application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
        } else attribute.scaleX = (null !== (_a = attribute.scaleX) && void 0 !== _a ? _a : config_1.DefaultTransform.scaleX) * scaleX, 
        attribute.scaleY = (null !== (_b = attribute.scaleY) && void 0 !== _b ? _b : config_1.DefaultTransform.scaleY) * scaleY;
        return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.onAttributeUpdate(context), 
        this;
    }
    scaleTo(scaleX, scaleY) {
        const attribute = this.attribute;
        if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) return this;
        const context = {
            type: enums_1.AttributeUpdateType.SCALE_TO
        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            scaleX: scaleX,
            scaleY: scaleY
        }, this.attribute, tempConstantScaleXYKey, context);
        return params ? (this._setAttributes(params, !1, context), this) : (attribute.scaleX = scaleX, 
        attribute.scaleY = scaleY, this.addUpdatePositionTag(), this.addUpdateBoundTag(), 
        this.onAttributeUpdate(context), this);
    }
    rotate(angle) {
        var _a;
        if (0 === angle) return this;
        const context = {
            type: enums_1.AttributeUpdateType.ROTATE
        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);
        if (params) return this._setAttributes(params, !1, context), this;
        const attribute = this.attribute;
        return attribute.angle = (null !== (_a = attribute.angle) && void 0 !== _a ? _a : config_1.DefaultTransform.angle) + angle, 
        this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.onAttributeUpdate(context), 
        this;
    }
    rotateTo(angle) {
        const attribute = this.attribute;
        if (attribute.angle === angle) return this;
        const context = {
            type: enums_1.AttributeUpdateType.ROTATE_TO
        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);
        return params ? (this._setAttributes(params, !1, context), this) : (attribute.angle = angle, 
        this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.onAttributeUpdate(context), 
        this);
    }
    skewTo(b, c) {
        return this;
    }
    animate(params) {
        this.animates || (this.animates = new Map);
        const animate = new animate_1.Animate(null == params ? void 0 : params.id).bind(this);
        if (params) {
            const {onStart: onStart, onFrame: onFrame, onEnd: onEnd, onRemove: onRemove} = params;
            null != onStart && animate.onStart(onStart), null != onFrame && animate.onFrame(onFrame), 
            null != onEnd && animate.onEnd(onEnd), null != onRemove && animate.onRemove(onRemove), 
            animate.interpolateFunc = params.interpolate;
        }
        return this.animates.set(animate.id, animate), animate.onRemove((() => {
            this.animates.delete(animate.id);
        })), animate;
    }
    onAttributeUpdate(context) {
        application_1.application.graphicService.onAttributeUpdate(this), this._emitCustomEvent("afterAttributeUpdate", context);
    }
    update(d) {
        d ? (d.bounds && this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode), 
        d.trans && this.tryUpdateLocalTransMatrix()) : (this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode), 
        this.tryUpdateLocalTransMatrix());
    }
    hasState(stateName) {
        return !(!this.currentStates || !this.currentStates.length) && (!!(0, vutils_1.isNil)(stateName) || this.currentStates.includes(stateName));
    }
    getState(stateName) {
        var _a;
        return null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
    }
    applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
        var _a, _b, _c, _d;
        if (hasAnimation) {
            const keys = Object.keys(attrs), animateAttrs = isClear ? keys.reduce(((res, key) => (res[key] = void 0 === attrs[key] ? this.getDefaultAttribute(key) : attrs[key], 
            res)), {}) : attrs, animate = this.animate();
            animate.stateNames = stateNames, animate.to(animateAttrs, null !== (_b = null === (_a = this.stateAnimateConfig) || void 0 === _a ? void 0 : _a.duration) && void 0 !== _b ? _b : animate_1.DefaultStateAnimateConfig.duration, null !== (_d = null === (_c = this.stateAnimateConfig) || void 0 === _c ? void 0 : _c.easing) && void 0 !== _d ? _d : animate_1.DefaultStateAnimateConfig.easing);
        } else this.setAttributes(attrs, !1, {
            type: enums_1.AttributeUpdateType.STATE
        });
    }
    updateNormalAttrs(stateAttrs) {
        const newNormalAttrs = {};
        this.normalAttrs ? (Object.keys(stateAttrs).forEach((key => {
            key in this.normalAttrs ? (newNormalAttrs[key] = this.normalAttrs[key], delete this.normalAttrs[key]) : newNormalAttrs[key] = this.getNormalAttribute(key);
        })), Object.keys(this.normalAttrs).forEach((key => {
            stateAttrs[key] = this.normalAttrs[key];
        }))) : Object.keys(stateAttrs).forEach((key => {
            newNormalAttrs[key] = this.getNormalAttribute(key);
        })), this.normalAttrs = newNormalAttrs;
    }
    getNormalAttribute(key) {
        let value = this.attribute[key];
        return this.animates && this.animates.forEach((animate => {
            if (animate.stateNames) {
                const endProps = animate.getEndProps();
                (0, vutils_1.has)(endProps, key) && (value = endProps[key]);
            }
        })), value;
    }
    clearStates(hasAnimation) {
        this.hasState() && this.normalAttrs && this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0), 
        this.normalAttrs = null, this.currentStates = [];
    }
    removeState(stateName, hasAnimation) {
        if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) >= 0) {
            const currentStates = this.currentStates.filter((state => state !== stateName));
            this.useStates(currentStates, hasAnimation);
        }
    }
    toggleState(stateName, hasAnimation) {
        if (this.hasState(stateName)) this.removeState(stateName, hasAnimation); else {
            if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) < 0) {
                const nextStates = this.currentStates ? this.currentStates.slice() : [];
                nextStates.push(stateName), this.useStates(nextStates, hasAnimation);
            }
        }
    }
    addState(stateName, keepCurrentStates, hasAnimation) {
        var _a;
        if (this.currentStates && this.currentStates.includes(stateName) && (keepCurrentStates || 1 === this.currentStates.length)) return;
        const newStates = keepCurrentStates && (null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) ? this.currentStates.concat([ stateName ]) : [ stateName ];
        this.useStates(newStates, hasAnimation);
    }
    useStates(states, hasAnimation) {
        var _a;
        if (!states.length) return void this.clearStates(hasAnimation);
        if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some(((stateName, index) => this.currentStates[index] !== stateName)))) return;
        const stateAttrs = {};
        states.forEach((stateName => {
            var _a;
            const attrs = this.stateProxy ? this.stateProxy(stateName, states) : null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
            attrs && Object.assign(stateAttrs, attrs);
        })), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
    }
    addUpdateBoundTag() {
        this._updateTag |= enums_1.UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), 
        this.glyphHost && this.glyphHost.addUpdateBoundTag();
    }
    addUpdateShapeTag() {
        this._updateTag |= enums_1.UpdateTag.UPDATE_SHAPE;
    }
    addUpdateShapeAndBoundsTag() {
        this._updateTag |= enums_1.UpdateTag.UPDATE_SHAPE_AND_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), 
        this.glyphHost && this.glyphHost.addUpdateBoundTag();
    }
    updateShapeAndBoundsTagSetted() {
        return (this._updateTag & enums_1.UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === enums_1.UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
    }
    clearUpdateBoundTag() {
        this._updateTag &= enums_1.UpdateTag.CLEAR_BOUNDS;
    }
    addUpdatePositionTag() {
        this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= enums_1.UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
    }
    addUpdateGlobalPositionTag() {
        this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= enums_1.UpdateTag.UPDATE_GLOBAL_MATRIX;
    }
    clearUpdateLocalPositionTag() {
        this._updateTag &= enums_1.UpdateTag.CLEAR_LOCAL_MATRIX;
    }
    clearUpdateGlobalPositionTag() {
        this._updateTag &= enums_1.UpdateTag.CLEAR_GLOBAL_MATRIX;
    }
    doUpdateLocalMatrix() {
        const {x: x = config_1.DefaultTransform.x, y: y = config_1.DefaultTransform.y, scaleX: scaleX = config_1.DefaultTransform.scaleX, scaleY: scaleY = config_1.DefaultTransform.scaleY, angle: angle = config_1.DefaultTransform.angle, anchor: anchor, postMatrix: postMatrix} = this.attribute, _anchor = [ 0, 0 ];
        if (anchor) {
            if ("string" == typeof anchor[0]) {
                const ratio = parseFloat(anchor[0]) / 100, bounds = this.AABBBounds;
                _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
            } else _anchor[0] = anchor[0];
            if ("string" == typeof anchor[1]) {
                const ratio = parseFloat(anchor[1]) / 100, bounds = this.AABBBounds;
                _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
            } else _anchor[1] = anchor[1];
        }
        (0, vutils_1.normalTransform)(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle, anchor && _anchor);
        const p = this.getOffsetXY(config_1.DefaultTransform);
        if (this._transMatrix.e += p.x, this._transMatrix.f += p.y, postMatrix) {
            const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f), m2 = this._transMatrix;
            m1.multiply(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f), m2.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
        }
    }
    doUpdateGlobalMatrix() {
        if (this.parent) {
            this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
            const {scrollX: scrollX = 0, scrollY: scrollY = 0} = this.parent.attribute;
            this._globalTransMatrix.translate(scrollX, scrollY);
        }
    }
    setStage(stage, layer) {
        this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), 
        this._onSetStage && this._onSetStage(this, stage, layer), application_1.application.graphicService.onSetStage(this, stage));
    }
    setStageToShadowRoot(stage, layer) {
        this.shadowRoot && this.shadowRoot.setStage(stage, layer);
    }
    onAddStep(step) {}
    onStop(props) {
        props && this.setAttributes(props, !1, {
            type: enums_1.AttributeUpdateType.ANIMATE_END
        });
    }
    onStep(subAnimate, animate, step, ratio, end) {
        const nextAttributes = {};
        if (step.customAnimate) step.customAnimate.update(end, ratio, nextAttributes); else {
            const nextProps = step.props, nextParsedProps = step.parsedProps, propKeys = step.propKeys;
            this.stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, void 0, nextParsedProps, propKeys);
        }
        this.setAttributes(nextAttributes, !1, {
            type: enums_1.AttributeUpdateType.ANIMATE_UPDATE,
            animationState: {
                ratio: ratio,
                end: end,
                step: step,
                isFirstFrameOfStep: subAnimate.getLastStep() !== step
            }
        }), this.stage && this.stage.renderNextFrame();
    }
    stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, lastProps, nextParsedProps, propKeys) {
        propKeys || (propKeys = Object.keys(nextProps), step.propKeys = propKeys), end ? step.propKeys.forEach((key => {
            animate.validAttr(key) && (nextAttributes[key] = nextProps[key]);
        })) : propKeys.forEach((key => {
            var _a;
            if (!animate.validAttr(key)) return;
            const nextStepVal = nextProps[key], lastStepVal = null !== (_a = lastProps && lastProps[key]) && void 0 !== _a ? _a : subAnimate.getLastPropByName(key, step);
            let match;
            match = animate.interpolateFunc && animate.interpolateFunc(key, ratio, lastStepVal, nextStepVal, nextAttributes), 
            match || (match = animate.customInterpolate(key, ratio, lastStepVal, nextStepVal, this, nextAttributes), 
            match || this.defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) || this._interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes));
        })), step.parsedProps = nextParsedProps;
    }
    defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) {
        if (Number.isFinite(nextStepVal)) return nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio, 
        !0;
        if ("fill" === key) {
            nextParsedProps || (nextParsedProps = {});
            const fillColorArray = nextParsedProps.fillColorArray, color = (0, interpolate_1.interpolateColor)(lastStepVal, null != fillColorArray ? fillColorArray : nextStepVal, ratio, !1, ((fArray, tArray) => {
                nextParsedProps.fillColorArray = tArray;
            }));
            return color && (nextAttributes[key] = color), !0;
        }
        if ("stroke" === key) {
            nextParsedProps || (nextParsedProps = {});
            const strokeColorArray = nextParsedProps.strokeColorArray, color = (0, interpolate_1.interpolateColor)(lastStepVal, null != strokeColorArray ? strokeColorArray : nextStepVal, ratio, !1, ((fArray, tArray) => {
                nextParsedProps.strokeColorArray = tArray;
            }));
            return color && (nextAttributes[key] = color), !0;
        }
        if ("shadowColor" === key) {
            nextParsedProps || (nextParsedProps = {});
            const shadowColorArray = nextParsedProps.shadowColorArray, color = (0, interpolate_1.interpolateColor)(lastStepVal, null != shadowColorArray ? shadowColorArray : nextStepVal, ratio, !0, ((fArray, tArray) => {
                nextParsedProps.shadowColorArray = tArray;
            }));
            return color && (nextAttributes[key] = color), !0;
        }
        return !1;
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {}
    getDefaultAttribute(name) {
        return (0, theme_1.getTheme)(this)[this.type][name];
    }
    getComputedAttribute(name) {
        var _a;
        return null !== (_a = this.attribute[name]) && void 0 !== _a ? _a : this.getDefaultAttribute(name);
    }
    onSetStage(cb, immediate = !1) {
        this._onSetStage = cb, immediate && this.stage && cb(this, this.stage);
    }
    attachShadow(shadowRoot) {
        return shadowRoot && (shadowRoot.shadowHost = this), this.shadowRoot = null != shadowRoot ? shadowRoot : application_1.application.graphicService.creator.shadowRoot(this), 
        this.addUpdateBoundTag(), this.shadowRoot.setStage(this.stage, this.layer), this.shadowRoot;
    }
    detachShadow() {
        this.shadowRoot && (this.addUpdateBoundTag(), this.shadowRoot = null);
    }
    toJson() {
        return {
            attribute: this.attribute,
            _uid: this._uid,
            type: this.type,
            name: this.name,
            children: this.children.map((item => item.toJson()))
        };
    }
    createPathProxy(path) {
        return (0, vutils_1.isString)(path, !0) ? this.pathProxy = (new custom_path2d_1.CustomPath2D).fromString(path) : this.pathProxy = new custom_path2d_1.CustomPath2D, 
        this.pathProxy;
    }
    loadImage(image, background = !1) {
        if (!image) return;
        const url = image;
        this.resources || (this.resources = new Map);
        const cache = {
            data: "init",
            state: null
        };
        this.resources.set(url, cache), "string" == typeof image ? (cache.state = "loading", 
        (0, vutils_1.isValidUrl)(image) || (0, vutils_1.isBase64)(image) ? (loader_1.ResourceLoader.GetImage(image, this), 
        this.backgroundImg = this.backgroundImg || background) : image.startsWith("<svg") && (loader_1.ResourceLoader.GetSvg(image, this), 
        this.backgroundImg = this.backgroundImg || background)) : (cache.state = "success", 
        cache.data = image, this.backgroundImg = this.backgroundImg || background);
    }
    imageLoadSuccess(url, image, cb) {
        if (!this.resources) return;
        const res = this.resources.get(url);
        res && (res.state = "success", res.data = image, cb && cb(), this.addUpdateBoundTag(), 
        this.stage && this.stage.renderNextFrame());
    }
    imageLoadFail(url, cb) {
        if (!this.resources) return;
        const res = this.resources.get(url);
        res && (res.state = "fail", cb && cb());
    }
    release() {
        this.releaseStatus = "released";
    }
    _emitCustomEvent(type, context) {
        var _a, _b;
        if (this._events && type in this._events) {
            const changeEvent = new event_1.CustomEvent(type, context);
            changeEvent.bubbles = !1, changeEvent.manager = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem) || void 0 === _b ? void 0 : _b.manager, 
            this.dispatchEvent(changeEvent);
        }
    }
}

exports.Graphic = Graphic, Graphic.mixin(event_1.EventTarget);
//# sourceMappingURL=graphic.js.map

}, function(modId) { var map = {"./node-tree":1689069767710,"../event":1689069767712,"./config":1689069767680,"../application":1689069767703,"../animate":1689069767728,"../color-string/interpolate":1689069767740,"../common/custom-path2d":1689069767681,"./theme":1689069767707,"../resource-loader/loader":1689069767743,"../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767710, function(require, module, exports) {


var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Node = void 0;

const vutils_1 = require("@visactor/vutils"), generator_1 = require("../common/generator");

class Node extends vutils_1.EventEmitter {
    get previousSibling() {
        return this._prev;
    }
    get nextSibling() {
        return this._next;
    }
    get children() {
        return this.getChildren();
    }
    get firstChild() {
        return this._firstChild;
    }
    get lastChild() {
        return this._lastChild;
    }
    get count() {
        return this._count;
    }
    get childrenCount() {
        return this._idMap ? this._idMap.size : 0;
    }
    constructor() {
        super(), this._uid = generator_1.Generator.GenAutoIncrementId(), this._firstChild = null, 
        this._lastChild = null, this.parent = null, this._count = 1;
    }
    forEachChildren(cb, reverse = !1) {
        if (reverse) {
            let child = this._lastChild, i = 0;
            for (;child; ) {
                if (cb(child, i++)) return;
                child = child._prev;
            }
        } else {
            let child = this._firstChild, i = 0;
            for (;child; ) {
                if (cb(child, i++)) return;
                child = child._next;
            }
        }
    }
    forEachChildrenAsync(cb, reverse = !1) {
        return __awaiter(this, void 0, void 0, (function*() {
            if (reverse) {
                let child = this._lastChild, i = 0;
                for (;child; ) {
                    let breakTag = cb(child, i++);
                    if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
                    child = child._prev;
                }
            } else {
                let child = this._firstChild, i = 0;
                for (;child; ) {
                    let breakTag = cb(child, i++);
                    if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
                    child = child._next;
                }
            }
        }));
    }
    forEach(cb) {
        return this.forEachChildren(cb);
    }
    appendChild(node) {
        if (this._uid === node._uid) return null;
        if (node.isAncestorsOf(this)) throw new Error("【Node::appendChild】不能将父辈元素append为子元素");
        return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, 
        node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, 
        node._prev = node._next = null), this._idMap || (this._idMap = new Map), this._idMap.set(node._uid, node), 
        this.setCount(node.count), this._structEdit = !0, node;
    }
    appendChildArrHighPerformance(nodes, replace = !1) {
        return console.error("暂不支持该函数"), nodes;
    }
    insertBefore(newNode, referenceNode) {
        if (this._uid === newNode._uid) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
        return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), 
        newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, 
        referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = new Map), 
        this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), 
        newNode);
    }
    insertAfter(newNode, referenceNode) {
        if (this._uid === newNode._uid) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertAfter】不能将父辈元素insert为子元素");
        return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), 
        newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, 
        newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, 
        newNode._prev = referenceNode, this._idMap || (this._idMap = new Map), this._idMap.set(newNode._uid, newNode), 
        this._structEdit = !0, this.setCount(newNode.count), newNode);
    }
    insertInto(newNode, idx) {
        if (this._nodeList && console.warn("insertIntoKeepIdx和insertInto混用可能会存在错误"), idx >= this.childrenCount) return this.appendChild(newNode);
        if (this._uid === newNode._uid) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
        if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, 
        0 === idx) newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), 
        newNode._prev = null, this._firstChild = newNode; else {
            let child = this._firstChild;
            for (let i = 0; i < idx; i++) {
                if (!child) return null;
                i > 0 && (child = child._next);
            }
            if (!child) return null;
            newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);
        }
        return this._idMap || (this._idMap = new Map), this._idMap.set(newNode._uid, newNode), 
        this._structEdit = !0, this.setCount(newNode.count), newNode;
    }
    insertIntoKeepIdx(newNode, idx) {
        if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx]) {
            const node = this._nodeList[idx];
            return this._nodeList.splice(idx, 0, newNode), this.insertBefore(newNode, node);
        }
        let node;
        this._nodeList[idx] = newNode;
        for (let i = idx - 1; i >= 0 && (node = this._nodeList[i], !node); i--) ;
        return node ? node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode) : this.insertInto(newNode, 0);
    }
    removeChild(child) {
        if (!this._idMap) return null;
        if (!this._idMap.has(child._uid)) return null;
        if (this._idMap.delete(child._uid), this._nodeList) {
            const idx = this._nodeList.findIndex((n => n === child));
            idx > 0 && this._nodeList.splice(idx, 1);
        }
        return child._prev ? child._prev._next = child._next : this._firstChild = child._next, 
        child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, 
        child._prev = null, child._next = null, this._structEdit = !0, this.setCount(-child.count), 
        child;
    }
    delete() {
        this.parent && this.parent.removeChild(this);
    }
    removeAllChild() {
        if (!this._idMap) return;
        let child = this._firstChild;
        for (;child; ) child.parent = null, child._prev = null, child._next = null, child = child._next;
        this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = !0, 
        this.setCount(1 - this._count);
    }
    replaceChild(newChild, oldChild) {
        throw new Error("暂不支持");
    }
    find(callback, deep = !1) {
        let target = null;
        return this.forEachChildren(((node, index) => !(node === this || !callback(node, index)) && (target = node, 
        !0))), deep && this.forEachChildren((child => {
            if (child.isContainer) {
                const node = child.find(callback, !0);
                if (node) return target = node, !0;
            }
            return !1;
        })), target;
    }
    findAll(callback, deep = !1) {
        let nodes = [];
        return this.forEachChildren(((node, index) => {
            node !== this && callback(node, index) && nodes.push(node);
        })), deep && this.forEachChildren((child => {
            if (child.isContainer) {
                const targets = child.findAll(callback, !0);
                targets.length && (nodes = nodes.concat(targets));
            }
        })), nodes;
    }
    getElementById(id) {
        return this.find((node => node.id === id), !0);
    }
    findChildById(id) {
        return this.getElementById(id);
    }
    findChildByUid(uid) {
        return this._idMap && this._idMap.get(uid) || null;
    }
    getElementsByName(name) {
        return this.findAll((node => node.name === name), !0);
    }
    findChildrenByName(name) {
        return this.getElementsByName(name);
    }
    getElementsByType(type) {
        return this.findAll((node => node.type === type), !0);
    }
    getChildByName(name, deep = !1) {
        return this.find((node => node.name === name), deep);
    }
    getChildAt(idx) {
        let c = this._firstChild;
        if (!c) return null;
        for (let i = 0; i < idx; i++) {
            if (!c._next) return null;
            c = c._next;
        }
        return c;
    }
    at(idx) {
        return this.getChildAt(idx);
    }
    containNode(node) {
        if (!this._idMap) return !1;
        if (this._idMap.has(node._uid)) return !0;
        let child = this._firstChild;
        for (;child; ) {
            if (child.containNode(node)) return !0;
            child = child._next;
        }
        return !1;
    }
    getRootNode() {
        let parent = this.parent;
        for (;null == parent ? void 0 : parent.parent; ) parent = parent.parent;
        return parent || this;
    }
    hasChildNodes() {
        return null !== this._firstChild;
    }
    addChild(node) {
        return this.appendChild(node);
    }
    add(node) {
        return this.appendChild(node);
    }
    getChildren() {
        const nodes = [];
        let child = this._firstChild;
        for (;child; ) nodes.push(child), child = child._next;
        return nodes;
    }
    isChildOf(node) {
        return !!this.parent && this.parent._uid === node._uid;
    }
    isParentOf(node) {
        return node.isChildOf(this);
    }
    isDescendantsOf(node) {
        let parent = this.parent;
        if (!parent) return !1;
        do {
            if (parent._uid === node._uid) return !0;
            parent = parent.parent;
        } while (null !== parent);
        return !1;
    }
    isAncestorsOf(node) {
        return node.isDescendantsOf(this);
    }
    getAncestor(idx) {
        throw new Error("暂不支持");
    }
    setAllDescendantsProps(propsName, propsValue) {
        let child = this._firstChild;
        for (;child; ) child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), 
        child = child._next;
    }
    setCount(deltaCount) {
        this._count += deltaCount;
        let parent = this.parent;
        if (parent) do {
            parent._count += deltaCount, parent = parent.parent;
        } while (null !== parent);
    }
    clone() {
        throw new Error("暂不支持");
    }
    cloneTo(node) {
        throw new Error("暂不支持");
    }
    getParent() {
        return this.parent;
    }
    del(child) {
        return this.removeChild(child);
    }
    addEventListener(type, listener, options) {
        const capture = (0, vutils_1.isBoolean)(options, !0) && options || (0, vutils_1.isObject)(options) && options.capture, once = (0, 
        vutils_1.isObject)(options) && options.once, context = (0, vutils_1.isFunction)(listener) ? void 0 : listener;
        return type = capture ? `${type}capture` : type, listener = (0, vutils_1.isFunction)(listener) ? listener : listener.handleEvent, 
        once ? super.once(type, listener, context) : super.on(type, listener, context), 
        this;
    }
    on(type, listener, options) {
        return this.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
        const capture = (0, vutils_1.isBoolean)(options, !0) && options || (0, vutils_1.isObject)(options) && options.capture, context = (0, 
        vutils_1.isFunction)(listener) ? void 0 : listener;
        type = capture ? `${type}capture` : type, listener = (0, vutils_1.isFunction)(listener) ? listener : listener.handleEvent;
        const once = (0, vutils_1.isObject)(options) && options.once;
        return super.off(type, listener, context, once), this;
    }
    off(type, listener, options) {
        return this.removeEventListener(type, listener, options);
    }
    once(type, listener, options) {
        return (0, vutils_1.isObject)(options) ? (options.once = !0, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {
            once: !0
        });
    }
    removeAllEventListeners() {
        return super.removeAllListeners(), this;
    }
    removeAllListeners() {
        return this.removeAllEventListeners();
    }
    dispatchEvent(event, ...args) {
        return super.emit(event.type, event, ...args), !event.defaultPrevented;
    }
    emit(event, data) {
        return this.dispatchEvent(event, data);
    }
    release() {
        this.removeAllListeners();
    }
}

exports.Node = Node;
//# sourceMappingURL=node-tree.js.map

}, function(modId) { var map = {"../common/generator":1689069767711}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767711, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Generator = void 0;

class Generator {
    static GenAutoIncrementId() {
        return Generator.auto_increment_id++;
    }
}

exports.Generator = Generator, Generator.auto_increment_id = 0;
//# sourceMappingURL=generator.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767712, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./federated-event"), exports), __exportStar(require("./event-manager"), exports), 
__exportStar(require("./event-target"), exports), __exportStar(require("./event-system"), exports), 
__exportStar(require("./extension"), exports), __exportStar(require("../interface/event"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./federated-event":1689069767713,"./event-manager":1689069767719,"./event-target":1689069767722,"./event-system":1689069767723,"./extension":1689069767724,"../interface/event":1689069767727}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767713, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./base-event"), exports), __exportStar(require("./mouse-event"), exports), 
__exportStar(require("./pointer-event"), exports), __exportStar(require("./wheel-event"), exports), 
__exportStar(require("./custom-event"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./base-event":1689069767714,"./mouse-event":1689069767715,"./pointer-event":1689069767716,"./wheel-event":1689069767717,"./custom-event":1689069767718}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767714, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.FederatedEvent = void 0;

const vutils_1 = require("@visactor/vutils");

class FederatedEvent {
    get layerX() {
        return this.layer.x;
    }
    get layerY() {
        return this.layer.y;
    }
    get pageX() {
        return this.page.x;
    }
    get pageY() {
        return this.page.y;
    }
    get x() {
        return this.canvas.x;
    }
    get y() {
        return this.canvas.y;
    }
    get canvasX() {
        return this.canvas.x;
    }
    get canvasY() {
        return this.canvas.y;
    }
    get viewX() {
        return this.viewport.x;
    }
    get viewY() {
        return this.viewport.y;
    }
    constructor(manager) {
        this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, 
        this.defaultPrevented = !1, this.eventPhase = FederatedEvent.prototype.NONE, this.propagationStopped = !1, 
        this.propagationImmediatelyStopped = !1, this.layer = new vutils_1.Point, this.page = new vutils_1.Point, 
        this.canvas = new vutils_1.Point, this.viewport = new vutils_1.Point, this.NONE = 0, 
        this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
    }
    composedPath() {
        return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), 
        this.path;
    }
    preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), 
        this.defaultPrevented = !0;
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0;
    }
    stopPropagation() {
        this.propagationStopped = !0;
    }
    initEvent() {}
    initUIEvent() {}
    clone() {
        throw new Error("Method not implemented.");
    }
}

exports.FederatedEvent = FederatedEvent;
//# sourceMappingURL=base-event.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767715, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.FederatedMouseEvent = void 0;

const vutils_1 = require("@visactor/vutils"), base_event_1 = require("./base-event");

class FederatedMouseEvent extends base_event_1.FederatedEvent {
    constructor() {
        super(...arguments), this.client = new vutils_1.Point, this.movement = new vutils_1.Point, 
        this.offset = new vutils_1.Point, this.global = new vutils_1.Point, this.screen = new vutils_1.Point;
    }
    get clientX() {
        return this.client.x;
    }
    get clientY() {
        return this.client.y;
    }
    get movementX() {
        return this.movement.x;
    }
    get movementY() {
        return this.movement.y;
    }
    get offsetX() {
        return this.offset.x;
    }
    get offsetY() {
        return this.offset.y;
    }
    get globalX() {
        return this.global.x;
    }
    get globalY() {
        return this.global.y;
    }
    get screenX() {
        return this.screen.x;
    }
    get screenY() {
        return this.screen.y;
    }
    getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
    }
    initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
    }
}

exports.FederatedMouseEvent = FederatedMouseEvent;
//# sourceMappingURL=mouse-event.js.map

}, function(modId) { var map = {"./base-event":1689069767714}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767716, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.FederatedPointerEvent = void 0;

const mouse_event_1 = require("./mouse-event");

class FederatedPointerEvent extends mouse_event_1.FederatedMouseEvent {
    constructor() {
        super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1;
    }
    getCoalescedEvents() {
        return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [ this ] : [];
    }
    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
    }
    clone() {
        var _a, _b, _c;
        const event = new FederatedPointerEvent(this.manager);
        return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], 
        event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, 
        null === (_a = this.manager) || void 0 === _a || _a.copyPointerData(this, event), 
        null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), 
        null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, 
        event.path = this.composedPath().slice(), event.type = this.type, event;
    }
}

exports.FederatedPointerEvent = FederatedPointerEvent;
//# sourceMappingURL=pointer-event.js.map

}, function(modId) { var map = {"./mouse-event":1689069767715}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767717, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.FederatedWheelEvent = void 0;

const mouse_event_1 = require("./mouse-event");

class FederatedWheelEvent extends mouse_event_1.FederatedMouseEvent {
    constructor() {
        super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
    }
    clone() {
        var _a, _b, _c;
        const event = new FederatedWheelEvent(this.manager);
        return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], 
        event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, 
        null === (_a = this.manager) || void 0 === _a || _a.copyWheelData(this, event), 
        null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), 
        null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, 
        event.path = this.composedPath().slice(), event.type = this.type, event;
    }
}

exports.FederatedWheelEvent = FederatedWheelEvent, FederatedWheelEvent.DOM_DELTA_PIXEL = 0, 
FederatedWheelEvent.DOM_DELTA_LINE = 1, FederatedWheelEvent.DOM_DELTA_PAGE = 2;
//# sourceMappingURL=wheel-event.js.map

}, function(modId) { var map = {"./mouse-event":1689069767715}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767718, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CustomEvent = void 0;

const base_event_1 = require("./base-event");

class CustomEvent extends base_event_1.FederatedEvent {
    constructor(eventName, object) {
        super(), this.type = eventName, this.detail = object;
    }
}

exports.CustomEvent = CustomEvent;
//# sourceMappingURL=custom-event.js.map

}, function(modId) { var map = {"./base-event":1689069767714}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767719, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.EventManager = void 0;

const vutils_1 = require("@visactor/vutils"), federated_event_1 = require("./federated-event"), constant_1 = require("./constant"), util_1 = require("./util"), PROPAGATION_LIMIT = 2048;

function isMouseLike(pointerType) {
    return "mouse" === pointerType || "pen" === pointerType;
}

class EventManager {
    constructor(root) {
        this.dispatch = new vutils_1.EventEmitter, this.mappingState = {
            trackingData: {}
        }, this.eventPool = new Map, this.onPointerDown = (from, target) => {
            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn("EventManager cannot map a non-pointer event as a pointer event");
            const e = this.createPointerEvent(from, from.type, target);
            if (this.dispatchEvent(e, "pointerdown"), "touch" === e.pointerType) this.dispatchEvent(e, "touchstart"); else if (isMouseLike(e.pointerType)) {
                const isRightButton = 2 === e.button;
                this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
            }
            this.trackingData(from.pointerId).pressTargetsByButton[from.button] = e.composedPath(), 
            this.freeEvent(e);
        }, this.onPointerMove = (from, target) => {
            var _a, _b;
            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn("EventManager cannot map a non-pointer event as a pointer event");
            const e = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e.pointerType), trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);
            if (trackingData.overTargets && outTarget && outTarget !== this.rootTarget && outTarget !== e.target) {
                const outType = "mousemove" === from.type ? "mouseout" : "pointerout", outEvent = this.createPointerEvent(from, outType, outTarget || void 0);
                if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), 
                !e.composedPath().includes(outTarget)) {
                    const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
                    for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target); ) leaveEvent.currentTarget = leaveEvent.target, 
                    this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), 
                    leaveEvent.target = leaveEvent.target.parent;
                    this.freeEvent(leaveEvent);
                }
                this.freeEvent(outEvent);
            }
            if (outTarget !== e.target) {
                const overType = "mousemove" === from.type ? "mouseover" : "pointerover", overEvent = this.clonePointerEvent(e, overType);
                this.dispatchEvent(overEvent, "pointerover"), isMouse && this.dispatchEvent(overEvent, "mouseover");
                let overTargetAncestor = null == outTarget ? void 0 : outTarget.parent;
                for (;overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e.target; ) overTargetAncestor = overTargetAncestor.parent;
                if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {
                    const enterEvent = this.clonePointerEvent(e, "pointerenter");
                    for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent; ) enterEvent.currentTarget = enterEvent.target, 
                    this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), 
                    enterEvent.target = enterEvent.target.parent;
                    this.freeEvent(enterEvent);
                }
                this.freeEvent(overEvent);
            }
            this.dispatchEvent(e, "pointermove"), "touch" === e.pointerType && this.dispatchEvent(e, "touchmove"), 
            isMouse && (this.dispatchEvent(e, "mousemove"), this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor()), 
            trackingData.overTargets = e.composedPath(), this.freeEvent(e);
        }, this.onPointerOver = (from, target) => {
            var _a, _b;
            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn("EventManager cannot map a non-pointer event as a pointer event");
            const trackingData = this.trackingData(from.pointerId), e = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e.pointerType);
            this.dispatchEvent(e, "pointerover"), isMouse && this.dispatchEvent(e, "mouseover"), 
            "mouse" === e.pointerType && (this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor());
            const enterEvent = this.clonePointerEvent(e, "pointerenter");
            for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; ) enterEvent.currentTarget = enterEvent.target, 
            this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), 
            enterEvent.target = enterEvent.target.parent;
            trackingData.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(enterEvent);
        }, this.onPointerOut = (from, target) => {
            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn("EventManager cannot map a non-pointer event as a pointer event");
            const trackingData = this.trackingData(from.pointerId);
            if (trackingData.overTargets) {
                const isMouse = isMouseLike(from.pointerType), outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, "pointerout", outTarget || void 0);
                this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, "mouseout");
                const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
                for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; ) leaveEvent.currentTarget = leaveEvent.target, 
                this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), 
                leaveEvent.target = leaveEvent.target.parent;
                trackingData.overTargets = [], this.freeEvent(outEvent), this.freeEvent(leaveEvent);
            }
            this.cursor = "";
        }, this.onPointerUp = (from, target) => {
            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn("EventManager cannot map a non-pointer event as a pointer event");
            const now = util_1.clock.now(), e = this.createPointerEvent(from, from.type, target);
            if (this.dispatchEvent(e, "pointerup"), "touch" === e.pointerType) this.dispatchEvent(e, "touchend"); else if (isMouseLike(e.pointerType)) {
                const isRightButton = 2 === e.button;
                this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
            }
            const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
            let clickTarget = pressTarget;
            if (pressTarget && !e.composedPath().includes(pressTarget)) {
                let currentTarget = pressTarget;
                for (;currentTarget && !e.composedPath().includes(currentTarget); ) {
                    if (e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType) this.notifyTarget(e, "touchendoutside"); else if (isMouseLike(e.pointerType)) {
                        const isRightButton = 2 === e.button;
                        this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
                    }
                    currentTarget = currentTarget.parent;
                }
                delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;
            }
            if (clickTarget) {
                const clickEvent = this.clonePointerEvent(e, "click");
                clickEvent.target = clickTarget, clickEvent.path = [], trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {
                    clickCount: 0,
                    target: clickEvent.target,
                    timeStamp: now
                });
                const clickHistory = trackingData.clicksByButton[from.button];
                clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200 ? ++clickHistory.clickCount : clickHistory.clickCount = 1, 
                clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, 
                isMouseLike(clickEvent.pointerType) ? (this.dispatchEvent(clickEvent, "click"), 
                2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dblclick")) : "touch" === clickEvent.pointerType && this.dispatchEvent(clickEvent, "tap"), 
                this.dispatchEvent(clickEvent, "pointertap"), this.freeEvent(clickEvent);
            }
            this.freeEvent(e);
        }, this.onPointerUpOutside = (from, target) => {
            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn("EventManager cannot map a non-pointer event as a pointer event");
            const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e = this.createPointerEvent(from, from.type, target);
            if (pressTarget) {
                let currentTarget = pressTarget;
                for (;currentTarget; ) e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), 
                "touch" === e.pointerType ? this.notifyTarget(e, "touchendoutside") : isMouseLike(e.pointerType) && this.notifyTarget(e, 2 === e.button ? "rightupoutside" : "mouseupoutside"), 
                currentTarget = currentTarget.parent;
                delete trackingData.pressTargetsByButton[from.button];
            }
            this.freeEvent(e);
        }, this.onWheel = (from, target) => {
            if (!(from instanceof federated_event_1.FederatedWheelEvent)) return void console.warn("EventManager cannot map a non-wheel event as a wheel event");
            const wheelEvent = this.createWheelEvent(from, target);
            this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);
        }, this.rootTarget = root, this.mappingTable = {}, this.addEventMapping("pointerdown", this.onPointerDown), 
        this.addEventMapping("pointermove", this.onPointerMove), this.addEventMapping("pointerout", this.onPointerOut), 
        this.addEventMapping("pointerleave", this.onPointerOut), this.addEventMapping("pointerover", this.onPointerOver), 
        this.addEventMapping("pointerup", this.onPointerUp), this.addEventMapping("pointerupoutside", this.onPointerUpOutside), 
        this.addEventMapping("wheel", this.onWheel);
    }
    addEventMapping(type, fn) {
        this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({
            fn: fn,
            priority: 0
        }), this.mappingTable[type].sort(((a, b) => a.priority - b.priority));
    }
    dispatchEvent(e, type) {
        e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, type), 
        this.dispatch.emit(type || e.type, e);
    }
    mapEvent(e) {
        var _a;
        if (!this.rootTarget) return;
        const mappers = this.mappingTable[e.type];
        let target;
        const cacheKey = `${e.canvasX}-${e.canvasY}`;
        if ((null === (_a = this._prePointTargetCache) || void 0 === _a ? void 0 : _a[cacheKey]) ? target = this._prePointTargetCache[cacheKey] : (target = this.pickTarget(e.canvasX, e.canvasY), 
        this._prePointTargetCache = {
            [cacheKey]: target
        }), mappers) for (let i = 0, j = mappers.length; i < j; i++) mappers[i].fn(e, target); else console.warn(`[EventManager]: Event mapping not defined for ${e.type}`);
    }
    propagate(e, type) {
        if (!e.target) return;
        const composedPath = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for (let i = 0, j = composedPath.length - 1; i < j; i++) if (e.currentTarget = composedPath[i], 
        this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
        if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), 
        !e.propagationStopped && !e.propagationImmediatelyStopped) {
            e.eventPhase = e.BUBBLING_PHASE;
            for (let i = composedPath.length - 2; i >= 0; i--) if (e.currentTarget = composedPath[i], 
            this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
        }
    }
    propagationPath(target) {
        const propagationPath = [ target ];
        for (let i = 0; i < 2048 && target !== this.rootTarget && target.parent; i++) {
            if (!target.parent) throw new Error("Cannot find propagation path to disconnected target");
            propagationPath.push(target.parent), target = target.parent;
        }
        return propagationPath.reverse(), propagationPath;
    }
    notifyTarget(e, type) {
        type = null != type ? type : e.type;
        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
        this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);
    }
    findMountedTarget(propagationPath) {
        if (!propagationPath) return null;
        let currentTarget = propagationPath[0];
        for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++) currentTarget = propagationPath[i];
        return currentTarget;
    }
    createPointerEvent(from, type, target) {
        const event = this.allocateEvent(federated_event_1.FederatedPointerEvent);
        return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), 
        event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(event.global.x, event.global.y), 
        "string" == typeof type && (event.type = type), event;
    }
    createWheelEvent(from, target) {
        const event = this.allocateEvent(federated_event_1.FederatedWheelEvent);
        return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), 
        event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(event.global.x, event.global.y), 
        event;
    }
    clonePointerEvent(from, type) {
        const event = this.allocateEvent(federated_event_1.FederatedPointerEvent);
        return event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, 
        this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), 
        event.target = from.target, event.path = from.composedPath().slice(), event.type = null != type ? type : event.type, 
        event;
    }
    copyWheelData(from, to) {
        to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, 
        to.deltaZ = from.deltaZ;
    }
    copyPointerData(from, to) {
        from instanceof federated_event_1.FederatedPointerEvent && to instanceof federated_event_1.FederatedPointerEvent && (to.pointerId = from.pointerId, 
        to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, 
        to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, 
        to.tiltY = from.tiltY, to.twist = from.twist);
    }
    copyMouseData(from, to) {
        from instanceof federated_event_1.FederatedMouseEvent && to instanceof federated_event_1.FederatedMouseEvent && (to.altKey = from.altKey, 
        to.button = from.button, to.buttons = from.buttons, to.client.copyFrom(from.client), 
        to.ctrlKey = from.ctrlKey, to.shiftKey = from.shiftKey, to.metaKey = from.metaKey, 
        to.movement.copyFrom(from.movement), to.canvas.copyFrom(from.canvas), to.screen.copyFrom(from.screen), 
        to.global.copyFrom(from.global), to.offset.copyFrom(from.offset), to.viewport.copyFrom(from.viewport));
    }
    copyData(from, to) {
        to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = util_1.clock.now(), 
        to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, 
        to.layer.copyFrom(from.layer), to.page.copyFrom(from.page);
    }
    trackingData(id) {
        return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
        }), this.mappingState.trackingData[id];
    }
    allocateEvent(constructor) {
        var _a;
        this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
        const event = (null === (_a = this.eventPool.get(constructor)) || void 0 === _a ? void 0 : _a.pop()) || new constructor(this);
        return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], 
        event.target = null, event;
    }
    freeEvent(event) {
        var _a;
        if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventManager!");
        const constructor = event.constructor;
        this.eventPool.has(constructor) || this.eventPool.set(constructor, []), null === (_a = this.eventPool.get(constructor)) || void 0 === _a || _a.push(event);
    }
    notifyListeners(e, type) {
        const listeners = e.currentTarget._events[type];
        if (listeners) if ("fn" in listeners) listeners.once && e.currentTarget.removeEventListener(type, listeners.fn, {
            once: !0
        }), listeners.fn.call(listeners.context, e); else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].once && e.currentTarget.removeEventListener(type, listeners[i].fn, {
            once: !0
        }), listeners[i].fn.call(listeners[i].context, e); else this.emitDelegation(e, type);
    }
    emitDelegation(e, type) {
        const listeners = e.currentTarget._events[constant_1.WILDCARD];
        if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type); else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
    }
    pickTarget(x, y) {
        let target;
        const pickResult = this.rootTarget.pick(x, y);
        return target = pickResult && pickResult.graphic ? pickResult.graphic : pickResult && pickResult.group ? pickResult.group : x >= 0 && x <= (0, 
        vutils_1.get)(this.rootTarget, "width") && y >= 0 && y <= (0, vutils_1.get)(this.rootTarget, "height") ? this.rootTarget : null, 
        target;
    }
}

exports.EventManager = EventManager;
//# sourceMappingURL=event-manager.js.map

}, function(modId) { var map = {"./federated-event":1689069767713,"./constant":1689069767720,"./util":1689069767721}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767720, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.WILDCARD = void 0, exports.WILDCARD = "*";
//# sourceMappingURL=constant.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767721, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.clock = void 0, exports.clock = "object" == typeof performance && performance.now ? performance : Date;
//# sourceMappingURL=util.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767722, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.EventTarget = void 0;

const federated_event_1 = require("./federated-event");

exports.EventTarget = {
    pickable: !0,
    visible: !0,
    dispatchEvent(e) {
        var _a;
        if (!(e instanceof federated_event_1.FederatedEvent)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        return e.defaultPrevented = !1, e.path = [], e.target = this, null === (_a = null == e ? void 0 : e.manager) || void 0 === _a || _a.dispatchEvent(e), 
        !e.defaultPrevented;
    },
    emit(eventName, object) {
        return this.dispatchEvent(new federated_event_1.CustomEvent(eventName, object));
    }
};
//# sourceMappingURL=event-target.js.map

}, function(modId) { var map = {"./federated-event":1689069767713}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767723, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.EventSystem = void 0;

const vutils_1 = require("@visactor/vutils"), event_manager_1 = require("./event-manager"), federated_event_1 = require("./federated-event"), util_1 = require("./util"), MOUSE_POINTER_ID = 1, TOUCH_TO_POINTER = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
};

class EventSystem {
    constructor(params) {
        this.resolution = 1, this.onPointerDown = nativeEvent => {
            if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
            const events = this.normalizeToPointerData(nativeEvent);
            if (this.autoPreventDefault && events[0].isNormalized) {
                (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();
            }
            for (let i = 0, j = events.length; i < j; i++) {
                const nativeEvent = events[i], federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent);
                this.manager.mapEvent(federatedEvent);
            }
            this.setCursor(this.manager.cursor);
        }, this.onPointerMove = nativeEvent => {
            if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
            if (this.isEventOutsideOfTargetElement(nativeEvent)) return;
            const normalizedEvents = this.normalizeToPointerData(nativeEvent);
            for (let i = 0, j = normalizedEvents.length; i < j; i++) {
                const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
                this.manager.mapEvent(event);
            }
            this.setCursor(this.manager.cursor);
        }, this.onPointerUp = nativeEvent => {
            if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
            const outside = this.isEventOutsideOfTargetElement(nativeEvent) ? "outside" : "", normalizedEvents = this.normalizeToPointerData(nativeEvent);
            for (let i = 0, j = normalizedEvents.length; i < j; i++) {
                const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
                event.type += outside, this.manager.mapEvent(event);
            }
            this.setCursor(this.manager.cursor);
        }, this.onPointerOverOut = nativeEvent => {
            if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
            const normalizedEvents = this.normalizeToPointerData(nativeEvent);
            for (let i = 0, j = normalizedEvents.length; i < j; i++) {
                const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
                this.manager.mapEvent(event);
            }
            this.setCursor(this.manager.cursor);
        }, this.onWheel = nativeEvent => {
            const wheelEvent = this.normalizeWheelEvent(nativeEvent);
            this.manager.mapEvent(wheelEvent);
        };
        const {targetElement: targetElement, resolution: resolution, rootNode: rootNode, global: global, viewport: viewport, autoPreventDefault: autoPreventDefault = !1} = params;
        this.manager = new event_manager_1.EventManager(rootNode), this.globalObj = global, 
        this.supportsPointerEvents = global.supportsPointerEvents, this.supportsTouchEvents = global.supportsTouchEvents, 
        this.supportsMouseEvents = global.supportsMouseEvents, this.applyStyles = global.applyStyles, 
        this.autoPreventDefault = autoPreventDefault, this.eventsAdded = !1, this.viewport = viewport, 
        this.rootPointerEvent = new federated_event_1.FederatedPointerEvent, this.rootWheelEvent = new federated_event_1.FederatedWheelEvent, 
        this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
        }, this.resolution = resolution, this.setTargetElement(targetElement);
    }
    release() {
        this.setTargetElement(null);
    }
    setCursor(mode = "default") {
        const {applyStyles: applyStyles, domElement: domElement} = this;
        if (this.currentCursor === mode) return;
        this.currentCursor = mode;
        const style = this.cursorStyles[mode];
        style ? "string" == typeof style && applyStyles ? domElement.style.cursor = style : "function" == typeof style ? style(mode) : "object" == typeof style && applyStyles && Object.assign(domElement.style, style) : applyStyles && (0, 
        vutils_1.isString)(mode) && !(0, vutils_1.has)(this.cursorStyles, mode) && (domElement.style.cursor = mode);
    }
    setTargetElement(element) {
        this.removeEvents(), this.domElement = element, this.addEvents();
    }
    addEvents() {
        if (this.eventsAdded || !this.domElement) return;
        const {globalObj: globalObj, domElement: domElement} = this;
        this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("pointermove", this.onPointerMove, !0), 
        globalObj.getDocument().addEventListener("pointerup", this.onPointerUp, !0)) : (domElement.addEventListener("pointermove", this.onPointerMove, !0), 
        domElement.addEventListener("pointerup", this.onPointerUp, !0)), domElement.addEventListener("pointerdown", this.onPointerDown, !0), 
        domElement.addEventListener("pointerleave", this.onPointerOverOut, !0), domElement.addEventListener("pointerover", this.onPointerOverOut, !0)) : (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("mousemove", this.onPointerMove, !0), 
        globalObj.getDocument().addEventListener("mouseup", this.onPointerUp, !0)) : (domElement.addEventListener("mousemove", this.onPointerMove, !0), 
        domElement.addEventListener("mouseup", this.onPointerUp, !0)), domElement.addEventListener("mousedown", this.onPointerDown, !0), 
        domElement.addEventListener("mouseout", this.onPointerOverOut, !0), domElement.addEventListener("mouseover", this.onPointerOverOut, !0)), 
        this.supportsTouchEvents && (domElement.addEventListener("touchstart", this.onPointerDown, !0), 
        domElement.addEventListener("touchend", this.onPointerUp, !0), domElement.addEventListener("touchmove", this.onPointerMove, !0)), 
        domElement.addEventListener("wheel", this.onWheel, {
            capture: !0
        }), this.eventsAdded = !0;
    }
    removeEvents() {
        if (!this.eventsAdded || !this.domElement) return;
        const {globalObj: globalObj, domElement: domElement} = this;
        this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().removeEventListener("pointermove", this.onPointerMove, !0), 
        globalObj.getDocument().removeEventListener("pointerup", this.onPointerUp, !0)) : (domElement.removeEventListener("pointermove", this.onPointerMove, !0), 
        domElement.removeEventListener("pointerup", this.onPointerUp, !0)), domElement.removeEventListener("pointerdown", this.onPointerDown, !0), 
        domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0), domElement.removeEventListener("pointerover", this.onPointerOverOut, !0)) : (globalObj.getDocument() ? (globalObj.getDocument().removeEventListener("mousemove", this.onPointerMove, !0), 
        globalObj.getDocument().removeEventListener("mouseup", this.onPointerUp, !0)) : (domElement.removeEventListener("mousemove", this.onPointerMove, !0), 
        domElement.removeEventListener("mouseup", this.onPointerUp, !0)), domElement.removeEventListener("mousedown", this.onPointerDown, !0), 
        domElement.removeEventListener("mouseout", this.onPointerOverOut, !0), domElement.removeEventListener("mouseover", this.onPointerOverOut, !0)), 
        this.supportsTouchEvents && (domElement.removeEventListener("touchstart", this.onPointerDown, !0), 
        domElement.removeEventListener("touchend", this.onPointerUp, !0), domElement.removeEventListener("touchmove", this.onPointerMove, !0)), 
        domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, 
        this.eventsAdded = !1;
    }
    mapToViewportPoint(event) {
        const viewport = this.viewport, {x: x, y: y} = event;
        return {
            x: x - viewport.x,
            y: y - viewport.y
        };
    }
    mapToCanvasPoint(nativeEvent) {
        var _a;
        const point = null === (_a = this.globalObj) || void 0 === _a ? void 0 : _a.mapToCanvasPoint(nativeEvent, this.domElement);
        if (point) return point;
        const {clientX: x, clientY: y} = nativeEvent, rect = this.domElement.getBoundingClientRect();
        return {
            x: x - rect.left,
            y: y - rect.top
        };
    }
    normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents && event.changedTouches && event.changedTouches.length) for (let i = 0, li = event.changedTouches.length; i < li; i++) {
            const touch = event.changedTouches[i];
            (0, vutils_1.isUndefined)(touch.button) && (touch.button = 0), (0, vutils_1.isUndefined)(touch.buttons) && (touch.buttons = 1), 
            (0, vutils_1.isUndefined)(touch.isPrimary) && (touch.isPrimary = 1 === event.touches.length && "touchstart" === event.type), 
            (0, vutils_1.isUndefined)(touch.width) && (touch.width = touch.radiusX || 1), (0, 
            vutils_1.isUndefined)(touch.height) && (touch.height = touch.radiusY || 1), (0, 
            vutils_1.isUndefined)(touch.tiltX) && (touch.tiltX = 0), (0, vutils_1.isUndefined)(touch.tiltY) && (touch.tiltY = 0), 
            (0, vutils_1.isUndefined)(touch.pointerType) && (touch.pointerType = "touch"), (0, 
            vutils_1.isUndefined)(touch.pointerId) && (touch.pointerId = touch.identifier || 0), 
            (0, vutils_1.isUndefined)(touch.pressure) && (touch.pressure = touch.force || .5), 
            (0, vutils_1.isUndefined)(touch.twist) && (touch.twist = 0), (0, vutils_1.isUndefined)(touch.tangentialPressure) && (touch.tangentialPressure = 0), 
            (0, vutils_1.isUndefined)(touch.layerX) && (touch.layerX = touch.offsetX = touch.clientX), 
            (0, vutils_1.isUndefined)(touch.layerY) && (touch.layerY = touch.offsetY = touch.clientY), 
            touch.isNormalized = !0, touch.type = event.type, normalizedEvents.push(touch);
        } else if (this.globalObj.supportsMouseEvents && (!(event instanceof MouseEvent) || this.supportsPointerEvents && event instanceof PointerEvent)) normalizedEvents.push(event); else {
            const tempEvent = event;
            (0, vutils_1.isUndefined)(tempEvent.isPrimary) && (tempEvent.isPrimary = !0), (0, 
            vutils_1.isUndefined)(tempEvent.width) && (tempEvent.width = 1), (0, vutils_1.isUndefined)(tempEvent.height) && (tempEvent.height = 1), 
            (0, vutils_1.isUndefined)(tempEvent.tiltX) && (tempEvent.tiltX = 0), (0, vutils_1.isUndefined)(tempEvent.tiltY) && (tempEvent.tiltY = 0), 
            (0, vutils_1.isUndefined)(tempEvent.pointerType) && (tempEvent.pointerType = "mouse"), 
            (0, vutils_1.isUndefined)(tempEvent.pointerId) && (tempEvent.pointerId = 1), (0, 
            vutils_1.isUndefined)(tempEvent.pressure) && (tempEvent.pressure = .5), (0, vutils_1.isUndefined)(tempEvent.twist) && (tempEvent.twist = 0), 
            (0, vutils_1.isUndefined)(tempEvent.tangentialPressure) && (tempEvent.tangentialPressure = 0), 
            tempEvent.isNormalized = !0, normalizedEvents.push(tempEvent);
        }
        return normalizedEvents;
    }
    normalizeWheelEvent(nativeEvent) {
        const event = this.rootWheelEvent;
        this.transferMouseData(event, nativeEvent), event.deltaMode = nativeEvent.deltaMode, 
        event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ;
        const {x: canvasX, y: canvasY} = this.mapToCanvasPoint(nativeEvent);
        event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.copyFrom(event.canvas), 
        event.offset.copyFrom(event.canvas);
        const {x: viewX, y: viewY} = this.mapToViewportPoint(event);
        return event.viewport.x = viewX, event.viewport.y = viewY, event.nativeEvent = nativeEvent, 
        event.type = nativeEvent.type, event;
    }
    bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, 
        event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, 
        event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, 
        event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, 
        event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent);
        const {x: canvasX, y: canvasY} = this.mapToCanvasPoint(nativeEvent);
        event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.copyFrom(event.canvas), 
        event.offset.copyFrom(event.canvas);
        const {x: viewX, y: viewY} = this.mapToViewportPoint(event);
        return event.viewport.x = viewX, event.viewport.y = viewY, event.isTrusted = nativeEvent.isTrusted, 
        "pointerleave" === event.type && (event.type = "pointerout"), event.type.startsWith("mouse") && (event.type = event.type.replace("mouse", "pointer")), 
        event.type.startsWith("touch") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), 
        event;
    }
    transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, 
        event.timeStamp = util_1.clock.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, 
        event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, 
        event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.shiftKey = nativeEvent.shiftKey, 
        event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, 
        event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null;
    }
    isEventOutsideOfTargetElement(nativeEvent) {
        let target = nativeEvent.target;
        nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);
        return target !== (this.domElement.getNativeHandler ? this.domElement.getNativeHandler().nativeCanvas : this.domElement);
    }
}

exports.EventSystem = EventSystem;
//# sourceMappingURL=event-system.js.map

}, function(modId) { var map = {"./event-manager":1689069767719,"./federated-event":1689069767713,"./util":1689069767721}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767724, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Gesture = exports.DragNDrop = void 0;

const drag_1 = require("./drag");

Object.defineProperty(exports, "DragNDrop", {
    enumerable: !0,
    get: function() {
        return drag_1.DragNDrop;
    }
});

const gesture_1 = require("./gesture");

Object.defineProperty(exports, "Gesture", {
    enumerable: !0,
    get: function() {
        return gesture_1.Gesture;
    }
});
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./drag":1689069767725,"./gesture":1689069767726}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767725, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DragNDrop = void 0;

class DragNDrop {
    constructor(rootNode) {
        this.onPointerDown = event => {
            const target = event.target, rootNode = this.rootNode, isRoot = target === rootNode;
            if (target && !isRoot) {
                let currentDroppable, dragstartTriggered = !1;
                function handlePointerMove(moveEvent) {
                    if (dragstartTriggered || (moveEvent.type = "dragstart", null == target || target.dispatchEvent(moveEvent), 
                    dragstartTriggered = !0), moveEvent.type = "drag", null == target || target.dispatchEvent(moveEvent), 
                    !isRoot) {
                        target.pickable = !1;
                        const elemBelow = (null == rootNode ? void 0 : rootNode.pick(moveEvent.global.x, moveEvent.global.y)).graphic;
                        target.pickable = !0, currentDroppable !== elemBelow && (currentDroppable && (moveEvent.type = "dragleave", 
                        moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)), 
                        elemBelow && (moveEvent.type = "dragenter", moveEvent.target = elemBelow, elemBelow.dispatchEvent(moveEvent)), 
                        currentDroppable = elemBelow, currentDroppable && (moveEvent.type = "dragover", 
                        moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)));
                    }
                }
                null == rootNode || rootNode.addEventListener("pointermove", handlePointerMove);
                const stopDragging = function() {
                    dragstartTriggered && (currentDroppable && (event.type = "drop", event.target = currentDroppable, 
                    currentDroppable.dispatchEvent(event)), event.type = "dragend", target.dispatchEvent(event), 
                    dragstartTriggered = !1), null == rootNode || rootNode.removeEventListener("pointermove", handlePointerMove);
                };
                target.addEventListener("pointerup", stopDragging, {
                    once: !0
                }), target.addEventListener("pointerupoutside", stopDragging, {
                    once: !0
                });
            }
        }, this.rootNode = rootNode, this.initEvents();
    }
    initEvents() {
        var _a;
        null === (_a = this.rootNode) || void 0 === _a || _a.addEventListener("pointerdown", this.onPointerDown);
    }
    removeEvents() {
        var _a;
        null === (_a = this.rootNode) || void 0 === _a || _a.removeEventListener("pointerdown", this.onPointerDown);
    }
    release() {
        this.removeEvents(), this.rootNode = null;
    }
}

exports.DragNDrop = DragNDrop;
//# sourceMappingURL=drag.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767726, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Gesture = void 0;

const vutils_1 = require("@visactor/vutils"), util_1 = require("../util"), constant_1 = require("../constant"), application_1 = require("../../application"), PRESS_TIME = 251, PRESS_THRESHOLD = 9, SWIPE_VELOCITY = .3, SWIPE_THRESHOLD = 10, calcDirection = (start, end) => {
    const xDistance = end.x - start.x, yDistance = end.y - start.y;
    return Math.abs(xDistance) > Math.abs(yDistance) ? xDistance > 0 ? "right" : "left" : yDistance > 0 ? "down" : "up";
}, calcDistance = (point1, point2) => {
    const xDistance = Math.abs(point2.x - point1.x), yDistance = Math.abs(point2.y - point1.y);
    return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
}, getCenter = points => {
    const pointersLength = points.length;
    if (1 === pointersLength) return {
        x: Math.round(points[0].x),
        y: Math.round(points[0].y)
    };
    let x = 0, y = 0, i = 0;
    for (;i < pointersLength; ) x += points[i].x, y += points[i].y, i++;
    return {
        x: Math.round(x / pointersLength),
        y: Math.round(y / pointersLength)
    };
};

class Gesture extends vutils_1.EventEmitter {
    constructor(element, config = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super(), this.cachedEvents = [], this.startPoints = [], this.processEvent = {}, 
        this.throttleTimer = 0, this.emitThrottles = [], this.onStart = ev => {
            this.reset(), this.startTime = util_1.clock.now();
            const {cachedEvents: cachedEvents, startPoints: startPoints} = this;
            ev && cachedEvents.push(ev.clone()), startPoints.length = cachedEvents.length;
            for (let i = 0; i < cachedEvents.length; i++) {
                const {x: x, y: y} = cachedEvents[i], point = {
                    x: x,
                    y: y
                };
                startPoints[i] = point;
            }
            if (1 !== startPoints.length) this.startDistance = calcDistance(startPoints[0], startPoints[1]), 
            this.center = getCenter([ startPoints[0], startPoints[1] ]); else {
                const event = cachedEvents[0];
                this.pressTimeout = setTimeout((() => {
                    event.direction = "none", event.deltaX = 0, event.deltaY = 0, event.points = startPoints, 
                    this.triggerStartEvent("press", event), this.triggerEvent("press", event), this.eventType = "press", 
                    this.direction = "none";
                }), this.config.press.time);
            }
        }, this.onMove = ev => {
            this.clearPressTimeout();
            const {startPoints: startPoints, cachedEvents: cachedEvents} = this;
            if (!startPoints.length) return;
            const moveEvent = ev.clone(), {x: x, y: y, pointerId: pointerId} = moveEvent;
            for (let i = 0, len = cachedEvents.length; i < len; i++) if (pointerId === cachedEvents[i].pointerId) {
                cachedEvents[i] = moveEvent;
                break;
            }
            const point = {
                x: x,
                y: y
            }, points = cachedEvents.map((cachedEvent => ({
                x: cachedEvent.x,
                y: cachedEvent.y
            }))), now = util_1.clock.now();
            if (this.prevMoveTime = this.lastMoveTime, this.prevMovePoint = this.lastMovePoint, 
            this.lastMoveTime = now, this.lastMovePoint = point, 1 === startPoints.length) {
                const startPoint = startPoints[0], deltaX = x - startPoint.x, deltaY = y - startPoint.y, direction = this.direction || calcDirection(startPoint, point);
                this.direction = direction;
                const eventType = this.getEventType(point);
                return moveEvent.direction = direction, moveEvent.deltaX = deltaX, moveEvent.deltaY = deltaY, 
                moveEvent.points = points, this.triggerStartEvent(eventType, moveEvent), void this.triggerEvent(eventType, moveEvent);
            }
            const {startDistance: startDistance} = this, currentDistance = calcDistance(points[0], points[1]);
            moveEvent.scale = currentDistance / startDistance, moveEvent.center = this.center, 
            moveEvent.points = points, this.triggerStartEvent("pinch", moveEvent), this.triggerEvent("pinch", moveEvent);
        }, this.onEnd = ev => {
            const endEvent = ev.clone(), {cachedEvents: cachedEvents, startPoints: startPoints} = this, points = cachedEvents.map((ev => ({
                x: ev.x,
                y: ev.y
            })));
            if (endEvent.points = points, this.triggerEndEvent(endEvent), 1 === cachedEvents.length) {
                const now = util_1.clock.now(), lastMoveTime = this.lastMoveTime;
                if (now - lastMoveTime < 100) {
                    const intervalTime = lastMoveTime - (this.prevMoveTime || this.startTime);
                    if (intervalTime > 0) {
                        const prevMovePoint = this.prevMovePoint || startPoints[0], lastMovePoint = this.lastMovePoint || startPoints[0], distance = calcDistance(prevMovePoint, lastMovePoint), velocity = distance / intervalTime;
                        velocity > this.config.swipe.velocity && distance > this.config.swipe.threshold && (endEvent.velocity = velocity, 
                        endEvent.direction = calcDirection(prevMovePoint, lastMovePoint), this.triggerEvent("swipe", endEvent));
                    }
                }
            }
            for (let i = 0, len = cachedEvents.length; i < len; i++) if (cachedEvents[i].pointerId === endEvent.pointerId) {
                cachedEvents.splice(i, 1), startPoints.splice(i, 1);
                break;
            }
            this.reset(), cachedEvents.length > 0 && this.onStart();
        }, this.element = element, this.config = {
            press: {
                time: null !== (_b = null === (_a = null == config ? void 0 : config.press) || void 0 === _a ? void 0 : _a.time) && void 0 !== _b ? _b : 251,
                threshold: null !== (_d = null === (_c = null == config ? void 0 : config.press) || void 0 === _c ? void 0 : _c.threshold) && void 0 !== _d ? _d : 9
            },
            swipe: {
                threshold: null !== (_f = null === (_e = null == config ? void 0 : config.swipe) || void 0 === _e ? void 0 : _e.threshold) && void 0 !== _f ? _f : 10,
                velocity: null !== (_h = null === (_g = null == config ? void 0 : config.swipe) || void 0 === _g ? void 0 : _g.velocity) && void 0 !== _h ? _h : .3
            }
        }, this.initEvents();
    }
    initEvents() {
        const {element: element} = this;
        element && (element.addEventListener("pointerdown", this.onStart), element.addEventListener("pointermove", this.onMove), 
        element.addEventListener("pointerup", this.onEnd), element.addEventListener("pointerupoutside", this.onEnd));
    }
    removeEvents() {
        const {element: element} = this;
        element && (element.removeEventListener("pointerdown", this.onStart), element.removeEventListener("pointermove", this.onMove), 
        element.removeEventListener("pointerup", this.onEnd), element.removeEventListener("pointerupoutside", this.onEnd));
    }
    release() {
        this.removeEvents(), this.element = null;
    }
    getEventType(point) {
        const {eventType: eventType, startTime: startTime, startPoints: startPoints} = this;
        if (eventType) return eventType;
        let type;
        return type = util_1.clock.now() - startTime > this.config.press.time && calcDistance(startPoints[0], point) < this.config.press.threshold ? "press" : "pan", 
        this.eventType = type, type;
    }
    enable(eventType) {
        this.processEvent[eventType] = !0;
    }
    isProcess(eventType) {
        return this.processEvent[eventType];
    }
    pushEvent(type, ev) {
        const {emitThrottles: emitThrottles} = this, newEvent = {
            type: type,
            ev: ev
        };
        for (let i = 0, len = emitThrottles.length; i < len; i++) if (emitThrottles[i].type === type) return void emitThrottles.splice(i, 1, newEvent);
        emitThrottles.push(newEvent);
    }
    clearPressTimeout() {
        this.pressTimeout && (clearTimeout(this.pressTimeout), this.pressTimeout = null);
    }
    reset() {
        this.clearPressTimeout(), this.startTime = 0, this.startDistance = 0, this.direction = null, 
        this.eventType = null, this.prevMoveTime = 0, this.prevMovePoint = null, this.lastMoveTime = 0, 
        this.lastMovePoint = null;
    }
    triggerEvent(type, ev) {
        this.pushEvent(type, ev);
        const {throttleTimer: throttleTimer, emitThrottles: emitThrottles} = this;
        throttleTimer || (this.throttleTimer = application_1.application.global.getRequestAnimationFrame()((() => {
            for (let i = 0, len = emitThrottles.length; i < len; i++) {
                const {type: type, ev: ev} = emitThrottles[i];
                this.emitEvent(type, ev);
            }
            this.throttleTimer = 0, this.emitThrottles.length = 0;
        })));
    }
    triggerStartEvent(type, ev) {
        this.isProcess(type) || (this.enable(type), this.triggerEvent(`${type}start`, ev));
    }
    triggerEndEvent(ev) {
        const processEvent = this.processEvent;
        Object.keys(processEvent).forEach((type => {
            this.triggerEvent(`${type}end`, ev), "press" === type && this.triggerEvent(`${type}up`, ev), 
            delete processEvent[type];
        }));
    }
    emitEvent(type, e) {
        const listeners = this.element._events[constant_1.WILDCARD];
        if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type); else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
        this.emit(type, e);
    }
}

exports.Gesture = Gesture;
//# sourceMappingURL=gesture.js.map

}, function(modId) { var map = {"../util":1689069767721,"../constant":1689069767720,"../../application":1689069767703}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767727, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=event.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767728, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./Ticker"), exports), __exportStar(require("./animate"), exports), 
__exportStar(require("./config"), exports), __exportStar(require("./custom-animate"), exports), 
__exportStar(require("./morphing"), exports), __exportStar(require("./timeline"), exports);
//# sourceMappingURL=index.js.map
}, function(modId) { var map = {"./Ticker":1689069767729,"./animate":1689069767731,"./config":1689069767734,"./custom-animate":1689069767735,"./morphing":1689069767737,"./timeline":1689069767733}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767729, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./default-ticker"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./default-ticker":1689069767730}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767730, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ManualTicker = exports.DefaultTicker = exports.RAFTickHandler = exports.TimeOutTickHandler = exports.ManualTickHandler = void 0;

const application_1 = require("../../application");

class ManualTickHandler {
    constructor() {
        this.time = 0;
    }
    static Avaliable() {
        return !0;
    }
    avaliable() {
        return ManualTickHandler.Avaliable();
    }
    tick(interval, cb) {
        this.time = Math.max(0, interval + this.time), cb(this, {
            once: !0
        });
    }
    tickTo(t, cb) {
        this.time = Math.max(0, t), cb(this, {
            once: !0
        });
    }
    release() {
        this.timerId > 0 && (this.timerId = -1);
    }
    getTime() {
        return this.time;
    }
}

exports.ManualTickHandler = ManualTickHandler;

class TimeOutTickHandler {
    static Avaliable() {
        return !0;
    }
    avaliable() {
        return TimeOutTickHandler.Avaliable();
    }
    tick(interval, cb) {
        this.timerId = setTimeout((() => {
            cb(this);
        }), interval);
    }
    release() {
        this.timerId > 0 && (clearTimeout(this.timerId), this.timerId = -1);
    }
    getTime() {
        return Date.now();
    }
}

exports.TimeOutTickHandler = TimeOutTickHandler;

class RAFTickHandler {
    static Avaliable() {
        return !!application_1.application.global.getRequestAnimationFrame();
    }
    avaliable() {
        return RAFTickHandler.Avaliable();
    }
    tick(interval, cb) {
        application_1.application.global.getRequestAnimationFrame()((() => {
            this.released || cb(this);
        }));
    }
    release() {
        this.released = !0;
    }
    getTime() {
        return Date.now();
    }
}

var STATUS;

exports.RAFTickHandler = RAFTickHandler, function(STATUS) {
    STATUS[STATUS.INITIAL = 0] = "INITIAL", STATUS[STATUS.RUNNING = 1] = "RUNNING", 
    STATUS[STATUS.PAUSE = 2] = "PAUSE";
}(STATUS || (STATUS = {}));

class DefaultTicker {
    set mode(m) {
        this._mode !== m && (this._mode = m, this.setupTickHandler());
    }
    get mode() {
        return this._mode;
    }
    constructor(timelines = []) {
        this.handleTick = (handler, params) => {
            const {once: once = !1} = null != params ? params : {};
            this.ifCanStop() ? this.stop() : (this._handlerTick(handler), once || handler.tick(this.interval, this.handleTick));
        }, this._handlerTick = handler => {
            const time = this.tickerHandler.getTime();
            let delta = 0;
            this.lastFrameTime >= 0 && (delta = time - this.lastFrameTime), this.lastFrameTime = time, 
            this.status === STATUS.RUNNING && (this.tickCounts++, this.timelines.forEach((t => {
                t.tick(delta);
            })));
        }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.timelines = timelines, 
        this.autoStop = !0;
    }
    init() {
        this.interval = NaN, this.status = STATUS.INITIAL, application_1.application.global.hooks.onSetEnv.tap("window", (() => {
            this.initHandler();
        })), application_1.application.global.env && this.initHandler();
    }
    addTimeline(timeline) {
        this.timelines.push(timeline);
    }
    remTimeline(timeline) {
        this.timelines = this.timelines.filter((t => t !== timeline));
    }
    initHandler() {
        if (this._mode) return null;
        const ticks = [ {
            mode: "raf",
            cons: RAFTickHandler
        }, {
            mode: "timeout",
            cons: TimeOutTickHandler
        }, {
            mode: "manual",
            cons: ManualTickHandler
        } ];
        for (let i = 0; i < ticks.length; i++) if (ticks[i].cons.Avaliable()) {
            this.mode = ticks[i].mode;
            break;
        }
        return null;
    }
    setupTickHandler() {
        let handler;
        switch (this._mode) {
          case "raf":
            handler = new RAFTickHandler;
            break;

          case "timeout":
            handler = new TimeOutTickHandler;
            break;

          case "manual":
            handler = new ManualTickHandler;
            break;

          default:
            console.warn("非法的计时器模式"), handler = new RAFTickHandler;
        }
        return !!handler.avaliable() && (this.tickerHandler && this.tickerHandler.release(), 
        this.tickerHandler = handler, !0);
    }
    setInterval(interval) {
        this.interval = interval;
    }
    getInterval() {
        return this.interval;
    }
    setFPS(fps) {
        this.setInterval(1e3 / fps);
    }
    getFPS() {
        return 1e3 / this.interval;
    }
    tick(interval) {
        this.tickerHandler.tick(interval, (handler => {
            this.handleTick(handler, {
                once: !0
            });
        }));
    }
    tickTo(t) {
        this.tickerHandler.tickTo && this.tickerHandler.tickTo(t, (handler => {
            this.handleTick(handler, {
                once: !0
            });
        }));
    }
    pause() {
        return this.status !== STATUS.INITIAL && (this.status = STATUS.PAUSE, !0);
    }
    resume() {
        return this.status !== STATUS.INITIAL && (this.status = STATUS.RUNNING, !0);
    }
    ifCanStop() {
        if (this.autoStop) {
            if (!this.timelines.length) return !0;
            if (0 === this.timelines.reduce(((a, b) => a + b.animateCount), 0)) return !0;
        }
        return !1;
    }
    start(force = !1) {
        if (this.status === STATUS.RUNNING) return !1;
        if (!this.tickerHandler) return !1;
        if (!force) {
            if (this.status === STATUS.PAUSE) return !1;
            if (!this.timelines.length) return !1;
            if (0 === this.timelines.reduce(((a, b) => a + b.animateCount), 0)) return !1;
        }
        return this.status = STATUS.RUNNING, this.tickerHandler.tick(0, this.handleTick), 
        !0;
    }
    stop() {
        this.status = STATUS.INITIAL, this.setupTickHandler(), this.lastFrameTime = -1;
    }
}

exports.DefaultTicker = DefaultTicker;

class ManualTicker extends DefaultTicker {
    set mode(m) {
        this.setupTickHandler();
    }
    get mode() {
        return this._mode;
    }
    initHandler() {
        return this.mode = "manual", null;
    }
    setupTickHandler() {
        const handler = new ManualTickHandler;
        return this._mode = "manual", this.tickerHandler && this.tickerHandler.release(), 
        this.tickerHandler = handler, !0;
    }
    tickAt(time) {
        this.tickerHandler.tick(time - this.lastFrameTime, (handler => {
            this.handleTick(handler, {
                once: !0
            });
        }));
    }
    ifCanStop() {
        return !1;
    }
}

exports.ManualTicker = ManualTicker;
//# sourceMappingURL=default-ticker.js.map

}, function(modId) { var map = {"../../application":1689069767703}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767731, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.SubAnimate = exports.Animate = exports.CbAnimate = exports.ACustomAnimate = void 0;

const enums_1 = require("../common/enums"), easing_1 = require("./easing"), vutils_1 = require("@visactor/vutils"), timeline_1 = require("./timeline"), generator_1 = require("../common/generator");

class ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        this.from = from, this.to = to, this.duration = duration, this.easing = easing, 
        this.params = params, this.updateCount = 0;
    }
    bind(target, subAni) {
        this.target = target, this.subAnimate = subAni, this.onBind();
    }
    onBind() {}
    onFirstRun() {}
    onStart() {}
    onEnd() {}
    getEndProps() {}
    getFromProps() {
        return this.from;
    }
    getMergedEndProps() {
        var _a;
        const thisEndProps = this.getEndProps();
        return thisEndProps ? this._endProps === thisEndProps ? this._mergedEndProps : (this._endProps = thisEndProps, 
        void (this._mergedEndProps = Object.assign({}, null !== (_a = this.step.prev.getLastProps()) && void 0 !== _a ? _a : {}, thisEndProps))) : this.step.prev ? this.step.prev.getLastProps() : thisEndProps;
    }
    update(end, ratio, out) {
        0 === this.updateCount && this.onFirstRun(), this.updateCount += 1, Object.assign(out, this.step.getLastProps()), 
        this.onUpdate(end, ratio, out), end && this.onEnd();
    }
}

exports.ACustomAnimate = ACustomAnimate;

class CbAnimate extends ACustomAnimate {
    constructor(cb) {
        super(null, null, 0, "linear"), this.cb = cb;
    }
    onUpdate(end, ratio, out) {}
    onStart() {
        this.cb();
    }
}

exports.CbAnimate = CbAnimate;

class Animate {
    constructor(id = generator_1.Generator.GenAutoIncrementId(), timeline = timeline_1.defaultTimeline) {
        this.id = id, this.timeline = timeline, this.status = enums_1.AnimateStatus.INITIAL, 
        this.tailAnimate = new SubAnimate(this), this.subAnimates = [ this.tailAnimate ], 
        this.timeScale = 1, this.rawPosition = -1, this._startTime = 0, this._duringTime = 0, 
        this.timeline.addAnimate(this);
    }
    getStartTime() {
        return this._startTime;
    }
    getDuration() {
        return this.subAnimates.reduce(((t, subAnimate) => t + subAnimate.totalDuration), 0);
    }
    after(animate) {
        const t = animate.getDuration();
        return this._startTime = t, this;
    }
    afterAll(list) {
        let maxT = -1 / 0;
        return list.forEach((a => {
            maxT = (0, vutils_1.max)(a.getDuration(), maxT);
        })), this._startTime = maxT, this;
    }
    parallel(animate) {
        return this._startTime = animate.getStartTime(), this;
    }
    static AddInterpolate(name, cb) {
        Animate.interpolateMap.set(name, cb);
    }
    play(customAnimate) {
        if (this.tailAnimate.play(customAnimate), this.target) {
            const stage = this.target.stage;
            stage && stage.renderNextFrame();
        }
        return 1 === this.subAnimates.length && this.tailAnimate.duration === customAnimate.duration && this.trySetAttribute(customAnimate.getFromProps(), customAnimate.mode), 
        this;
    }
    trySetAttribute(attr, mode = Animate.mode) {
        attr && mode & enums_1.AnimateMode.SET_ATTR_IMMEDIATELY && this.target.setAttributes && this.target.setAttributes(attr, !1, {
            type: enums_1.AttributeUpdateType.ANIMATE_PLAY
        });
    }
    runCb(cb) {
        const customAnimate = new CbAnimate((() => {
            cb(this, customAnimate.step.prev);
        }));
        return this.tailAnimate.play(customAnimate), this;
    }
    customInterpolate(key, ratio, from, to, target, ret) {
        const func = Animate.interpolateMap.get(key) || Animate.interpolateMap.get("");
        return !!func && func(key, ratio, from, to, target, ret);
    }
    pause() {
        this.status === enums_1.AnimateStatus.RUNNING && (this.status = enums_1.AnimateStatus.PAUSED);
    }
    resume() {
        this.status === enums_1.AnimateStatus.PAUSED && (this.status = enums_1.AnimateStatus.RUNNING);
    }
    to(props, duration, easing, params) {
        if (this.tailAnimate.to(props, duration, easing, params), this.target) {
            const stage = this.target.stage;
            stage && stage.renderNextFrame();
        }
        return this;
    }
    from(props, duration, easing, params) {
        if (this.tailAnimate.from(props, duration, easing, params), this.target) {
            const stage = this.target.stage;
            stage && stage.renderNextFrame();
        }
        return this;
    }
    wait(duration) {
        if (this.tailAnimate.wait(duration), this.target) {
            const stage = this.target.stage;
            stage && stage.renderNextFrame();
        }
        return this;
    }
    startAt(t) {
        if (this.tailAnimate.startAt(t), this.target) {
            const stage = this.target.stage;
            stage && stage.renderNextFrame();
        }
        return this;
    }
    loop(l) {
        if (this.tailAnimate.loop = l, this.target) {
            const stage = this.target.stage;
            stage && stage.renderNextFrame();
        }
        return this;
    }
    reversed(r) {
        if (this.tailAnimate.reversed = r, this.target) {
            const stage = this.target.stage;
            stage && stage.renderNextFrame();
        }
        return this;
    }
    bounce(b) {
        if (this.tailAnimate.bounce = b, this.target) {
            const stage = this.target.stage;
            stage && stage.renderNextFrame();
        }
        return this;
    }
    subAnimate() {
        const sa = new SubAnimate(this, this.tailAnimate);
        return this.tailAnimate = sa, this.subAnimates.push(sa), sa.bind(this.target), this;
    }
    getStartProps() {
        return this.subAnimates[0].getStartProps();
    }
    getEndProps() {
        return this.tailAnimate.getEndProps();
    }
    depreventAttr(key) {
        this._preventAttrs && this._preventAttrs.delete(key);
    }
    preventAttr(key) {
        this._preventAttrs || (this._preventAttrs = new Set), this._preventAttrs.add(key);
    }
    preventAttrs(keys) {
        keys.forEach((key => this.preventAttr(key)));
    }
    validAttr(key) {
        return !this._preventAttrs || !this._preventAttrs.has(key);
    }
    bind(target) {
        return this.target = target, this.target.onAnimateBind && this.target.onAnimateBind(this), 
        this.subAnimates.forEach((sa => {
            sa.bind(target);
        })), this;
    }
    advance(delta) {
        if (this._duringTime < this._startTime) {
            if (this._duringTime + delta * this.timeScale < this._startTime) return void (this._duringTime += delta * this.timeScale);
            delta = this._duringTime + delta * this.timeScale - this._startTime, this._duringTime = this._startTime;
        }
        this.status === enums_1.AnimateStatus.INITIAL && (this.status = enums_1.AnimateStatus.RUNNING, 
        this._onStart && this._onStart.forEach((cb => cb())));
        this.setPosition(this.rawPosition + delta * this.timeScale) && this.status === enums_1.AnimateStatus.RUNNING && (this.status = enums_1.AnimateStatus.END, 
        this._onEnd && this._onEnd.forEach((cb => cb())));
    }
    setPosition(rawPosition) {
        let sa, d = 0;
        const prevRawPos = this.rawPosition, maxRawPos = this.subAnimates.reduce(((a, b) => a + b.totalDuration), 0);
        rawPosition < 0 && (rawPosition = 0);
        const end = rawPosition >= maxRawPos;
        if (end && (rawPosition = maxRawPos), rawPosition === prevRawPos) return end;
        for (let i = 0; i < this.subAnimates.length && (sa = this.subAnimates[i], !(d + sa.totalDuration >= rawPosition)); i++) d += sa.totalDuration, 
        sa = void 0;
        return this.rawPosition = rawPosition, sa.setPosition(rawPosition - d), end;
    }
    onStart(cb) {
        this._onStart || (this._onStart = []), this._onStart.push(cb);
    }
    onEnd(cb) {
        this._onEnd || (this._onEnd = []), this._onEnd.push(cb);
    }
    onRemove(cb) {
        this._onRemove || (this._onRemove = []), this._onRemove.push(cb);
    }
    onFrame(cb) {
        this._onFrame || (this._onFrame = []), this._onFrame.push(cb);
    }
    release() {
        this.status = enums_1.AnimateStatus.END;
    }
    stop(nextVal) {
        nextVal || this.target.onStop(), "start" === nextVal ? this.target.onStop(this.getStartProps()) : "end" === nextVal ? this.target.onStop(this.getEndProps()) : this.target.onStop(nextVal), 
        this.release();
    }
}

exports.Animate = Animate, Animate.mode = enums_1.AnimateMode.NORMAL, Animate.interpolateMap = new Map;

class SubAnimate {
    get totalDuration() {
        return this.calcAttr(), this._totalDuration + this._startAt;
    }
    constructor(animate, lastSubAnimate) {
        this.rawPosition = -1, this.position = 0, this.loop = 0, this.duration = 0, this.animate = animate, 
        this.stepHead = new Step(0, 0, lastSubAnimate ? Object.assign({}, lastSubAnimate.stepTail.props) : {}), 
        this.stepTail = this.stepHead, this.dirty = !0, this._startAt = 0;
    }
    calcAttr() {
        this.dirty && (this._totalDuration = this.duration * (this.loop + 1));
    }
    bind(target) {
        return this.target = target, this;
    }
    play(customAnimate) {
        let duration = customAnimate.duration;
        (null == duration || duration < 0) && (duration = 0);
        const easing = customAnimate.easing, easingFunc = "string" == typeof easing ? easing_1.Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);
        return step.type = enums_1.AnimateStepType.customAnimate, this._appendProps(customAnimate.getEndProps(), step, !1), 
        this._appendCustomAnimate(customAnimate, step), this;
    }
    to(props, duration, easing, params) {
        (null == duration || duration < 0) && (duration = 0);
        const easingFunc = "string" == typeof easing ? easing_1.Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);
        return step.type = enums_1.AnimateStepType.to, this._appendProps(props, step, !!params && params.tempProps), 
        step.propKeys || (step.propKeys = Object.keys(step.props)), params && params.noPreventAttrs || this.target.animates.forEach((a => {
            a.id !== this.animate.id && a.preventAttrs(step.propKeys);
        })), this;
    }
    from(props, duration, easing, params) {
        this.to(props, 0, easing, params);
        const toProps = {};
        this.stepTail.propKeys || (this.stepTail.propKeys = Object.keys(this.stepTail.props)), 
        this.stepTail.propKeys.forEach((k => {
            toProps[k] = this.getLastPropByName(k, this.stepTail);
        })), this.to(toProps, duration, easing, params), this.stepTail.type = enums_1.AnimateStepType.from;
    }
    startAt(t) {
        return t < 0 && (t = 0), this._startAt = t, this;
    }
    getStartProps() {
        var _a;
        return null === (_a = this.stepHead) || void 0 === _a ? void 0 : _a.props;
    }
    getEndProps() {
        return this.stepTail.props;
    }
    getLastStep() {
        return this._lastStep;
    }
    wait(duration) {
        if (duration > 0) {
            const step = this._addStep(+duration, null);
            step.type = enums_1.AnimateStepType.wait, step.prev.customAnimate ? step.props = step.prev.customAnimate.getEndProps() : step.props = step.prev.props, 
            this.target.onAddStep && this.target.onAddStep(step);
        }
        return this;
    }
    _addStep(duration, props, easingFunc) {
        const step = new Step(this.duration, duration, props, easingFunc);
        return this.duration += duration, this.stepTail.append(step), this.stepTail = step, 
        step;
    }
    _appendProps(props, step, tempProps) {
        step.props = tempProps ? props : Object.assign({}, props);
        let lastStep = step.prev;
        const _props = step.props;
        for (step.propKeys || (step.propKeys = Object.keys(step.props)), step.propKeys.forEach((k => {
            void 0 === step.props[k] && (step.props[k] = this.target.getDefaultAttribute(k));
        })); lastStep.prev; ) lastStep.props && (lastStep.propKeys || (lastStep.propKeys = Object.keys(lastStep.props)), 
        lastStep.propKeys.forEach((key => {
            void 0 === _props[key] && (_props[key] = lastStep.props[key]);
        }))), lastStep = lastStep.prev;
        const initProps = this.stepHead.props;
        step.propKeys || (step.propKeys = Object.keys(_props)), step.propKeys.forEach((key => {
            if (void 0 === initProps[key]) {
                const parentAnimateInitProps = this.animate.getStartProps();
                initProps[key] = parentAnimateInitProps[key] = this.target.getComputedAttribute(key);
            }
        })), this.target.onAddStep && this.target.onAddStep(step);
    }
    _appendCustomAnimate(customAnimate, step) {
        step.customAnimate = customAnimate, customAnimate.step = step, customAnimate.bind(this.target, this);
    }
    setPosition(rawPosition) {
        var _a;
        const d = this.duration, loopCount = this.loop, prevRawPos = this.rawPosition;
        let loop, position, end = !1;
        const startAt = null !== (_a = this._startAt) && void 0 !== _a ? _a : 0;
        if (rawPosition < 0 && (rawPosition = 0), rawPosition < startAt) return this.rawPosition = rawPosition, 
        !1;
        if (rawPosition -= startAt, d <= 0) return end = !0, end;
        if (loop = Math.floor(rawPosition / d), position = rawPosition - loop * d, end = rawPosition >= loopCount * d + d, 
        end && (position = d, loop = loopCount, rawPosition = position * loop + d), rawPosition === prevRawPos) return end;
        const rev = !this.reversed != !(this.bounce && loop % 2);
        return rev && (position = d - position), this._deltaPosition = position - this.position, 
        this.position = position, this.rawPosition = rawPosition + startAt, this.updatePosition(end, rev), 
        end;
    }
    updatePosition(end, rev) {
        if (!this.stepHead) return;
        let step = this.stepHead.next;
        const position = this.position, duration = this.duration;
        if (this.target && step) {
            let stepNext = step.next;
            for (;stepNext && stepNext.position <= position; ) step = stepNext, stepNext = step.next;
            let ratio = end ? 0 === duration ? 1 : position / duration : (position - step.position) / step.duration;
            step.easing && (ratio = step.easing(ratio)), this.tryCallCustomAnimateLifeCycle(step, this._lastStep || (rev ? this.stepTail : this.stepHead), rev), 
            this.updateTarget(step, ratio, end), this._lastStep = step, this.animate._onFrame && this.animate._onFrame.forEach((cb => cb(step, ratio)));
        }
    }
    tryCallCustomAnimateLifeCycle(step, lastStep, rev) {
        if (step !== lastStep) if (rev) {
            let _step = lastStep.prev;
            for (;_step && _step !== step; ) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), 
            _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = step.prev;
            lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), 
            step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
        } else {
            let _step = lastStep.next;
            for (;_step && _step !== step; ) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), 
            _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = _step.next;
            lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), 
            step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
        }
    }
    getLastPropByName(name, step) {
        let lastStep = step.prev;
        for (;lastStep; ) {
            if (lastStep.props && void 0 !== lastStep.props[name]) return lastStep.props[name];
            if (lastStep.customAnimate) {
                const val = lastStep.customAnimate.getEndProps()[name];
                if (void 0 !== val) return val;
            }
            lastStep = lastStep.prev;
        }
        return console.warn("未知错误，step中找不到属性"), step.props[name];
    }
    updateTarget(step, ratio, end) {
        null == step.props && null == step.customAnimate || this.target.onStep(this, this.animate, step, ratio, end);
    }
}

exports.SubAnimate = SubAnimate;

class Step {
    constructor(position, duration, props, easing) {
        this.duration = duration, this.position = position, this.props = props, this.easing = easing;
    }
    append(step) {
        step.prev = this, step.next = this.next, this.next = step;
    }
    getLastProps() {
        let step = this.prev;
        for (;step; ) {
            if (step.props) return step.props;
            if (step.customAnimate) return step.customAnimate.getMergedEndProps();
            step = step.prev;
        }
        return null;
    }
}
//# sourceMappingURL=animate.js.map
}, function(modId) { var map = {"../common/enums":1689069767685,"./easing":1689069767732,"./timeline":1689069767733,"../common/generator":1689069767711}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767732, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Easing = void 0;

const vutils_1 = require("@visactor/vutils");

class Easing {
    constructor() {}
    static linear(t) {
        return t;
    }
    static none() {
        return this.linear;
    }
    static get(amount) {
        return amount < -1 ? amount = -1 : amount > 1 && (amount = 1), function(t) {
            return 0 === amount ? t : amount < 0 ? t * (t * -amount + 1 + amount) : t * ((2 - t) * amount + (1 - amount));
        };
    }
    static getPowIn(pow) {
        return function(t) {
            return Math.pow(t, pow);
        };
    }
    static getPowOut(pow) {
        return function(t) {
            return 1 - Math.pow(1 - t, pow);
        };
    }
    static getPowInOut(pow) {
        return function(t) {
            return (t *= 2) < 1 ? .5 * Math.pow(t, pow) : 1 - .5 * Math.abs(Math.pow(2 - t, pow));
        };
    }
    static getBackIn(amount) {
        return function(t) {
            return t * t * ((amount + 1) * t - amount);
        };
    }
    static getBackOut(amount) {
        return function(t) {
            return --t * t * ((amount + 1) * t + amount) + 1;
        };
    }
    static getBackInOut(amount) {
        return amount *= 1.525, function(t) {
            return (t *= 2) < 1 ? t * t * ((amount + 1) * t - amount) * .5 : .5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
        };
    }
    static sineIn(t) {
        return 1 - Math.cos(t * Math.PI / 2);
    }
    static sineOut(t) {
        return Math.sin(t * Math.PI / 2);
    }
    static sineInOut(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
    }
    static expoIn(t) {
        return 0 === t ? 0 : Math.pow(2, 10 * t - 10);
    }
    static expoOut(t) {
        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
    }
    static expoInOut(t) {
        return 0 === t ? 0 : 1 === t ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
    }
    static circIn(t) {
        return -(Math.sqrt(1 - t * t) - 1);
    }
    static circOut(t) {
        return Math.sqrt(1 - --t * t);
    }
    static circInOut(t) {
        return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    }
    static bounceOut(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }
    static bounceIn(t) {
        return 1 - Easing.bounceOut(1 - t);
    }
    static bounceInOut(t) {
        return t < .5 ? .5 * Easing.bounceIn(2 * t) : .5 * Easing.bounceOut(2 * t - 1) + .5;
    }
    static getElasticIn(amplitude, period) {
        return function(t) {
            if (0 === t || 1 === t) return t;
            const s = period / vutils_1.pi2 * Math.asin(1 / amplitude);
            return -amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * vutils_1.pi2 / period);
        };
    }
    static getElasticOut(amplitude, period) {
        return function(t) {
            if (0 === t || 1 === t) return t;
            const s = period / vutils_1.pi2 * Math.asin(1 / amplitude);
            return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * vutils_1.pi2 / period) + 1;
        };
    }
    static getElasticInOut(amplitude, period) {
        return function(t) {
            const s = period / vutils_1.pi2 * Math.asin(1 / amplitude);
            return (t *= 2) < 1 ? amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * vutils_1.pi2 / period) * -.5 : amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * vutils_1.pi2 / period) * .5 + 1;
        };
    }
}

exports.Easing = Easing, Easing.quadIn = Easing.getPowIn(2), Easing.quadOut = Easing.getPowOut(2), 
Easing.quadInOut = Easing.getPowInOut(2), Easing.cubicIn = Easing.getPowIn(3), Easing.cubicOut = Easing.getPowOut(3), 
Easing.cubicInOut = Easing.getPowInOut(3), Easing.quartIn = Easing.getPowIn(4), 
Easing.quartOut = Easing.getPowOut(4), Easing.quartInOut = Easing.getPowInOut(4), 
Easing.quintIn = Easing.getPowIn(5), Easing.quintOut = Easing.getPowOut(5), Easing.quintInOut = Easing.getPowInOut(5), 
Easing.backIn = Easing.getBackIn(1.7), Easing.backOut = Easing.getBackOut(1.7), 
Easing.backInOut = Easing.getBackInOut(1.7), Easing.elasticIn = Easing.getElasticIn(1, .3), 
Easing.elasticOut = Easing.getElasticOut(1, .3), Easing.elasticInOut = Easing.getElasticInOut(1, .3 * 1.5);
//# sourceMappingURL=easing.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767733, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.defaultTimeline = exports.DefaultTimeline = void 0;

const enums_1 = require("../common/enums"), generator_1 = require("../common/generator");

class DefaultTimeline {
    constructor() {
        this.id = generator_1.Generator.GenAutoIncrementId(), this.animateHead = null, this.animateTail = null, 
        this.animateCount = 0, this.paused = !1;
    }
    addAnimate(animate) {
        this.animateTail ? (this.animateTail.nextAnimate = animate, animate.prevAnimate = this.animateTail, 
        this.animateTail = animate, animate.nextAnimate = null) : (this.animateHead = animate, 
        this.animateTail = animate), this.animateCount++;
    }
    pause() {
        this.paused = !0;
    }
    resume() {
        this.paused = !1;
    }
    tick(delta) {
        if (this.paused) return;
        let animate = this.animateHead;
        for (this.animateCount = 0; animate; ) animate.status === enums_1.AnimateStatus.END ? this.removeAnimate(animate) : animate.status === enums_1.AnimateStatus.RUNNING || animate.status === enums_1.AnimateStatus.INITIAL ? (this.animateCount++, 
        animate.advance(delta)) : animate.status === enums_1.AnimateStatus.PAUSED && this.animateCount++, 
        animate = animate.nextAnimate;
    }
    clear() {
        let animate = this.animateHead;
        for (;animate; ) animate.release(), animate = animate.nextAnimate;
        this.animateHead = null, this.animateTail = null, this.animateCount = 0;
    }
    removeAnimate(animate) {
        animate._onRemove && animate._onRemove.forEach((cb => cb())), animate === this.animateHead ? (this.animateHead = animate.nextAnimate, 
        animate === this.animateTail ? this.animateTail = null : this.animateHead.prevAnimate = null) : animate === this.animateTail ? (this.animateTail = animate.prevAnimate, 
        this.animateTail.nextAnimate = null) : (animate.prevAnimate.nextAnimate = animate.nextAnimate, 
        animate.nextAnimate.prevAnimate = animate.prevAnimate), animate.release();
    }
}

exports.DefaultTimeline = DefaultTimeline, exports.defaultTimeline = new DefaultTimeline;
//# sourceMappingURL=timeline.js.map
}, function(modId) { var map = {"../common/enums":1689069767685,"../common/generator":1689069767711}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767734, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMorphingAnimateConfig = exports.DefaultStateAnimateConfig = void 0, 
exports.DefaultStateAnimateConfig = {
    duration: 200,
    easing: "cubicOut"
}, exports.DefaultMorphingAnimateConfig = {
    duration: 1e3,
    easing: "quadInOut"
};
//# sourceMappingURL=config.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767735, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.AnimateGroup1 = exports.AnimateGroup = exports.AttributeAnimate = exports.GroupFadeOut = exports.GroupFadeIn = exports.RotateBySphereAnimate = exports.ClipDirectionAnimate = exports.ClipRadiusAnimate = exports.ClipAngleAnimate = exports.ClipGraphicAnimate = exports.GraphicAnimate = exports.TagPointsUpdate = exports.MotionPath = exports.Meteor = exports.StreamLight = exports.InputText = exports.FadeInPlus = exports.IncreaseCount = void 0;

const vutils_1 = require("@visactor/vutils"), application_1 = require("../application"), enums_1 = require("../common/enums"), animate_1 = require("./animate"), easing_1 = require("./easing"), utils_1 = require("../common/utils");

class IncreaseCount extends animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    getEndProps() {
        return !1 === this.valid ? {} : {
            text: this.to
        };
    }
    onBind() {
        var _a, _b, _c, _d, _e, _f;
        this.fromNumber = (0, vutils_1.isNumber)(null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) ? null === (_b = this.from) || void 0 === _b ? void 0 : _b.text : Number.parseFloat(null === (_c = this.from) || void 0 === _c ? void 0 : _c.text), 
        this.toNumber = (0, vutils_1.isNumber)(null === (_d = this.to) || void 0 === _d ? void 0 : _d.text) ? null === (_e = this.to) || void 0 === _e ? void 0 : _e.text : Number.parseFloat(null === (_f = this.to) || void 0 === _f ? void 0 : _f.text), 
        Number.isFinite(this.toNumber) || (this.fromNumber = 0), Number.isFinite(this.toNumber) || (this.valid = !1);
    }
    onEnd() {}
    onUpdate(end, ratio, out) {
        var _a, _b;
        !1 !== this.valid && (out.text = end ? this.toNumber.toFixed() : (this.fromNumber + (this.toNumber - this.fromNumber) * ratio).toFixed(null !== (_b = null === (_a = this.params) || void 0 === _a ? void 0 : _a.fixed) && void 0 !== _b ? _b : 0));
    }
}

var Direction;

exports.IncreaseCount = IncreaseCount, function(Direction) {
    Direction[Direction.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", Direction[Direction.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT", 
    Direction[Direction.TOP_TO_BOTTOM = 2] = "TOP_TO_BOTTOM", Direction[Direction.BOTTOM_TO_TOP = 3] = "BOTTOM_TO_TOP", 
    Direction[Direction.STROKE = 4] = "STROKE";
}(Direction || (Direction = {}));

class FadeInPlus extends animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        const {direction: direction = Direction.LEFT_TO_RIGHT, fill: fill = !0, stroke: stroke = !0} = params || {};
        this.direction = direction, this.fill = fill, this.stroke = stroke, this.fillGradient = {
            gradient: "linear",
            stops: []
        }, this.strokeGradient = {
            gradient: "linear",
            stops: []
        };
    }
    getEndProps() {
        return {
            fill: this.toFill,
            stroke: this.toStroke
        };
    }
    onBind() {
        this.toFill = this.target.getComputedAttribute("fill"), this.toStroke = this.target.getComputedAttribute("stroke");
    }
    onEnd() {}
    onUpdate(end, ratio, out) {
        if (this.toFill && this.toStroke) switch (this.direction) {
          case Direction.RIGHT_TO_LEFT:
            this.rightToLeft(end, ratio, out);
            break;

          case Direction.TOP_TO_BOTTOM:
            this.topToBottom(end, ratio, out);
            break;

          case Direction.BOTTOM_TO_TOP:
            this.bottomToTop(end, ratio, out);
            break;

          case Direction.STROKE:
            this.strokePath(end, ratio, out);
            break;

          default:
            this.leftToRight(end, ratio, out);
        }
    }
    leftToRight(end, ratio, out) {
        if (this.fill) {
            const toFillColor = this.toFill;
            this.fillGradient.x0 = 0, this.fillGradient.y0 = 0, this.fillGradient.x1 = 1, this.fillGradient.y1 = 0, 
            this.fillGradient.stops = [ {
                offset: 0,
                color: toFillColor
            }, {
                offset: ratio,
                color: toFillColor
            }, {
                offset: Math.min(1, 2 * ratio),
                color: "transparent"
            } ], out.fill = this.fillGradient;
        }
        if (this.stroke) {
            const toStrokeColor = this.toStroke;
            this.strokeGradient.x0 = 0, this.strokeGradient.y0 = 0, this.strokeGradient.x1 = 1, 
            this.strokeGradient.y1 = 0, this.strokeGradient.stops = [ {
                offset: 0,
                color: toStrokeColor
            }, {
                offset: ratio,
                color: toStrokeColor
            }, {
                offset: Math.min(1, 6 * ratio),
                color: "transparent"
            } ], out.stroke = this.strokeGradient;
        }
    }
    strokePath(end, ratio, out) {
        if (this.fill) {
            const toFillColor = this.toFill;
            this.fillGradient.x0 = 0, this.fillGradient.y0 = 0, this.fillGradient.x1 = 1, this.fillGradient.y1 = 0, 
            this.fillGradient.stops = [ {
                offset: 0,
                color: toFillColor
            }, {
                offset: ratio,
                color: toFillColor
            }, {
                offset: Math.min(1, 2 * ratio),
                color: "transparent"
            } ], out.fill = this.fillGradient;
        }
        if (this.stroke) {
            const dashLen = 300, offset = ratio * dashLen;
            out.lineDash = [ offset, dashLen - offset ];
        }
    }
    rightToLeft(end, ratio, out) {}
    topToBottom(end, ratio, out) {}
    bottomToTop(end, ratio, out) {}
}

exports.FadeInPlus = FadeInPlus;

class InputText extends animate_1.ACustomAnimate {
    constructor() {
        super(...arguments), this.fromText = "", this.toText = "";
    }
    getEndProps() {
        return !1 === this.valid ? {} : {
            text: this.to
        };
    }
    onBind() {
        var _a, _b, _c, _d;
        if (this.fromText = null !== (_b = null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) && void 0 !== _b ? _b : "", 
        this.toText = null !== (_d = null === (_c = this.to) || void 0 === _c ? void 0 : _c.text) && void 0 !== _d ? _d : "", 
        !this.toText || (0, vutils_1.isArray)(this.toText)) this.valid = !1; else {
            this.toText = this.toText.toString();
            const root = this.target.attachShadow(), line = application_1.application.graphicService.creator.line({
                x: 0,
                y: 0,
                points: [ {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: this.target.getComputedAttribute("fontSize")
                } ],
                stroke: "black",
                lineWidth: 1
            });
            root.add(line);
        }
    }
    onEnd() {
        this.target.detachShadow();
    }
    onUpdate(end, ratio, out) {
        var _a;
        if (!1 === this.valid) return;
        const fromCount = this.fromText.length, toCount = this.toText.length, count = Math.ceil(fromCount + (toCount - fromCount) * ratio);
        out.text = this.toText.substr(0, count);
        const line = null === (_a = this.target.shadowRoot) || void 0 === _a ? void 0 : _a.at(0), endX = this.target.clipedWidth + 2;
        line.setAttribute("x", endX);
    }
}

exports.InputText = InputText;

class StreamLight extends animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    getEndProps() {
        return {};
    }
    onStart() {
        var _a;
        const root = this.target.attachShadow(), height = this.target.AABBBounds.height(), rect = application_1.application.graphicService.creator.rect(Object.assign(Object.assign({
            height: height,
            fill: "#bcdeff",
            shadowBlur: 30,
            shadowColor: "#bcdeff"
        }, null === (_a = this.params) || void 0 === _a ? void 0 : _a.attribute), {
            x: 0,
            y: 0,
            width: 0
        }));
        this.rect = rect, root.add(rect);
    }
    onBind() {}
    onEnd() {
        this.target.detachShadow();
    }
    onUpdate(end, ratio, out) {
        var _a, _b, _c, _d, _e, _f;
        const parentWidth = null !== (_a = this.target.attribute.width) && void 0 !== _a ? _a : 250, streamLength = null !== (_c = null === (_b = this.params) || void 0 === _b ? void 0 : _b.streamLength) && void 0 !== _c ? _c : parentWidth, maxLength = null !== (_f = null === (_e = null === (_d = this.params) || void 0 === _d ? void 0 : _d.attribute) || void 0 === _e ? void 0 : _e.width) && void 0 !== _f ? _f : 60, startX = -maxLength, currentX = startX + (streamLength - startX) * ratio, x = Math.max(currentX, 0), w = Math.min(Math.min(currentX + maxLength, maxLength), streamLength - currentX), width = w + x > parentWidth ? Math.max(parentWidth - x, 0) : w;
        this.rect.setAttributes({
            x: x,
            width: width
        }, !1, {
            type: enums_1.AttributeUpdateType.ANIMATE_PLAY,
            animationState: {
                ratio: ratio,
                end: end
            }
        });
    }
}

exports.StreamLight = StreamLight;

class Meteor extends animate_1.ACustomAnimate {
    get lastPos() {
        return this.posList[this.posList.length - 1];
    }
    constructor(size, duration, easing, params) {
        super(null, null, duration, easing, params), this.size = size, this.posList = [];
    }
    onBind() {
        const root = this.target.attachShadow();
        this.root = root;
        for (let i = 0; i < this.size; i++) {
            const g = this.target.clone(), scale = Math.min((this.size - i) / this.size * 3, 1), opacity = Math.min(.2 + .7 / this.size);
            g.setAttributes({
                x: 0,
                y: 0,
                dx: 0,
                dy: 0,
                scaleX: scale,
                scaleY: scale,
                opacity: opacity
            }, !1, {
                type: enums_1.AttributeUpdateType.ANIMATE_BIND
            }), root.add(g);
        }
    }
    onUpdate(end, ratio, out) {
        if (end) return this.target.detachShadow(), void (this.posList.length = 0);
        const x = this.target.getComputedAttribute("x"), y = this.target.getComputedAttribute("y"), nextPos = new vutils_1.Point(x, y);
        this.posList.length ? (this.target.shadowRoot.forEachChildren(((g, i) => {
            const pos = this.posList[Math.max(this.posList.length - i - 1, 0)];
            g.setAttributes({
                x: pos.x - x,
                y: pos.y - y
            }, !1);
        })), this.posList.push(nextPos)) : this.posList.push(nextPos);
    }
}

exports.Meteor = Meteor;

class MotionPath extends animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        var _a;
        super(from, to, duration, easing, params), params && (this.pathLength = params.path.getLength(), 
        this.path = params.path, this.distance = params.distance, this.to = params.distance * this.pathLength, 
        this.initAngle = null !== (_a = params.initAngle) && void 0 !== _a ? _a : 0, this.changeAngle = !!params.changeAngle, 
        this.cb = params.cb);
    }
    onUpdate(end, ratio, out) {
        const at = this.to * ratio, {pos: pos, angle: angle} = this.path.getAttrAt(at);
        out.x = pos.x, out.y = pos.y, this.changeAngle && (out.angle = angle + this.initAngle), 
        this.cb && this.cb(this.from, this.to, ratio, this.target);
    }
}

exports.MotionPath = MotionPath;

class TagPointsUpdate extends animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params), this.newPointAnimateType = "appear" === (null == params ? void 0 : params.newPointAnimateType) ? "appear" : "grow";
    }
    onBind() {
        var _a, _b;
        const originFromPoints = null === (_a = this.from) || void 0 === _a ? void 0 : _a.points, originToPoints = null === (_b = this.to) || void 0 === _b ? void 0 : _b.points;
        this.fromPoints = originFromPoints ? Array.isArray(originFromPoints) ? originFromPoints : [ originFromPoints ] : [], 
        this.toPoints = originToPoints ? Array.isArray(originToPoints) ? originToPoints : [ originToPoints ] : [];
        const tagMap = new Map;
        this.fromPoints.forEach((point => {
            point.context && tagMap.set(point.context, point);
        }));
        let firstMatchedPoint, lastMatchedPoint, firstMatchedIndex = 1 / 0, lastMatchedIndex = -1 / 0;
        for (let i = 0; i < this.toPoints.length; i += 1) if (tagMap.has(this.toPoints[i].context)) {
            firstMatchedIndex = i, firstMatchedPoint = tagMap.get(this.toPoints[i].context);
            break;
        }
        for (let i = this.toPoints.length - 1; i >= 0; i -= 1) if (tagMap.has(this.toPoints[i].context)) {
            lastMatchedIndex = i, lastMatchedPoint = tagMap.get(this.toPoints[i].context);
            break;
        }
        let prevMatchedPoint = this.toPoints[0];
        this.interpolatePoints = this.toPoints.map(((point, index) => {
            const matchedPoint = tagMap.get(point.context);
            return matchedPoint ? (prevMatchedPoint = matchedPoint, [ matchedPoint, point ]) : "appear" === this.newPointAnimateType ? [ point, point ] : index < firstMatchedIndex && firstMatchedPoint ? [ firstMatchedPoint, point ] : index > lastMatchedIndex && lastMatchedPoint ? [ lastMatchedPoint, point ] : [ prevMatchedPoint, point ];
        })), this.points = this.interpolatePoints.map((interpolate => {
            const fromPoint = interpolate[0], toPoint = interpolate[1], newPoint = new vutils_1.Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);
            return newPoint.defined = toPoint.defined, newPoint.context = toPoint.context, newPoint;
        }));
    }
    onUpdate(end, ratio, out) {
        this.points = this.points.map(((point, index) => {
            const newPoint = (0, utils_1.pointInterpolation)(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
            return newPoint.context = point.context, newPoint;
        })), out.points = this.points;
    }
}

exports.TagPointsUpdate = TagPointsUpdate;

class GraphicAnimate extends animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params), this.graphic = null == params ? void 0 : params.graphic;
    }
    onUpdate(end, ratio, out) {
        this.graphic && Object.keys(this.from).forEach((k => {
            out[k] = this.from[k] + (this.to[k] - this.from[k]) * ratio;
        }));
    }
}

exports.GraphicAnimate = GraphicAnimate;

class ClipGraphicAnimate extends animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(null, null, duration, easing, params), this.clipFromAttribute = from, this.clipToAttribute = to, 
        this._group = null == params ? void 0 : params.group, this._clipGraphic = null == params ? void 0 : params.clipGraphic;
    }
    onBind() {
        this._group && this._clipGraphic && (this._lastClip = this._group.attribute.clip, 
        this._lastPath = this._group.attribute.path, this._group.setAttributes({
            clip: !0,
            path: [ this._clipGraphic ]
        }, !1, {
            type: enums_1.AttributeUpdateType.ANIMATE_BIND
        }));
    }
    onEnd() {
        this._group && this._group.setAttributes({
            clip: this._lastClip,
            path: this._lastPath
        }, !1, {
            type: enums_1.AttributeUpdateType.ANIMATE_END
        });
    }
    onUpdate(end, ratio, out) {
        if (!this._clipGraphic) return;
        const res = {};
        Object.keys(this.clipFromAttribute).forEach((k => {
            res[k] = this.clipFromAttribute[k] + (this.clipToAttribute[k] - this.clipFromAttribute[k]) * ratio;
        })), this._clipGraphic.setAttributes(res, !1, {
            type: enums_1.AttributeUpdateType.ANIMATE_UPDATE,
            animationState: {
                ratio: ratio,
                end: end
            }
        });
    }
}

exports.ClipGraphicAnimate = ClipGraphicAnimate;

class ClipAngleAnimate extends ClipGraphicAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0, height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0, animationType = null !== (_e = null == params ? void 0 : params.animationType) && void 0 !== _e ? _e : "in", startAngle = null !== (_f = null == params ? void 0 : params.startAngle) && void 0 !== _f ? _f : 0, orient = null !== (_g = null == params ? void 0 : params.orient) && void 0 !== _g ? _g : "clockwise";
        let arcStartAngle = 0, arcEndAngle = 0;
        "anticlockwise" === orient ? (arcEndAngle = "in" === animationType ? startAngle + 2 * Math.PI : startAngle, 
        arcEndAngle = startAngle + 2 * Math.PI) : (arcStartAngle = startAngle, arcEndAngle = "out" === animationType ? startAngle + 2 * Math.PI : startAngle);
        const arc = application_1.application.graphicService.creator.arc({
            x: null !== (_j = null === (_h = null == params ? void 0 : params.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,
            y: null !== (_l = null === (_k = null == params ? void 0 : params.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,
            outerRadius: null !== (_m = null == params ? void 0 : params.radius) && void 0 !== _m ? _m : (width + height) / 2,
            innerRadius: 0,
            startAngle: arcStartAngle,
            endAngle: arcEndAngle,
            fill: !0
        });
        let fromAttributes, toAttributes;
        "anticlockwise" === orient ? (fromAttributes = {
            startAngle: startAngle + 2 * Math.PI
        }, toAttributes = {
            startAngle: startAngle
        }) : (fromAttributes = {
            endAngle: startAngle
        }, toAttributes = {
            endAngle: startAngle + 2 * Math.PI
        }), super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
            group: null == params ? void 0 : params.group,
            clipGraphic: arc
        });
    }
}

exports.ClipAngleAnimate = ClipAngleAnimate;

class ClipRadiusAnimate extends ClipGraphicAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0, height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0, animationType = null !== (_e = null == params ? void 0 : params.animationType) && void 0 !== _e ? _e : "in", startRadius = null !== (_f = null == params ? void 0 : params.startRadius) && void 0 !== _f ? _f : 0, endRadius = null !== (_g = null == params ? void 0 : params.endRadius) && void 0 !== _g ? _g : Math.sqrt((width / 2) ** 2 + (height / 2) ** 2), arc = application_1.application.graphicService.creator.arc({
            x: null !== (_j = null === (_h = null == params ? void 0 : params.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,
            y: null !== (_l = null === (_k = null == params ? void 0 : params.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,
            outerRadius: "out" === animationType ? endRadius : startRadius,
            innerRadius: 0,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            fill: !0
        }), fromAttributes = {
            outerRadius: startRadius
        }, toAttributes = {
            outerRadius: endRadius
        };
        super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
            group: null == params ? void 0 : params.group,
            clipGraphic: arc
        });
    }
}

exports.ClipRadiusAnimate = ClipRadiusAnimate;

class ClipDirectionAnimate extends ClipGraphicAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_d = null !== (_c = null == params ? void 0 : params.width) && void 0 !== _c ? _c : groupAttribute.width) && void 0 !== _d ? _d : 0, height = null !== (_f = null !== (_e = null == params ? void 0 : params.height) && void 0 !== _e ? _e : groupAttribute.height) && void 0 !== _f ? _f : 0, animationType = null !== (_g = null == params ? void 0 : params.animationType) && void 0 !== _g ? _g : "in", direction = null !== (_h = null == params ? void 0 : params.direction) && void 0 !== _h ? _h : "x", orient = null !== (_j = null == params ? void 0 : params.orient) && void 0 !== _j ? _j : "positive", rect = application_1.application.graphicService.creator.rect({
            x: 0,
            y: 0,
            width: "in" === animationType && "x" === direction ? 0 : width,
            height: "in" === animationType && "y" === direction ? 0 : height,
            fill: !0
        });
        let fromAttributes = {}, toAttributes = {};
        "y" === direction ? "negative" === orient ? (fromAttributes = {
            y: height,
            height: 0
        }, toAttributes = {
            y: 0,
            height: height
        }) : (fromAttributes = {
            height: 0
        }, toAttributes = {
            height: height
        }) : "negative" === orient ? (fromAttributes = {
            x: width,
            width: 0
        }, toAttributes = {
            x: 0,
            width: width
        }) : (fromAttributes = {
            width: 0
        }, toAttributes = {
            width: width
        }), super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
            group: null == params ? void 0 : params.group,
            clipGraphic: rect
        });
    }
}

exports.ClipDirectionAnimate = ClipDirectionAnimate;

class RotateBySphereAnimate extends animate_1.ACustomAnimate {
    onStart() {
        const {center: center, r: r} = "function" == typeof this.params ? this.params() : this.params, startX = this.target.getComputedAttribute("x"), startY = this.target.getComputedAttribute("y"), startZ = this.target.getComputedAttribute("z"), phi = Math.acos((startY - center.y) / r);
        let theta = Math.acos((startX - center.x) / r / Math.sin(phi));
        startZ - center.z < 0 && (theta = vutils_1.pi2 - theta), this.theta = theta, this.phi = phi;
    }
    onBind() {}
    onEnd() {}
    onUpdate(end, ratio, out) {
        if (null == this.phi || null == this.theta) return;
        const {center: center, r: r} = "function" == typeof this.params ? this.params() : this.params, deltaAngle = 2 * Math.PI * ratio, theta = this.theta + deltaAngle, phi = this.phi, x = r * Math.sin(phi) * Math.cos(theta) + center.x, y = r * Math.cos(phi) + center.y, z = r * Math.sin(phi) * Math.sin(theta) + center.z;
        for (out.x = x, out.y = y, out.z = z, out.alpha = theta + vutils_1.pi / 2; out.alpha > vutils_1.pi2; ) out.alpha -= vutils_1.pi2;
        out.alpha = vutils_1.pi2 - out.alpha, out.zIndex = -1e4 * out.z;
    }
}

exports.RotateBySphereAnimate = RotateBySphereAnimate;

class GroupFadeIn extends animate_1.ACustomAnimate {
    getEndProps() {
        return {};
    }
    onBind() {
        this.target.setTheme({
            common: {
                opacity: 0
            }
        });
    }
    onEnd() {
        this.target.setTheme({
            common: {
                opacity: 1
            }
        });
    }
    onUpdate(end, ratio, out) {
        this.target.setTheme({
            common: {
                opacity: ratio
            }
        });
    }
}

exports.GroupFadeIn = GroupFadeIn;

class GroupFadeOut extends animate_1.ACustomAnimate {
    getEndProps() {
        return {};
    }
    onBind() {
        this.target.setTheme({
            common: {
                opacity: 1
            }
        });
    }
    onEnd() {
        this.target.setTheme({
            common: {
                opacity: 0
            }
        });
    }
    onUpdate(end, ratio, out) {
        this.target.setTheme({
            common: {
                opacity: 1 - ratio
            }
        });
    }
}

exports.GroupFadeOut = GroupFadeOut;

class AttributeAnimate extends animate_1.ACustomAnimate {
    constructor(to, duration, easing) {
        super({}, to, duration, easing);
    }
    getEndProps() {
        return this.to;
    }
    onBind() {
        Object.keys(this.to).forEach((k => {
            this.from[k] = this.target.getComputedAttribute(k);
        }));
    }
    onEnd() {}
    onUpdate(end, ratio, out) {
        this.target.stepInterpolate(this.subAnimate, this.subAnimate.animate, out, this.step, ratio, end, this.to, this.from);
    }
}

exports.AttributeAnimate = AttributeAnimate;

class AnimateGroup extends animate_1.ACustomAnimate {
    constructor(duration, customAnimates) {
        super(null, null, duration, "linear"), this.customAnimates = customAnimates;
    }
    initAnimates() {
        this.customAnimates.forEach((a => {
            a.step = this.step, a.subAnimate = this.subAnimate, a.target = this.target;
        }));
    }
    getEndProps() {
        const props = {};
        return this.customAnimates.forEach((a => {
            Object.assign(props, a.getEndProps());
        })), props;
    }
    onBind() {
        this.initAnimates(), this.customAnimates.forEach((a => {
            a.onBind();
        }));
    }
    onEnd() {
        this.customAnimates.forEach((a => {
            a.onEnd();
        }));
    }
    onUpdate(end, ratio, out) {
        this.updating || (this.updating = !0, this.customAnimates.forEach((a => {
            const easing = a.easing, easingFunc = "string" == typeof easing ? easing_1.Easing[easing] : easing;
            ratio = easingFunc(ratio), a.onUpdate(end, ratio, out);
        })), this.updating = !1);
    }
}

exports.AnimateGroup = AnimateGroup;

class AnimateGroup1 extends animate_1.ACustomAnimate {
    constructor(duration, customAnimates) {
        super(null, null, duration, "linear"), this.customAnimates = customAnimates;
    }
    initAnimates() {
        this.customAnimates.forEach((a => {
            a.step = this.step, a.subAnimate = this.subAnimate, a.target = this.target;
        }));
    }
    getEndProps() {
        const props = {};
        return this.customAnimates.forEach((a => {
            Object.assign(props, a.getEndProps());
        })), props;
    }
    onBind() {
        this.initAnimates(), this.customAnimates.forEach((a => {
            a.onBind();
        }));
    }
    onEnd() {
        this.customAnimates.forEach((a => {
            a.onEnd();
        }));
    }
    onUpdate(end, ratio, out) {
        this.updating || (this.updating = !0, this.customAnimates.forEach((a => {
            const easing = a.easing, easingFunc = "string" == typeof easing ? easing_1.Easing[easing] : easing;
            ratio = easingFunc(ratio), a.onUpdate(end, ratio, out);
        })), this.updating = !1);
    }
}

exports.AnimateGroup1 = AnimateGroup1;
//# sourceMappingURL=custom-animate.js.map
}, function(modId) { var map = {"../application":1689069767703,"../common/enums":1689069767685,"./animate":1689069767731,"./easing":1689069767732,"../common/utils":1689069767736}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767736, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getAttributeFromDefaultAttrList = exports.isTransformKey = exports.transformKeys = exports.pointsInterpolation = exports.pointInterpolationHighPerformance = exports.pointInterpolation = exports.pointEqual = exports.pointsEqual = exports.circleBounds = exports.parsePadding = exports.parseStroke = exports.Edge = void 0;

const vutils_1 = require("@visactor/vutils");

var Edge;

!function(Edge) {
    Edge[Edge.Top = 1] = "Top", Edge[Edge.Right = 2] = "Right", Edge[Edge.Bottom = 4] = "Bottom", 
    Edge[Edge.Left = 8] = "Left", Edge[Edge.ALL = 15] = "ALL";
}(Edge = exports.Edge || (exports.Edge = {}));

const _strokeVec4 = [ !1, !1, !1, !1 ], parseStroke = stroke => {
    var _a;
    let isFullStroke = !0;
    if ((0, vutils_1.isBoolean)(stroke, !0)) {
        for (let i = 0; i < 4; i++) _strokeVec4[i] = stroke, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));
        isFullStroke = stroke;
    } else if (Array.isArray(stroke)) for (let i = 0; i < 4; i++) _strokeVec4[i] = !!stroke[i], 
    isFullStroke && (isFullStroke = !!_strokeVec4[i]); else _strokeVec4[0] = !1, _strokeVec4[1] = !1, 
    _strokeVec4[2] = !1, _strokeVec4[3] = !1;
    return {
        isFullStroke: isFullStroke,
        stroke: _strokeVec4
    };
};

exports.parseStroke = parseStroke;

const _paddingVec4 = [ 0, 0, 0, 0 ], parsePadding = padding => padding ? (0, vutils_1.isArray)(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], 
_paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], 
_paddingVec4) : padding : padding : 0;

exports.parsePadding = parsePadding;

const _coords = [ {
    x: 0,
    y: 0
}, {
    x: 0,
    y: 0
}, {
    x: 0,
    y: 0
}, {
    x: 0,
    y: 0
} ], indexList = [ 1, 2, 3, 0, 1, 2, 3, 0 ];

function circleBounds(startAngle, endAngle, radius, bounds) {
    for (;startAngle >= vutils_1.pi2; ) startAngle -= vutils_1.pi2;
    for (;startAngle < 0; ) startAngle += vutils_1.pi2;
    for (;startAngle > endAngle; ) endAngle += vutils_1.pi2;
    _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
    const startIdx = Math.ceil(startAngle / vutils_1.halfPi) % 4, endIdx = Math.ceil(endAngle / vutils_1.halfPi) % 4;
    if (bounds.add((0, vutils_1.cos)(startAngle) * radius, (0, vutils_1.sin)(startAngle) * radius), 
    bounds.add((0, vutils_1.cos)(endAngle) * radius, (0, vutils_1.sin)(endAngle) * radius), 
    startIdx !== endIdx || endAngle - startAngle > vutils_1.pi) {
        let match = !1;
        for (let i = 0; i < indexList.length; i++) if (match || startIdx !== indexList[i]) {
            if (match && endIdx === indexList[i]) break;
            if (match) {
                const p = _coords[indexList[i]];
                bounds.add(p.x, p.y);
            }
        } else {
            match = !0;
            const p = _coords[startIdx];
            bounds.add(p.x, p.y);
        }
    }
}

function pointsEqual(pointsA, pointsB) {
    return !(!pointsA || !pointsB) && (Array.isArray(pointsA) && Array.isArray(pointsB) ? pointsA.length === pointsB.length && pointsA.every(((point, index) => pointEqual(point, pointsB[index]))) : !Number.isNaN(pointsA.x + pointsA.y) && pointEqual(pointsA, pointsB));
}

function pointEqual(pointA, pointB) {
    return pointA.x === pointB.x && pointA.y === pointB.y && pointA.x1 === pointB.x1 && pointA.y1 === pointB.y1 && pointA.defined === pointB.defined;
}

function pointInterpolation(pointA, pointB, ratio) {
    const {x: x, y: y} = (0, vutils_1.pointAt)(pointA.x, pointA.y, pointB.x, pointB.y, ratio), {x: x1, y: y1} = (0, 
    vutils_1.pointAt)(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio), point = new vutils_1.Point(x, y, x1, y1);
    return point.defined = pointB.defined, point;
}

function pointInterpolationHighPerformance(pointA, pointB, ratio, point) {
    const {x: x, y: y} = (0, vutils_1.pointAt)(pointA.x, pointA.y, pointB.x, pointB.y, ratio), {x: x1, y: y1} = (0, 
    vutils_1.pointAt)(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio);
    return point.x = x, point.y = y, point.x1 = x1, point.y1 = y1, point.defined = pointB.defined, 
    point;
}

function pointsInterpolation(pointsA, pointsB, ratio) {
    if (!pointsA || !pointsB) return [];
    Array.isArray(pointsA) || (pointsA = [ pointsA ]), Array.isArray(pointsB) || (pointsB = [ pointsB ]);
    let points = [];
    if (pointsA.length > pointsB.length) {
        points = pointsB.map((point => {
            const p = new vutils_1.Point(point.x, point.y, point.x1, point.y1);
            return p.defined = point.defined, p;
        }));
        for (let i = 0; i < pointsB.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
    } else {
        points = pointsB.map((point => {
            const p = new vutils_1.Point(point.x, point.y, point.x1, point.y1);
            return p.defined = point.defined, p;
        }));
        for (let i = 0; i < pointsA.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
    }
    return points;
}

exports.circleBounds = circleBounds, exports.pointsEqual = pointsEqual, exports.pointEqual = pointEqual, 
exports.pointInterpolation = pointInterpolation, exports.pointInterpolationHighPerformance = pointInterpolationHighPerformance, 
exports.pointsInterpolation = pointsInterpolation, exports.transformKeys = [ "x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "scrollX", "scrollY" ];

const isTransformKey = key => exports.transformKeys.includes(key);

function getAttributeFromDefaultAttrList(attr, key) {
    if ((0, vutils_1.isArray)(attr)) {
        let val;
        for (let i = 0; i < attr.length && void 0 === val; i++) val = attr[i][key];
        return val;
    }
    return attr[key];
}

exports.isTransformKey = isTransformKey, exports.getAttributeFromDefaultAttrList = getAttributeFromDefaultAttrList;
//# sourceMappingURL=utils.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767737, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.multiToOneMorph = exports.splitGraphic = exports.cloneGraphic = exports.MultiToOneMorphingPath = exports.oneToMultiMorph = exports.morphPath = exports.MorphingPath = void 0;

const split_path_1 = require("./../common/split-path"), custom_path2d_1 = require("../common/custom-path2d"), animate_1 = require("./animate"), morphing_utils_1 = require("../common/morphing-utils"), application_1 = require("../application"), vutils_1 = require("@visactor/vutils"), interpolate_1 = require("../color-string/interpolate"), color_string_1 = require("../color-string"), config_1 = require("./config"), utils_1 = require("../common/utils"), enums_1 = require("../common/enums"), interpolateOtherAttrs = (attrs, out, ratio) => {
    attrs.forEach((entry => {
        if (Number.isFinite(entry.to)) out[entry.key] = entry.from + (entry.to - entry.from) * ratio; else if ("fill" === entry.key || "stroke" === entry.key) {
            const color = (0, interpolate_1.interpolateColor)(entry.from, entry.to, ratio, !1);
            color && (out[entry.key] = color);
        }
    }));
}, interpolateMorphingData = (morphingData, path, ratio) => {
    const tmpArr = [], newCp = [];
    path.clear();
    for (let i = 0; i < morphingData.length; i++) {
        const item = morphingData[i], from = item.from, to = item.to, angle = item.rotation * ratio, fromCp = item.fromCp, toCp = item.toCp, sa = Math.sin(angle), ca = Math.cos(angle);
        newCp[0] = fromCp[0] + (toCp[0] - fromCp[0]) * ratio, newCp[1] = fromCp[1] + (toCp[1] - fromCp[1]) * ratio;
        for (let m = 0; m < from.length; m += 2) {
            const x0 = from[m], y0 = from[m + 1], x = x0 * (1 - ratio) + to[m] * ratio, y = y0 * (1 - ratio) + to[m + 1] * ratio;
            tmpArr[m] = x * ca - y * sa + newCp[0], tmpArr[m + 1] = x * sa + y * ca + newCp[1];
        }
        let x0 = tmpArr[0], y0 = tmpArr[1];
        path.moveTo(x0, y0);
        for (let m = 2; m < from.length; m += 6) {
            const x1 = tmpArr[m], y1 = tmpArr[m + 1], x2 = tmpArr[m + 2], y2 = tmpArr[m + 3], x3 = tmpArr[m + 4], y3 = tmpArr[m + 5];
            x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3 ? path.lineTo(x3, y3) : path.bezierCurveTo(x1, y1, x2, y2, x3, y3), 
            x0 = x3, y0 = y3;
        }
    }
}, parseMorphingData = (fromPath, toPath, config) => {
    const fromBezier = fromPath ? (0, morphing_utils_1.pathToBezierCurves)(fromPath) : [], toBezier = (0, 
    morphing_utils_1.pathToBezierCurves)(toPath);
    config && fromBezier && (config.fromTransform && (0, morphing_utils_1.applyTransformOnBezierCurves)(fromBezier, config.fromTransform.clone().getInverse()), 
    (0, morphing_utils_1.applyTransformOnBezierCurves)(fromBezier, config.toTransfrom));
    const [fromBezierCurves, toBezierCurves] = (0, morphing_utils_1.alignBezierCurves)(fromBezier, toBezier);
    return fromPath ? (0, morphing_utils_1.findBestMorphingRotation)(fromBezierCurves, toBezierCurves, 10, Math.PI) : toBezierCurves.map(((to, index) => ({
        from: fromBezierCurves[index],
        to: to,
        fromCp: [ 0, 0 ],
        toCp: [ 0, 0 ],
        rotation: 0
    })));
}, validateOtherAttrs = [ "fill", "fillOpacity", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "lineDashOffset" ], parseOtherAnimateAttrs = (fromAttrs, toAttrs) => {
    if (!fromAttrs || !toAttrs) return null;
    const res = [];
    let hasAttr = !1;
    return Object.keys(fromAttrs).forEach((fromKey => {
        if (!validateOtherAttrs.includes(fromKey)) return;
        const toValue = toAttrs[fromKey];
        (0, vutils_1.isNil)(toValue) || (0, vutils_1.isNil)(fromAttrs[fromKey]) || toValue === fromAttrs[fromKey] || ("fill" === fromKey || "stroke" === fromKey ? res.push({
            from: "string" == typeof fromAttrs[fromKey] ? color_string_1.ColorStore.Get(fromAttrs[fromKey], color_string_1.ColorType.Color255) : fromAttrs[fromKey],
            to: "string" == typeof toValue ? color_string_1.ColorStore.Get(toValue, color_string_1.ColorType.Color255) : toValue,
            key: fromKey
        }) : res.push({
            from: fromAttrs[fromKey],
            to: toValue,
            key: fromKey
        }), hasAttr = !0);
    })), hasAttr ? res : null;
};

class MorphingPath extends animate_1.ACustomAnimate {
    constructor(config, duration, easing) {
        super(0, 1, duration, easing), this.morphingData = config.morphingData, this.otherAttrs = config.otherAttrs, 
        this.saveOnEnd = config.saveOnEnd;
    }
    getEndProps() {
        return {};
    }
    onBind() {
        this.target.createPathProxy(), this.onUpdate(!1, 0, this.target.attribute);
    }
    onEnd() {}
    onUpdate(end, ratio, out) {
        const target = this.target, pathProxy = "function" == typeof target.pathProxy ? target.pathProxy(target.attribute) : target.pathProxy;
        interpolateMorphingData(this.morphingData, pathProxy, ratio), this.otherAttrs && this.otherAttrs.length && interpolateOtherAttrs(this.otherAttrs, out, ratio), 
        end && !this.saveOnEnd && (this.target.pathProxy = null);
    }
}

exports.MorphingPath = MorphingPath;

const morphPath = (fromGraphic, toGraphic, animationConfig, fromGraphicTransform) => {
    var _a, _b, _c;
    if (fromGraphic && (!fromGraphic.valid || !fromGraphic.toCustomPath)) return __DEV__ && console.error(fromGraphic, " is not validate"), 
    null;
    if (!toGraphic.valid || !toGraphic.toCustomPath) return __DEV__ && console.error(toGraphic, " is not validate"), 
    null;
    let fromTransform = null == fromGraphic ? void 0 : fromGraphic.globalTransMatrix;
    fromGraphicTransform && fromTransform && (fromTransform = fromGraphicTransform.clone().multiply(fromTransform.a, fromTransform.b, fromTransform.c, fromTransform.d, fromTransform.e, fromTransform.f));
    const morphingData = parseMorphingData(null === (_a = null == fromGraphic ? void 0 : fromGraphic.toCustomPath) || void 0 === _a ? void 0 : _a.call(fromGraphic), toGraphic.toCustomPath(), {
        fromTransform: fromTransform,
        toTransfrom: toGraphic.globalTransMatrix
    }), attrs = parseOtherAnimateAttrs(null == fromGraphic ? void 0 : fromGraphic.attribute, toGraphic.attribute), animate = toGraphic.animate(animationConfig);
    return (null == animationConfig ? void 0 : animationConfig.delay) && animate.wait(animationConfig.delay), 
    animate.play(new MorphingPath({
        morphingData: morphingData,
        otherAttrs: attrs
    }, null !== (_b = null == animationConfig ? void 0 : animationConfig.duration) && void 0 !== _b ? _b : config_1.DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig ? void 0 : animationConfig.easing) && void 0 !== _c ? _c : config_1.DefaultMorphingAnimateConfig.easing)), 
    animate;
};

exports.morphPath = morphPath;

const oneToMultiMorph = (fromGraphic, toGraphics, animationConfig) => {
    var _a;
    const validateToGraphics = toGraphics.filter((graphic => graphic && graphic.toCustomPath && graphic.valid));
    validateToGraphics.length || __DEV__ && console.error(validateToGraphics, " is not validate"), 
    fromGraphic.valid && fromGraphic.toCustomPath || __DEV__ && console.error(fromGraphic, " is not validate");
    const childGraphics = ("clone" === (null == animationConfig ? void 0 : animationConfig.splitPath) ? exports.cloneGraphic : null !== (_a = null == animationConfig ? void 0 : animationConfig.splitPath) && void 0 !== _a ? _a : exports.splitGraphic)(fromGraphic, validateToGraphics.length, !1), oldOnEnd = null == animationConfig ? void 0 : animationConfig.onEnd;
    let count = validateToGraphics.length;
    const onEachEnd = () => {
        count--, 0 === count && oldOnEnd && oldOnEnd();
    };
    validateToGraphics.forEach(((toChild, index) => {
        var _a;
        const fromChild = childGraphics[index], delay = (null !== (_a = null == animationConfig ? void 0 : animationConfig.delay) && void 0 !== _a ? _a : 0) + ((null == animationConfig ? void 0 : animationConfig.individualDelay) ? animationConfig.individualDelay(index, validateToGraphics.length, fromChild, toChild) : 0);
        (0, exports.morphPath)(fromChild, toChild, Object.assign({}, animationConfig, {
            onEnd: onEachEnd,
            delay: delay
        }), fromGraphic.globalTransMatrix);
    }));
};

exports.oneToMultiMorph = oneToMultiMorph;

class MultiToOneMorphingPath extends animate_1.ACustomAnimate {
    constructor(config, duration, easing) {
        super(0, 1, duration, easing), this.morphingData = config.morphingData, this.otherAttrs = config.otherAttrs;
    }
    getEndProps() {
        return {};
    }
    onBind() {
        this.addPathProxy();
    }
    addPathProxy() {
        this.target.shadowRoot.forEachChildren((child => {
            child.createPathProxy();
        })), this.onUpdate(!1, 0, this.target.attribute);
    }
    clearPathProxy() {
        this.target.shadowRoot.forEachChildren((child => {
            child.pathProxy = null;
        }));
    }
    onEnd() {}
    onUpdate(end, ratio, out) {
        this.target.shadowRoot.forEachChildren(((child, index) => {
            var _a;
            interpolateMorphingData(this.morphingData[index], "function" == typeof child.pathProxy ? child.pathProxy(child.attribute) : child.pathProxy, ratio), 
            (null === (_a = this.otherAttrs) || void 0 === _a ? void 0 : _a[index]) && this.otherAttrs[index].length && interpolateOtherAttrs(this.otherAttrs[index], child.attribute, ratio);
        })), end && (this.clearPathProxy(), this.morphingData = null);
    }
}

exports.MultiToOneMorphingPath = MultiToOneMorphingPath;

const parseShadowChildAttrs = graphicAttrs => {
    const attrs = {};
    return Object.keys(graphicAttrs).forEach((key => {
        (0, utils_1.isTransformKey)(key) || (attrs[key] = graphicAttrs[key]);
    })), attrs;
}, appendShadowChildrenToGraphic = (graphic, children, count) => {
    const childAttrs = parseShadowChildAttrs(graphic.attribute), shadowRoot = graphic.attachShadow();
    if (children.length) shadowRoot.setTheme({
        [children[0].type]: childAttrs
    }), children.forEach((element => {
        shadowRoot.appendChild(element);
    })); else {
        const box = graphic.AABBBounds, width = box.width(), height = box.height();
        shadowRoot.setTheme({
            rect: childAttrs
        }), new Array(count).fill(0).forEach((el => {
            const child = application_1.application.graphicService.creator.rect({
                x: 0,
                y: 0,
                width: width,
                height: height
            });
            shadowRoot.appendChild(child), children.push(child);
        }));
    }
}, cloneGraphic = (graphic, count, needAppend) => {
    const children = [], childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute), path = graphic.toCustomPath();
    for (let i = 0; i < count; i++) {
        const element = {
            path: (new custom_path2d_1.CustomPath2D).fromCustomPath2D(path)
        };
        children.push(application_1.application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element)));
    }
    return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
};

exports.cloneGraphic = cloneGraphic;

const splitGraphic = (graphic, count, needAppend) => {
    const children = [], childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute);
    if ("rect" === graphic.type) {
        (0, split_path_1.splitRect)(graphic, count).forEach((element => {
            children.push(application_1.application.graphicService.creator.rect(needAppend ? element : Object.assign({}, childAttrs, element)));
        }));
    } else if ("arc" === graphic.type) {
        (0, split_path_1.splitArc)(graphic, count).forEach((element => {
            children.push(application_1.application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
        }));
    } else if ("circle" === graphic.type) {
        (0, split_path_1.splitCircle)(graphic, count).forEach((element => {
            children.push(application_1.application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
        }));
    } else if ("line" === graphic.type) {
        const childrenAttrs = (0, split_path_1.splitLine)(graphic, count), defaultSymbol = {
            size: 10,
            symbolType: "circle"
        };
        childrenAttrs.forEach((element => {
            children.push(application_1.application.graphicService.creator.symbol(needAppend ? Object.assign({}, element, defaultSymbol) : Object.assign({}, childAttrs, element, defaultSymbol)));
        }));
    } else if ("polygon" === graphic.type) {
        (0, split_path_1.splitPolygon)(graphic, count).forEach((element => {
            children.push(application_1.application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
        }));
    } else if ("area" === graphic.type) {
        (0, split_path_1.splitArea)(graphic, count).forEach((element => {
            children.push(application_1.application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
        }));
    } else if ("path" === graphic.type) {
        (0, split_path_1.splitPath)(graphic, count).forEach((element => {
            "path" in element ? children.push(application_1.application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element))) : children.push(application_1.application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
        }));
    }
    return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
};

exports.splitGraphic = splitGraphic;

const multiToOneMorph = (fromGraphics, toGraphic, animationConfig) => {
    var _a, _b, _c;
    const validateFromGraphics = fromGraphics.filter((graphic => graphic.toCustomPath && graphic.valid));
    validateFromGraphics.length || __DEV__ && console.error(fromGraphics, " is not validate"), 
    toGraphic.valid && toGraphic.toCustomPath || __DEV__ && console.error(toGraphic, " is not validate");
    const childGraphics = ("clone" === (null == animationConfig ? void 0 : animationConfig.splitPath) ? exports.cloneGraphic : null !== (_a = null == animationConfig ? void 0 : animationConfig.splitPath) && void 0 !== _a ? _a : exports.splitGraphic)(toGraphic, validateFromGraphics.length, !0), toAttrs = toGraphic.attribute;
    toGraphic.setAttribute("visible", !1);
    const morphingData = validateFromGraphics.map(((graphic, index) => parseMorphingData(graphic.toCustomPath(), childGraphics[index].toCustomPath(), {
        fromTransform: graphic.globalTransMatrix,
        toTransfrom: childGraphics[index].globalTransMatrix
    }))), otherAttrs = validateFromGraphics.map(((graphic, index) => parseOtherAnimateAttrs(graphic.attribute, toAttrs)));
    if (null == animationConfig ? void 0 : animationConfig.individualDelay) {
        const oldOnEnd = animationConfig.onEnd;
        let count = validateFromGraphics.length;
        const onEachEnd = () => {
            count--, 0 === count && (toGraphic.setAttributes({
                visible: !0,
                ratio: null
            }, !1, {
                type: enums_1.AttributeUpdateType.ANIMATE_END
            }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd());
        };
        childGraphics.forEach(((to, index) => {
            var _a, _b, _c;
            const delay = (null !== (_a = animationConfig.delay) && void 0 !== _a ? _a : 0) + animationConfig.individualDelay(index, validateFromGraphics.length, fromGraphics[index], to), animate = to.animate(Object.assign({}, animationConfig, {
                onEnd: onEachEnd
            }));
            animate.wait(delay), animate.play(new MorphingPath({
                morphingData: morphingData[index],
                saveOnEnd: !0,
                otherAttrs: otherAttrs[index]
            }, null !== (_b = animationConfig.duration) && void 0 !== _b ? _b : config_1.DefaultMorphingAnimateConfig.duration, null !== (_c = animationConfig.easing) && void 0 !== _c ? _c : config_1.DefaultMorphingAnimateConfig.easing));
        }));
    } else {
        const oldOnEnd = null == animationConfig ? void 0 : animationConfig.onEnd, config = animationConfig ? Object.assign({}, animationConfig) : {};
        config.onEnd = () => {
            toGraphic.setAttribute("visible", !0, !1, {
                type: enums_1.AttributeUpdateType.ANIMATE_END
            }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd();
        };
        const animate = toGraphic.animate(config);
        (null == animationConfig ? void 0 : animationConfig.delay) && animate.wait(animationConfig.delay), 
        animate.play(new MultiToOneMorphingPath({
            morphingData: morphingData,
            otherAttrs: otherAttrs
        }, null !== (_b = null == animationConfig ? void 0 : animationConfig.duration) && void 0 !== _b ? _b : config_1.DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig ? void 0 : animationConfig.easing) && void 0 !== _c ? _c : config_1.DefaultMorphingAnimateConfig.easing));
    }
};

exports.multiToOneMorph = multiToOneMorph;
//# sourceMappingURL=morphing.js.map
}, function(modId) { var map = {"./../common/split-path":1689069767738,"../common/custom-path2d":1689069767681,"./animate":1689069767731,"../common/morphing-utils":1689069767739,"../application":1689069767703,"../color-string/interpolate":1689069767740,"../color-string":1689069767741,"./config":1689069767734,"../common/utils":1689069767736,"../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767738, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.splitPath = exports.splitPolygon = exports.recursiveCallBinarySplit = exports.binarySplitPolygon = exports.splitLine = exports.splitArea = exports.splitCircle = exports.splitArc = exports.splitRect = exports.splitToGrids = void 0;

const vutils_1 = require("@visactor/vutils"), morphing_utils_1 = require("./morphing-utils");

function splitToGrids(width, height, count) {
    const ratio = width / height;
    let rowCount, columnCount;
    width >= height ? (columnCount = Math.ceil(Math.sqrt(count * ratio)), rowCount = Math.floor(count / columnCount), 
    0 === rowCount && (rowCount = 1, columnCount = count)) : (rowCount = Math.ceil(Math.sqrt(count / ratio)), 
    columnCount = Math.floor(count / rowCount), 0 === columnCount && (columnCount = 1, 
    rowCount = count));
    const grids = [];
    for (let i = 0; i < rowCount; i++) grids.push(columnCount);
    const remained = count - rowCount * columnCount;
    if (remained > 0) for (let i = 0; i < remained; i += columnCount) i + columnCount < remained ? grids.push(columnCount) : grids.push(remained - i);
    return grids;
}

exports.splitToGrids = splitToGrids;

const splitRect = (rect, count) => {
    const width = rect.getComputedAttribute("width"), height = rect.getComputedAttribute("height"), grids = splitToGrids(width, height, count), res = [], gridHeight = height / grids.length;
    for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
        const columnCount = grids[i], gridWidth = width / columnCount;
        for (let j = 0; j < columnCount; j++) res.push({
            x: 0 + j * gridWidth,
            y: 0 + i * gridHeight,
            width: gridWidth,
            height: gridHeight
        });
    }
    return res;
};

exports.splitRect = splitRect;

const splitArc = (arc, count) => {
    const angles = arc.getParsedAngle(), startAngle = angles.startAngle, endAngle = angles.endAngle, innerRadius = arc.getComputedAttribute("innerRadius"), outerRadius = arc.getComputedAttribute("outerRadius"), angleDelta = Math.abs(startAngle - endAngle), radiusDelta = Math.abs(outerRadius - innerRadius), grids = splitToGrids(angleDelta * (innerRadius + outerRadius) / 2, radiusDelta, count), res = [], gridRadius = radiusDelta / grids.length, radiusSign = outerRadius >= innerRadius ? 1 : -1, angleSign = endAngle >= startAngle ? 1 : -1;
    for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
        const columnCount = grids[i], gridAngle = angleDelta / columnCount;
        for (let j = 0; j < columnCount; j++) res.push({
            innerRadius: outerRadius - gridRadius * i * radiusSign,
            outerRadius: outerRadius - gridRadius * (i + 1) * radiusSign,
            startAngle: startAngle + gridAngle * j * angleSign,
            endAngle: startAngle + gridAngle * (j + 1) * angleSign
        });
    }
    return res;
};

exports.splitArc = splitArc;

const splitCircle = (arc, count) => {
    const startAngle = arc.getComputedAttribute("startAngle"), endAngle = arc.getComputedAttribute("endAngle"), radius = arc.getComputedAttribute("radius"), angleDelta = Math.abs(startAngle - endAngle), grids = splitToGrids(angleDelta * radius, radius, count), res = [], gridAngle = angleDelta / grids[0], gridRadius = radius / grids.length, angleSign = endAngle >= startAngle ? 1 : -1;
    for (let i = 0, rowCount = grids.length; i < rowCount; i++) for (let j = 0, columnCount = grids[i]; j < columnCount; j++) res.push({
        innerRadius: gridRadius * i,
        outerRadius: gridRadius * (i + 1),
        startAngle: startAngle + gridAngle * j * angleSign,
        endAngle: startAngle + gridAngle * (j + 1) * angleSign
    });
    return res;
};

exports.splitCircle = splitCircle;

const samplingPoints = (points, count) => {
    const validatePoints = points.filter((point => !1 !== point.defined && (0, vutils_1.isNumber)(point.x) && (0, 
    vutils_1.isNumber)(point.y)));
    if (0 === validatePoints.length) return [];
    if (1 === validatePoints.length) return new Array(count).fill(0).map((i => validatePoints[0]));
    const res = [];
    if (count <= validatePoints.length) {
        const step = validatePoints.length / count;
        let i = 0, cur = 0;
        for (;i < count; ) res.push(validatePoints[Math.floor(cur)]), cur += step, i++;
        return res;
    }
    const insertCount = count - validatePoints.length, insetRatio = 1 / (insertCount / (validatePoints.length - 1) + 1);
    let curCount = 0;
    for (let i = 0, len = points.length; i < len; i++) if (res.push(points[i]), i < len - 1) {
        let cur = insetRatio;
        const xCur = points[i].x, yCur = points[i].y, xNext = points[i + 1].x, yNext = points[i + 1].y;
        for (;cur < 1 && curCount < insertCount; ) res.push({
            x: xCur + (xNext - xCur) * cur,
            y: yCur + (yNext - yCur) * cur
        }), cur += insetRatio, curCount += 1;
    }
    return res;
}, splitArea = (area, count) => {
    var _a, _b;
    const attribute = area.attribute;
    let points = attribute.points;
    const segements = attribute.segments;
    points || (points = segements.reduce(((res, seg) => {
        var _a;
        return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);
    }), []));
    const validatePoints = points.filter((point => !1 !== point.defined && (0, vutils_1.isNumber)(point.x) && (0, 
    vutils_1.isNumber)(point.y)));
    if (!validatePoints.length) return [];
    const allPoints = [];
    validatePoints.forEach((point => {
        allPoints.push({
            x: point.x,
            y: point.y
        });
    }));
    for (let i = validatePoints.length - 1; i >= 0; i--) {
        const point = validatePoints[i];
        allPoints.push({
            x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,
            y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y
        });
    }
    const res = [];
    return (0, exports.recursiveCallBinarySplit)(points, count, res), res;
};

exports.splitArea = splitArea;

const splitLine = (line, count) => {
    const attribute = line.attribute, points = attribute.points;
    if (points) return samplingPoints(points, count);
    if (attribute.segments) {
        const allPoints = attribute.segments.reduce(((res, seg) => {
            var _a;
            return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);
        }), []);
        return samplingPoints(allPoints, count);
    }
    return [];
};

function crossProduct(dir1, dir2) {
    return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}

exports.splitLine = splitLine;

const clonePoints = points => points.map((p => ({
    x: p.x,
    y: p.y
}))), splitPolygonByLine = (points, p0, p1) => {
    const len = points.length, intersections = [];
    for (let i = 0; i < len; i++) {
        const cur = points[i], next = i === len - 1 ? points[0] : points[i + 1], res = (0, 
        vutils_1.getIntersectPoint)([ p0.x, p0.y ], [ p1.x, p1.y ], [ cur.x, cur.y ], [ next.x, next.y ]);
        res && "boolean" != typeof res && intersections.push({
            dot: crossProduct([ res[0] - p0.x, res[1] - p0.x ], [ p1.x - p0.x, p1.y - p0.x ]),
            point: {
                x: res[0],
                y: res[1]
            },
            edgeIndex: i
        });
    }
    if (intersections.length < 2) return [ clonePoints(points), clonePoints(points) ];
    intersections.sort(((a, b) => a.dot - b.dot));
    let is0 = intersections[0], is1 = intersections[intersections.length - 1];
    is0.edgeIndex > is1.edgeIndex && ([is0, is1] = [ is1, is0 ]);
    const newP0 = is0.point, newP1 = is1.point, newPointsA = [ {
        x: newP0.x,
        y: newP0.y
    } ];
    for (let i = is0.edgeIndex + 1; i <= is1.edgeIndex; i++) newPointsA.push({
        x: points[i].x,
        y: points[i].y
    });
    newPointsA.push({
        x: newP1.x,
        y: newP1.y
    });
    const newPointsB = [ {
        x: newP1.x,
        y: newP1.y
    } ];
    for (let i = is1.edgeIndex + 1, maxIndex = is0.edgeIndex + len; i <= maxIndex; i++) {
        const p = points[i % len];
        newPointsB.push({
            x: p.x,
            y: p.y
        });
    }
    return newPointsB.push({
        x: newP0.x,
        y: newP0.y
    }), [ newPointsA, newPointsB ];
}, binarySplitPolygon = points => {
    const box = new vutils_1.Bounds;
    points.forEach((point => {
        box.add(point.x, point.y);
    }));
    const width = box.width(), height = box.height();
    if (width >= height) {
        const midX = box.x1 + width / 2;
        return splitPolygonByLine(points, {
            x: midX,
            y: box.y1
        }, {
            x: midX,
            y: box.y2
        });
    }
    const midY = box.y1 + height / 2;
    return splitPolygonByLine(points, {
        x: box.x1,
        y: midY
    }, {
        x: box.x2,
        y: midY
    });
};

exports.binarySplitPolygon = binarySplitPolygon;

const recursiveCallBinarySplit = (points, count, out) => {
    if (1 === count) out.push({
        points: points
    }); else {
        const half = Math.floor(count / 2), res = (0, exports.binarySplitPolygon)(points);
        (0, exports.recursiveCallBinarySplit)(res[0], half, out), (0, exports.recursiveCallBinarySplit)(res[1], count - half, out);
    }
};

exports.recursiveCallBinarySplit = recursiveCallBinarySplit;

const splitPolygon = (polygon, count) => {
    const points = polygon.attribute.points;
    if (!points || !points.length) return [];
    if (1 === count) return [ {
        points: clonePoints(points)
    } ];
    const res = [];
    return (0, exports.recursiveCallBinarySplit)(points, count, res), res;
};

exports.splitPolygon = splitPolygon;

const splitPath = (path, count) => {
    const pathShape = path.getParsedPathShape(), bezierCurves = (0, morphing_utils_1.pathToBezierCurves)(pathShape);
    if (!bezierCurves.length || count < 0) return [];
    const subPathCnt = bezierCurves.length;
    if (bezierCurves.length >= count) {
        const res = [], stepCount = Math.floor(bezierCurves.length / count);
        for (let i = 0; i < count; i++) {
            const curves = bezierCurves.slice(i * stepCount, i === count - 1 ? subPathCnt : (i + 1) * stepCount);
            res.push({
                path: (0, morphing_utils_1.bezierCurversToPath)(curves)
            });
        }
        return res;
    }
    const res = [], stepCount = Math.floor(count / subPathCnt);
    let remain = count;
    for (let c = 0; c < subPathCnt; c++) {
        const points = [];
        for (let i = 2, len = bezierCurves[c].length; i < len; i += 2) points.push({
            x: bezierCurves[0][i],
            y: bezierCurves[0][i + 1]
        });
        (0, exports.recursiveCallBinarySplit)(points, c === subPathCnt - 1 ? remain : stepCount, res), 
        remain -= stepCount;
    }
    return res;
};

exports.splitPath = splitPath;
//# sourceMappingURL=split-path.js.map
}, function(modId) { var map = {"./morphing-utils":1689069767739}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767739, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.bezierCurversToPath = exports.applyTransformOnBezierCurves = exports.pathToBezierCurves = exports.alignBezierCurves = exports.findBestMorphingRotation = exports.centroidOfSubpath = exports.alignSubpath = exports.cubicSubdivide = void 0;

const vutils_1 = require("@visactor/vutils"), custom_path2d_1 = require("./custom-path2d"), path_svg_1 = require("./path-svg"), arc_1 = require("./shape/arc");

function cubicSubdivide(p0, p1, p2, p3, t, out) {
    const p01 = (p1 - p0) * t + p0, p12 = (p2 - p1) * t + p1, p23 = (p3 - p2) * t + p2, p012 = (p12 - p01) * t + p01, p123 = (p23 - p12) * t + p12, p0123 = (p123 - p012) * t + p012;
    out[0] = p0, out[1] = p01, out[2] = p012, out[3] = p0123, out[4] = p0123, out[5] = p123, 
    out[6] = p23, out[7] = p3;
}

function alignSubpath(subpath1, subpath2) {
    const len1 = subpath1.length, len2 = subpath2.length;
    if (len1 === len2) return [ subpath1, subpath2 ];
    const tmpSegX = [], tmpSegY = [], shorterPath = len1 < len2 ? subpath1 : subpath2, shorterLen = Math.min(len1, len2), diff = Math.abs(len2 - len1) / 6, shorterBezierCount = (shorterLen - 2) / 6, eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount), newSubpath = [ shorterPath[0], shorterPath[1] ];
    let remained = diff;
    for (let i = 2; i < shorterLen; i += 6) {
        let x0 = shorterPath[i - 2], y0 = shorterPath[i - 1], x1 = shorterPath[i], y1 = shorterPath[i + 1], x2 = shorterPath[i + 2], y2 = shorterPath[i + 3];
        const x3 = shorterPath[i + 4], y3 = shorterPath[i + 5];
        if (remained <= 0) {
            newSubpath.push(x1, y1, x2, y2, x3, y3);
            continue;
        }
        const actualSubDivCount = Math.min(remained, eachCurveSubDivCount) + 1;
        for (let k = 1; k <= actualSubDivCount; k++) {
            const p = k / actualSubDivCount;
            cubicSubdivide(x0, x1, x2, x3, p, tmpSegX), cubicSubdivide(y0, y1, y2, y3, p, tmpSegY), 
            x0 = tmpSegX[3], y0 = tmpSegY[3], newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0), 
            x1 = tmpSegX[5], y1 = tmpSegY[5], x2 = tmpSegX[6], y2 = tmpSegY[6];
        }
        remained -= actualSubDivCount - 1;
    }
    return shorterPath === subpath1 ? [ newSubpath, subpath2 ] : [ subpath1, newSubpath ];
}

function createSubpath(lastSubpath, otherSubpath) {
    const prevSubPath = lastSubpath || otherSubpath, len = prevSubPath.length, lastX = prevSubPath[len - 2], lastY = prevSubPath[len - 1], newSubpath = [];
    for (let i = 0; i < otherSubpath.length; i += 2) newSubpath[i] = lastX, newSubpath[i + 1] = lastY;
    return newSubpath;
}

function reverseSubpath(array) {
    const newArr = [], len = array.length;
    for (let i = 0; i < len; i += 2) newArr[i] = array[len - i - 2], newArr[i + 1] = array[len - i - 1];
    return newArr;
}

function centroidOfSubpath(array) {
    let signedArea = 0, cx = 0, cy = 0;
    const len = array.length;
    for (let i = 0, j = len - 2; i < len; j = i, i += 2) {
        const x0 = array[j], y0 = array[j + 1], x1 = array[i], y1 = array[i + 1], a = x0 * y1 - x1 * y0;
        signedArea += a, cx += (x0 + x1) * a, cy += (y0 + y1) * a;
    }
    return 0 === signedArea ? [ array[0] || 0, array[1] || 0, 0 ] : [ cx / signedArea / 3, cy / signedArea / 3, signedArea ];
}

function findBestRotationOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
    const bezierCount = (fromSubBeziers.length - 2) / 6;
    let bestScore = 1 / 0, bestOffset = 0;
    const len = fromSubBeziers.length, len2 = len - 2;
    for (let offset = 0; offset < bezierCount; offset++) {
        const cursorOffset = 6 * offset;
        let score = 0;
        for (let k = 0; k < len; k += 2) {
            const idx = 0 === k ? cursorOffset : (cursorOffset + k - 2) % len2 + 2, x0 = fromSubBeziers[idx] - fromCp[0], y0 = fromSubBeziers[idx + 1] - fromCp[1], dx = toSubBeziers[k] - toCp[0] - x0, dy = toSubBeziers[k + 1] - toCp[1] - y0;
            score += dx * dx + dy * dy;
        }
        score < bestScore && (bestScore = score, bestOffset = offset);
    }
    return bestOffset;
}

function findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {
    const result = [];
    let fromNeedsReverse;
    for (let i = 0; i < fromArr.length; i++) {
        let fromSubpathBezier = fromArr[i];
        const toSubpathBezier = toArr[i], fromCp = centroidOfSubpath(fromSubpathBezier), toCp = centroidOfSubpath(toSubpathBezier);
        null == fromNeedsReverse && (fromNeedsReverse = fromCp[2] < 0 != toCp[2] < 0);
        const newFromSubpathBezier = [], newToSubpathBezier = [];
        let bestAngle = 0, bestScore = 1 / 0;
        const tmpArr = [], len = fromSubpathBezier.length;
        fromNeedsReverse && (fromSubpathBezier = reverseSubpath(fromSubpathBezier));
        const offset = 6 * findBestRotationOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp), len2 = len - 2;
        for (let k = 0; k < len2; k += 2) {
            const idx = (offset + k) % len2 + 2;
            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0], newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
        }
        if (newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0], newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1], 
        searchAngleIteration > 0) {
            const step = searchAngleRange / searchAngleIteration;
            for (let angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
                const sa = Math.sin(angle), ca = Math.cos(angle);
                let score = 0;
                for (let k = 0; k < fromSubpathBezier.length; k += 2) {
                    const x0 = newFromSubpathBezier[k], y0 = newFromSubpathBezier[k + 1], x1 = toSubpathBezier[k] - toCp[0], y1 = toSubpathBezier[k + 1] - toCp[1], newX1 = x1 * ca - y1 * sa, newY1 = x1 * sa + y1 * ca;
                    tmpArr[k] = newX1, tmpArr[k + 1] = newY1;
                    const dx = newX1 - x0, dy = newY1 - y0;
                    score += dx * dx + dy * dy;
                }
                if (score < bestScore) {
                    bestScore = score, bestAngle = angle;
                    for (let m = 0; m < tmpArr.length; m++) newToSubpathBezier[m] = tmpArr[m];
                }
            }
        } else for (let i = 0; i < len; i += 2) newToSubpathBezier[i] = toSubpathBezier[i] - toCp[0], 
        newToSubpathBezier[i + 1] = toSubpathBezier[i + 1] - toCp[1];
        result.push({
            from: newFromSubpathBezier,
            to: newToSubpathBezier,
            fromCp: fromCp,
            toCp: toCp,
            rotation: -bestAngle
        });
    }
    return result;
}

function alignBezierCurves(array1, array2) {
    let lastSubpath1, lastSubpath2;
    const newArray1 = [], newArray2 = [];
    for (let i = 0; i < Math.max(array1.length, array2.length); i++) {
        const subpath1 = array1[i], subpath2 = array2[i];
        let newSubpath1, newSubpath2;
        subpath1 ? subpath2 ? ([newSubpath1, newSubpath2] = alignSubpath(subpath1, subpath2), 
        lastSubpath1 = newSubpath1, lastSubpath2 = newSubpath2) : (newSubpath2 = createSubpath(lastSubpath2, subpath1), 
        newSubpath1 = subpath1) : (newSubpath1 = createSubpath(lastSubpath1, subpath2), 
        newSubpath2 = subpath2), newArray1.push(newSubpath1), newArray2.push(newSubpath2);
    }
    return [ newArray1, newArray2 ];
}

exports.cubicSubdivide = cubicSubdivide, exports.alignSubpath = alignSubpath, exports.centroidOfSubpath = centroidOfSubpath, 
exports.findBestMorphingRotation = findBestMorphingRotation, exports.alignBezierCurves = alignBezierCurves;

const addLineToBezierPath = (bezierPath, x0, y0, x1, y1) => {
    (0, vutils_1.isNumberClose)(x0, x1) && (0, vutils_1.isNumberClose)(y0, y1) || bezierPath.push(x0, y0, x1, y1, x1, y1);
};

function pathToBezierCurves(path) {
    const commandList = path.commandList, bezierArrayGroups = [];
    let currentSubpath, xi = 0, yi = 0, x0 = 0, y0 = 0;
    const createNewSubpath = (x, y) => {
        currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), 
        currentSubpath = [ x, y ];
    };
    let x1, y1, x2, y2;
    for (let i = 0, len = commandList.length; i < len; i++) {
        const cmd = commandList[i], isFirst = 0 === i;
        switch (isFirst && (x0 = xi = cmd[1], y0 = yi = cmd[2], [ path_svg_1.enumCommandMap.L, path_svg_1.enumCommandMap.C, path_svg_1.enumCommandMap.Q ].includes(cmd[0]) && (currentSubpath = [ x0, y0 ])), 
        cmd[0]) {
          case path_svg_1.enumCommandMap.M:
            xi = x0 = cmd[1], yi = y0 = cmd[2], createNewSubpath(x0, y0);
            break;

          case path_svg_1.enumCommandMap.L:
            x1 = cmd[1], y1 = cmd[2], addLineToBezierPath(currentSubpath, xi, yi, x1, y1), xi = x1, 
            yi = y1;
            break;

          case path_svg_1.enumCommandMap.C:
            currentSubpath.push(cmd[1], cmd[2], cmd[3], cmd[4], xi = cmd[5], yi = cmd[6]);
            break;

          case path_svg_1.enumCommandMap.Q:
            x1 = cmd[1], y1 = cmd[2], x2 = cmd[3], y2 = cmd[4], currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2), 
            xi = x2, yi = y2;
            break;

          case path_svg_1.enumCommandMap.A:
            {
                const cx = cmd[1], cy = cmd[2], rx = cmd[3], ry = rx, startAngle = cmd[4], endAngle = cmd[5], counterClockwise = !!cmd[6];
                x1 = Math.cos(startAngle) * rx + cx, y1 = Math.sin(startAngle) * rx + cy, isFirst ? (x0 = x1, 
                y0 = y1, createNewSubpath(x0, y0)) : addLineToBezierPath(currentSubpath, xi, yi, x1, y1), 
                xi = Math.cos(endAngle) * rx + cx, yi = Math.sin(endAngle) * rx + cy;
                const step = (counterClockwise ? -1 : 1) * Math.PI / 2;
                for (let angle = startAngle; counterClockwise ? angle > endAngle : angle < endAngle; angle += step) {
                    const nextAngle = counterClockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
                    (0, arc_1.addArcToBezierPath)(currentSubpath, angle, nextAngle, cx, cy, rx, ry);
                }
                break;
            }

          case path_svg_1.enumCommandMap.E:
            {
                const cx = cmd[1], cy = cmd[2], rx = cmd[3], ry = cmd[4], rotate = cmd[5], startAngle = cmd[6], endAngle = cmd[7] + startAngle, anticlockwise = !!cmd[8], hasRotate = !(0, 
                vutils_1.isNumberClose)(rotate, 0), rc = Math.cos(rotate), rs = Math.sin(rotate);
                let xTemp = Math.cos(startAngle) * rx, yTemp = Math.sin(startAngle) * ry;
                hasRotate ? (x1 = xTemp * rc - yTemp * rs + cx, y1 = xTemp * rs + yTemp * rc + cy) : (x1 = xTemp + cx, 
                y1 = yTemp + cy), isFirst ? (x0 = x1, y0 = y1, createNewSubpath(x0, y0)) : addLineToBezierPath(currentSubpath, xi, yi, x1, y1), 
                xTemp = Math.cos(endAngle) * rx, yTemp = Math.sin(endAngle) * ry, hasRotate ? (xi = xTemp * rc - yTemp * rs + cx, 
                yi = xTemp * rs + yTemp * rc + cy) : (xi = xTemp + cx, yi = yTemp + cy);
                const step = (anticlockwise ? -1 : 1) * Math.PI / 2;
                for (let angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
                    const nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
                    if ((0, arc_1.addArcToBezierPath)(currentSubpath, angle, nextAngle, cx, cy, rx, ry), 
                    hasRotate) {
                        const curLen = currentSubpath.length;
                        for (let j = curLen - 6; j <= curLen - 1; j += 2) xTemp = currentSubpath[j], yTemp = currentSubpath[j + 1], 
                        currentSubpath[j] = (xTemp - cx) * rc - (yTemp - cy) * rs + cx, currentSubpath[j + 1] = (xTemp - cx) * rs + (yTemp - cy) * rc + cy;
                    }
                }
                break;
            }

          case path_svg_1.enumCommandMap.R:
            x0 = xi = cmd[1], y0 = yi = cmd[2], x1 = x0 + cmd[3], y1 = y0 + cmd[4], createNewSubpath(x1, y0), 
            addLineToBezierPath(currentSubpath, x1, y0, x1, y1), addLineToBezierPath(currentSubpath, x1, y1, x0, y1), 
            addLineToBezierPath(currentSubpath, x0, y1, x0, y0), addLineToBezierPath(currentSubpath, x0, y0, x1, y0);
            break;

          case path_svg_1.enumCommandMap.AT:
            {
                const tx1 = cmd[1], ty1 = cmd[2], tx2 = cmd[3], ty2 = cmd[4], r = cmd[5], dis1 = vutils_1.PointService.distancePP({
                    x: xi,
                    y: yi
                }, {
                    x: tx1,
                    y: ty1
                }), dis2 = vutils_1.PointService.distancePP({
                    x: tx2,
                    y: ty2
                }, {
                    x: tx1,
                    y: ty1
                }), theta = ((xi - tx1) * (tx2 - tx1) + (yi - ty1) * (ty2 - ty1)) / (dis1 * dis2), dis = r / Math.sin(theta / 2), midX = (xi + tx2 - 2 * tx1) / 2, midY = (yi + ty2 - 2 * ty1) / 2, midLen = vutils_1.PointService.distancePP({
                    x: midX,
                    y: midY
                }, {
                    x: 0,
                    y: 0
                }), cx = tx1 + dis * midX / midLen, cy = tx2 + dis * midY / midLen, disP = Math.sqrt(dis * dis - r * r);
                x0 = tx1 + disP * (xi - tx1) / dis1, y0 = ty1 + disP * (yi - ty1) / dis1, addLineToBezierPath(currentSubpath, xi, yi, x0, y0), 
                xi = tx1 + disP * (tx2 - tx1) / dis2, yi = ty1 + disP * (ty2 - ty1) / dis2;
                const startAngle = (0, vutils_1.getAngleByPoint)({
                    x: cx,
                    y: cy
                }, {
                    x: x0,
                    y: y0
                }), endAngle = (0, vutils_1.getAngleByPoint)({
                    x: cx,
                    y: cy
                }, {
                    x: xi,
                    y: yi
                });
                (0, arc_1.addArcToBezierPath)(currentSubpath, startAngle, endAngle, cx, cy, r, r);
                break;
            }

          case path_svg_1.enumCommandMap.Z:
            currentSubpath && addLineToBezierPath(currentSubpath, xi, yi, x0, y0), xi = x0, 
            yi = y0;
        }
    }
    return currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), 
    bezierArrayGroups;
}

function applyTransformOnBezierCurves(bezierCurves, martrix) {
    for (let i = 0; i < bezierCurves.length; i++) {
        const subPath = bezierCurves[i];
        for (let k = 0; k < subPath.length; k += 2) {
            const x = subPath[k], y = subPath[k + 1], res = {
                x: x,
                y: y
            };
            martrix.transformPoint({
                x: x,
                y: y
            }, res), subPath[k] = res.x, subPath[k + 1] = res.y;
        }
    }
}

function bezierCurversToPath(bezierCurves) {
    const path = new custom_path2d_1.CustomPath2D;
    for (let i = 0; i < bezierCurves.length; i++) {
        const subPath = bezierCurves[i];
        if (subPath.length > 2) {
            path.moveTo(subPath[0], subPath[1]);
            for (let k = 2; k < subPath.length; k += 6) path.bezierCurveTo(subPath[k], subPath[k + 1], subPath[k + 2], subPath[k + 3], subPath[k + 4], subPath[k + 5]);
        }
    }
    return path;
}

exports.pathToBezierCurves = pathToBezierCurves, exports.applyTransformOnBezierCurves = applyTransformOnBezierCurves, 
exports.bezierCurversToPath = bezierCurversToPath;
//# sourceMappingURL=morphing-utils.js.map
}, function(modId) { var map = {"./custom-path2d":1689069767681,"./path-svg":1689069767684,"./shape/arc":1689069767686}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767740, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.colorStringInterpolationToStr = exports.interpolatePureColorArray = exports.interpolateGradientConicalColor = exports.interpolateGradientRadialColor = exports.interpolateGradientLinearColor = exports.interpolateColor = void 0;

const index_1 = require("./index");

function colorArrayToString(color, alphaChannel = !1) {
    return Array.isArray(color) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;
}

function interpolateColor(from, to, ratio, alphaChannel, cb) {
    if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || !1;
    let fromArray, toArray, fromGradient = !1, toGradient = !1;
    if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = index_1.ColorStore.Get(from, index_1.ColorType.Color255) : fromGradient = !0, 
    Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = index_1.ColorStore.Get(to, index_1.ColorType.Color255) : toGradient = !0, 
    fromGradient !== toGradient) {
        const gradient = fromGradient ? from : to, pure = fromGradient ? to : from, gradientFromPure = Object.assign(Object.assign({}, gradient), {
            stops: gradient.stops.map((v => Object.assign(Object.assign({}, v), {
                color: colorArrayToString(pure)
            })))
        });
        return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
    }
    if (fromGradient) {
        if (from.gradient === to.gradient) {
            const fc = from, tc = to, fromStops = fc.stops, toStops = tc.stops;
            if (fromStops.length !== toStops.length) return !1;
            if ("linear" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);
            if ("radial" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);
            if ("conical" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);
        }
        return !1;
    }
    cb && cb(fromArray, toArray);
    return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
}

function interpolateGradientLinearColor(fc, tc, ratio) {
    const fStops = fc.stops, tStops = tc.stops;
    return {
        gradient: "linear",
        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
        stops: new Array(fStops.length).fill(0).map(((_, i) => ({
            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        })))
    };
}

function interpolateGradientRadialColor(fc, tc, ratio) {
    const fStops = fc.stops, tStops = tc.stops;
    return {
        gradient: "radial",
        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
        r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
        r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
        stops: new Array(fStops.length).fill(0).map(((_, i) => ({
            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        })))
    };
}

function interpolateGradientConicalColor(fc, tc, ratio) {
    const fStops = fc.stops, tStops = tc.stops;
    return {
        gradient: "conical",
        startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
        endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
        x: fc.x + (tc.x - fc.x) * ratio,
        y: fc.y + (tc.y - fc.y) * ratio,
        stops: new Array(fStops.length).fill(0).map(((_, i) => ({
            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        })))
    };
}

function interpolatePureColorArray(from, to, ratio) {
    return [ from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio ];
}

exports.interpolateColor = interpolateColor, exports.interpolateGradientLinearColor = interpolateGradientLinearColor, 
exports.interpolateGradientRadialColor = interpolateGradientRadialColor, exports.interpolateGradientConicalColor = interpolateGradientConicalColor, 
exports.interpolatePureColorArray = interpolatePureColorArray;

const _fromColorRGB = [ 0, 0, 0, 0 ], _toColorRGB = [ 0, 0, 0, 0 ];

function colorStringInterpolationToStr(fromColor, toColor, ratio) {
    return index_1.ColorStore.Get(fromColor, index_1.ColorType.Color255, _fromColorRGB), 
    index_1.ColorStore.Get(toColor, index_1.ColorType.Color255, _toColorRGB), `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
}

exports.colorStringInterpolationToStr = colorStringInterpolationToStr;
//# sourceMappingURL=interpolate.js.map
}, function(modId) { var map = {"./index":1689069767741}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767741, function(require, module, exports) {


var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ColorStore = exports.ColorType = exports.colorEqual = exports.colorString = void 0;

const vutils_1 = require("@visactor/vutils"), colorName_1 = __importDefault(require("./colorName")), reverseNames = {};

for (const name in colorName_1.default) (0, vutils_1.has)(colorName_1.default, name) && (reverseNames[colorName_1.default[name]] = name);

const cs = {
    to: {},
    get: {}
};

function clamp(num, min, max) {
    return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
    const str = num.toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
}

function colorEqual(color1, color2) {
    const {value: c1 = [ 0, 0, 0, 0 ]} = cs.get(color1) || {}, {value: c2 = [ 0, 0, 0, 0 ]} = cs.get(color2) || {};
    return c1.every(((item, index) => item === c2[index]));
}

var ColorType;

cs.get = function(str, arr = [ 0, 0, 0, 1 ]) {
    let val, model;
    switch (str.substring(0, 3).toLowerCase()) {
      case "hsl":
        val = cs.get.hsl(str, arr), model = "hsl";
        break;

      case "hwb":
        val = cs.get.hwb(str, arr), model = "hwb";
        break;

      default:
        val = cs.get.rgb(str, arr), model = "rgb";
    }
    return val ? {
        model: model,
        value: val
    } : null;
}, cs.get.rgb = function(str, arr = [ 0, 0, 0, 1 ]) {
    if (!str) return null;
    const rgb = arr;
    let match, i, hexAlpha;
    if (match = str.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)) {
        for (hexAlpha = match[2], match = match[1], i = 0; i < 3; i++) {
            const i2 = 2 * i;
            rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        hexAlpha && (rgb[3] = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100);
    } else if (match = str.match(/^#([a-f0-9]{3,4})$/i)) {
        for (match = match[1], hexAlpha = match[3], i = 0; i < 3; i++) rgb[i] = parseInt(match[i] + match[i], 16);
        hexAlpha && (rgb[3] = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100);
    } else if (match = str.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/)) {
        for (i = 0; i < 3; i++) rgb[i] = parseInt(match[i + 1], 10);
        match[4] && (rgb[3] = parseFloat(match[4]));
    } else {
        if (!(match = str.match(/^rgba?\(\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/))) {
            if (match = str.match(/(\D+)/)) {
                if ("transparent" === match[1]) return [ 0, 0, 0, 0 ];
                const _color = colorName_1.default[match[1]];
                return rgb[0] = _color[0], rgb[1] = _color[1], rgb[2] = _color[2], rgb[3] = _color[3], 
                rgb ? (rgb[3] = 1, rgb) : null;
            }
            return null;
        }
        for (i = 0; i < 3; i++) rgb[i] = Math.round(2.55 * parseFloat(match[i + 1]));
        match[4] && (rgb[3] = parseFloat(match[4]));
    }
    for (i = 0; i < 3; i++) rgb[i] = clamp(rgb[i], 0, 255);
    return rgb[3] = clamp(rgb[3], 0, 1), rgb;
}, cs.get.hsl = function(str, arr = [ 0, 0, 0, 1 ]) {
    if (!str) return null;
    const match = str.match(/^hsla?\(\s*([+-]?(?:\d*\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/);
    if (match) {
        const alpha = parseFloat(match[4]);
        return arr[0] = (parseFloat(match[1]) + 360) % 360, arr[1] = clamp(parseFloat(match[2]), 0, 100), 
        arr[2] = clamp(parseFloat(match[3]), 0, 100), arr[3] = clamp(isNaN(alpha) ? 1 : alpha, 0, 1), 
        arr;
    }
    return null;
}, cs.get.hwb = function(str, arr = [ 0, 0, 0, 1 ]) {
    if (!str) return null;
    const match = str.match(/^hwb\(\s*([+-]?\d*[.]?\d+)(?:deg)?\s*,\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/);
    if (match) {
        const alpha = parseFloat(match[4]);
        return arr[0] = (parseFloat(match[1]) % 360 + 360) % 360, arr[1] = clamp(parseFloat(match[2]), 0, 100), 
        arr[2] = clamp(parseFloat(match[3]), 0, 100), arr[3] = clamp(isNaN(alpha) ? 1 : alpha, 0, 1), 
        arr;
    }
    return null;
}, cs.to.hex = function(...args) {
    const rgba = args;
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(255 * rgba[3])) : "");
}, cs.to.rgb = function(...args) {
    const rgba = args;
    return rgba.length < 4 || 1 === rgba[3] ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
}, cs.to.rgb.percent = function(...args) {
    const rgba = args, r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || 1 === rgba[3] ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
}, cs.to.hsl = function(...args) {
    const hsla = args;
    return hsla.length < 4 || 1 === hsla[3] ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
}, cs.to.hwb = function(...args) {
    const hwba = args;
    let a = "";
    return hwba.length >= 4 && 1 !== hwba[3] && (a = ", " + hwba[3]), "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
}, cs.to.keyword = function(rgb) {
    return reverseNames[rgb.slice(0, 3)];
}, exports.default = cs, exports.colorString = cs, exports.colorEqual = colorEqual, 
function(ColorType) {
    ColorType[ColorType.Color255 = 0] = "Color255", ColorType[ColorType.Color1 = 1] = "Color1";
}(ColorType = exports.ColorType || (exports.ColorType = {}));

class ColorStore {
    static Get(str, size = ColorType.Color1, arr = [ 0, 0, 0, 1 ]) {
        if (size === ColorType.Color1) {
            let color = ColorStore.store1[str];
            if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], 
            arr;
            if (color = cs.get(str), color && color.value) {
                const value = color.value, data = [ value[0] / 255, value[1] / 255, value[2] / 255, value[3] ];
                ColorStore.store1[str] = data, ColorStore.store255[str] = value, arr[0] = data[0], 
                arr[1] = data[1], arr[2] = data[2], arr[3] = data[3];
            }
            return arr;
        }
        let color = ColorStore.store255[str];
        if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], 
        arr;
        if (color = cs.get(str), color && color.value) {
            const value = color.value;
            ColorStore.store1[str] = [ value[0] / 255, value[1] / 255, value[2] / 255, value[3] ], 
            ColorStore.store255[str] = value, arr[0] = value[0], arr[1] = value[1], arr[2] = value[2], 
            arr[3] = value[3];
        }
        return arr;
    }
    static Set(str, size, arr) {
        if (size === ColorType.Color1) {
            if (ColorStore.store1[str]) return;
            ColorStore.store1[str] = arr, ColorStore.store255[str] = [ Math.floor(255 * arr[0]), Math.floor(255 * arr[1]), Math.floor(255 * arr[2]), Math.floor(255 * arr[3]) ];
        } else {
            if (ColorStore.store255[str]) return;
            ColorStore.store255[str] = arr, ColorStore.store1[str] = [ arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3] ];
        }
    }
}

exports.ColorStore = ColorStore, ColorStore.store255 = {}, ColorStore.store1 = {};
//# sourceMappingURL=index.js.map
}, function(modId) { var map = {"./colorName":1689069767742}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767742, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.default = {
    aliceblue: [ 240, 248, 255 ],
    antiquewhite: [ 250, 235, 215 ],
    aqua: [ 0, 255, 255 ],
    aquamarine: [ 127, 255, 212 ],
    azure: [ 240, 255, 255 ],
    beige: [ 245, 245, 220 ],
    bisque: [ 255, 228, 196 ],
    black: [ 0, 0, 0 ],
    blanchedalmond: [ 255, 235, 205 ],
    blue: [ 0, 0, 255 ],
    blueviolet: [ 138, 43, 226 ],
    brown: [ 165, 42, 42 ],
    burlywood: [ 222, 184, 135 ],
    cadetblue: [ 95, 158, 160 ],
    chartreuse: [ 127, 255, 0 ],
    chocolate: [ 210, 105, 30 ],
    coral: [ 255, 127, 80 ],
    cornflowerblue: [ 100, 149, 237 ],
    cornsilk: [ 255, 248, 220 ],
    crimson: [ 220, 20, 60 ],
    cyan: [ 0, 255, 255 ],
    darkblue: [ 0, 0, 139 ],
    darkcyan: [ 0, 139, 139 ],
    darkgoldenrod: [ 184, 134, 11 ],
    darkgray: [ 169, 169, 169 ],
    darkgreen: [ 0, 100, 0 ],
    darkgrey: [ 169, 169, 169 ],
    darkkhaki: [ 189, 183, 107 ],
    darkmagenta: [ 139, 0, 139 ],
    darkolivegreen: [ 85, 107, 47 ],
    darkorange: [ 255, 140, 0 ],
    darkorchid: [ 153, 50, 204 ],
    darkred: [ 139, 0, 0 ],
    darksalmon: [ 233, 150, 122 ],
    darkseagreen: [ 143, 188, 143 ],
    darkslateblue: [ 72, 61, 139 ],
    darkslategray: [ 47, 79, 79 ],
    darkslategrey: [ 47, 79, 79 ],
    darkturquoise: [ 0, 206, 209 ],
    darkviolet: [ 148, 0, 211 ],
    deeppink: [ 255, 20, 147 ],
    deepskyblue: [ 0, 191, 255 ],
    dimgray: [ 105, 105, 105 ],
    dimgrey: [ 105, 105, 105 ],
    dodgerblue: [ 30, 144, 255 ],
    firebrick: [ 178, 34, 34 ],
    floralwhite: [ 255, 250, 240 ],
    forestgreen: [ 34, 139, 34 ],
    fuchsia: [ 255, 0, 255 ],
    gainsboro: [ 220, 220, 220 ],
    ghostwhite: [ 248, 248, 255 ],
    gold: [ 255, 215, 0 ],
    goldenrod: [ 218, 165, 32 ],
    gray: [ 128, 128, 128 ],
    green: [ 0, 128, 0 ],
    greenyellow: [ 173, 255, 47 ],
    grey: [ 128, 128, 128 ],
    honeydew: [ 240, 255, 240 ],
    hotpink: [ 255, 105, 180 ],
    indianred: [ 205, 92, 92 ],
    indigo: [ 75, 0, 130 ],
    ivory: [ 255, 255, 240 ],
    khaki: [ 240, 230, 140 ],
    lavender: [ 230, 230, 250 ],
    lavenderblush: [ 255, 240, 245 ],
    lawngreen: [ 124, 252, 0 ],
    lemonchiffon: [ 255, 250, 205 ],
    lightblue: [ 173, 216, 230 ],
    lightcoral: [ 240, 128, 128 ],
    lightcyan: [ 224, 255, 255 ],
    lightgoldenrodyellow: [ 250, 250, 210 ],
    lightgray: [ 211, 211, 211 ],
    lightgreen: [ 144, 238, 144 ],
    lightgrey: [ 211, 211, 211 ],
    lightpink: [ 255, 182, 193 ],
    lightsalmon: [ 255, 160, 122 ],
    lightseagreen: [ 32, 178, 170 ],
    lightskyblue: [ 135, 206, 250 ],
    lightslategray: [ 119, 136, 153 ],
    lightslategrey: [ 119, 136, 153 ],
    lightsteelblue: [ 176, 196, 222 ],
    lightyellow: [ 255, 255, 224 ],
    lime: [ 0, 255, 0 ],
    limegreen: [ 50, 205, 50 ],
    linen: [ 250, 240, 230 ],
    magenta: [ 255, 0, 255 ],
    maroon: [ 128, 0, 0 ],
    mediumaquamarine: [ 102, 205, 170 ],
    mediumblue: [ 0, 0, 205 ],
    mediumorchid: [ 186, 85, 211 ],
    mediumpurple: [ 147, 112, 219 ],
    mediumseagreen: [ 60, 179, 113 ],
    mediumslateblue: [ 123, 104, 238 ],
    mediumspringgreen: [ 0, 250, 154 ],
    mediumturquoise: [ 72, 209, 204 ],
    mediumvioletred: [ 199, 21, 133 ],
    midnightblue: [ 25, 25, 112 ],
    mintcream: [ 245, 255, 250 ],
    mistyrose: [ 255, 228, 225 ],
    moccasin: [ 255, 228, 181 ],
    navajowhite: [ 255, 222, 173 ],
    navy: [ 0, 0, 128 ],
    oldlace: [ 253, 245, 230 ],
    olive: [ 128, 128, 0 ],
    olivedrab: [ 107, 142, 35 ],
    orange: [ 255, 165, 0 ],
    orangered: [ 255, 69, 0 ],
    orchid: [ 218, 112, 214 ],
    palegoldenrod: [ 238, 232, 170 ],
    palegreen: [ 152, 251, 152 ],
    paleturquoise: [ 175, 238, 238 ],
    palevioletred: [ 219, 112, 147 ],
    papayawhip: [ 255, 239, 213 ],
    peachpuff: [ 255, 218, 185 ],
    peru: [ 205, 133, 63 ],
    pink: [ 255, 192, 203 ],
    plum: [ 221, 160, 221 ],
    powderblue: [ 176, 224, 230 ],
    purple: [ 128, 0, 128 ],
    rebeccapurple: [ 102, 51, 153 ],
    red: [ 255, 0, 0 ],
    rosybrown: [ 188, 143, 143 ],
    royalblue: [ 65, 105, 225 ],
    saddlebrown: [ 139, 69, 19 ],
    salmon: [ 250, 128, 114 ],
    sandybrown: [ 244, 164, 96 ],
    seagreen: [ 46, 139, 87 ],
    seashell: [ 255, 245, 238 ],
    sienna: [ 160, 82, 45 ],
    silver: [ 192, 192, 192 ],
    skyblue: [ 135, 206, 235 ],
    slateblue: [ 106, 90, 205 ],
    slategray: [ 112, 128, 144 ],
    slategrey: [ 112, 128, 144 ],
    snow: [ 255, 250, 250 ],
    springgreen: [ 0, 255, 127 ],
    steelblue: [ 70, 130, 180 ],
    tan: [ 210, 180, 140 ],
    teal: [ 0, 128, 128 ],
    thistle: [ 216, 191, 216 ],
    tomato: [ 255, 99, 71 ],
    turquoise: [ 64, 224, 208 ],
    violet: [ 238, 130, 238 ],
    wheat: [ 245, 222, 179 ],
    white: [ 255, 255, 255 ],
    whitesmoke: [ 245, 245, 245 ],
    yellow: [ 255, 255, 0 ],
    yellowgreen: [ 154, 205, 50 ]
};
//# sourceMappingURL=colorName.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767743, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ResourceLoader = void 0;

const application_1 = require("../application");

class ResourceLoader {
    static GetImage(url, mark) {
        var _a;
        let data = ResourceLoader.cache.get(url);
        data ? "fail" === data.loadState ? application_1.application.global.getRequestAnimationFrame()((() => {
            mark.imageLoadFail(url);
        })) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && application_1.application.global.getRequestAnimationFrame()((() => {
            mark.imageLoadSuccess(url, data.data);
        })) : (data = {
            type: "image",
            loadState: "init"
        }, ResourceLoader.cache.set(url, data), data.dataPromise = application_1.application.global.loadImage(url), 
        data.dataPromise ? (data.waitingMark = [ mark ], data.dataPromise.then((res => {
            var _a;
            data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, 
            null === (_a = data.waitingMark) || void 0 === _a || _a.map(((mark, index) => {
                (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, 
                mark.imageLoadSuccess(url, res.data)) : (data.loadState = "fail", mark.imageLoadFail(url));
            }));
        }))) : (data.loadState = "fail", mark.imageLoadFail(url)));
    }
    static GetSvg(svgStr, mark) {
        var _a;
        let data = ResourceLoader.cache.get(svgStr);
        data ? "fail" === data.loadState ? application_1.application.global.getRequestAnimationFrame()((() => {
            mark.imageLoadFail(svgStr);
        })) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && application_1.application.global.getRequestAnimationFrame()((() => {
            mark.imageLoadSuccess(svgStr, data.data);
        })) : (data = {
            type: "image",
            loadState: "init"
        }, ResourceLoader.cache.set(svgStr, data), data.dataPromise = application_1.application.global.loadSvg(svgStr), 
        data.dataPromise ? (data.waitingMark = [ mark ], data.dataPromise.then((res => {
            var _a;
            data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, 
            null === (_a = data.waitingMark) || void 0 === _a || _a.map(((mark, index) => {
                (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, 
                mark.imageLoadSuccess(svgStr, res.data)) : (data.loadState = "fail", mark.imageLoadFail(svgStr));
            }));
        }))) : (data.loadState = "fail", mark.imageLoadFail(svgStr)));
    }
    static GetFile(url, type) {
        let data = ResourceLoader.cache.get(url);
        return data ? "init" === data.loadState || "fail" === data.loadState ? Promise.reject() : "loading" === data.loadState ? data.dataPromise.then((data => data.data)) : Promise.resolve(data.data) : (data = {
            type: type,
            loadState: "init"
        }, ResourceLoader.cache.set(url, data), "arrayBuffer" === type ? data.dataPromise = application_1.application.global.loadArrayBuffer(url) : "blob" === type ? data.dataPromise = application_1.application.global.loadBlob(url) : "json" === type && (data.dataPromise = application_1.application.global.loadJson(url)), 
        data.dataPromise.then((data => data.data)));
    }
}

exports.ResourceLoader = ResourceLoader, ResourceLoader.cache = new Map;
//# sourceMappingURL=loader.js.map

}, function(modId) { var map = {"../application":1689069767703}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767744, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.GraphicCreator = exports.GraphicService = exports.TEXT_NUMBER_TYPE = exports.SYMBOL_NUMBER_TYPE = exports.RICHTEXT_NUMBER_TYPE = exports.RECT3D_NUMBER_TYPE = exports.RECT_NUMBER_TYPE = exports.PYRAMID3D_NUMBER_TYPE = exports.POLYGON_NUMBER_TYPE = exports.PATH_NUMBER_TYPE = exports.LINE_NUMBER_TYPE = exports.IMAGE_NUMBER_TYPE = exports.GROUP_NUMBER_TYPE = exports.GLYPH_NUMBER_TYPE = exports.CIRCLE_NUMBER_TYPE = exports.AREA_NUMBER_TYPE = exports.ARC3D_NUMBER_TYPE = exports.ARC_NUMBER_TYPE = void 0;

const tools_1 = require("./tools");

exports.ARC_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.ARC3D_NUMBER_TYPE = (0, 
tools_1.genNumberType)(), exports.AREA_NUMBER_TYPE = (0, tools_1.genNumberType)(), 
exports.CIRCLE_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.GLYPH_NUMBER_TYPE = (0, 
tools_1.genNumberType)(), exports.GROUP_NUMBER_TYPE = (0, tools_1.genNumberType)(), 
exports.IMAGE_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.LINE_NUMBER_TYPE = (0, 
tools_1.genNumberType)(), exports.PATH_NUMBER_TYPE = (0, tools_1.genNumberType)(), 
exports.POLYGON_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.PYRAMID3D_NUMBER_TYPE = (0, 
tools_1.genNumberType)(), exports.RECT_NUMBER_TYPE = (0, tools_1.genNumberType)(), 
exports.RECT3D_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.RICHTEXT_NUMBER_TYPE = (0, 
tools_1.genNumberType)(), exports.SYMBOL_NUMBER_TYPE = (0, tools_1.genNumberType)(), 
exports.TEXT_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.GraphicService = Symbol.for("GraphicService"), 
exports.GraphicCreator = Symbol.for("GraphicCreator");
//# sourceMappingURL=constants.js.map

}, function(modId) { var map = {"./tools":1689069767745}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767745, function(require, module, exports) {


var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.genNumberType = exports.boundStroke = exports.waitForAllSubLayers = exports.incrementalAddTo = void 0;

const application_1 = require("../application");

function incrementalAddTo(group, graphic) {
    group.incrementalAppendChild(graphic);
}

function waitForAllSubLayers(stage) {
    return __awaiter(this, void 0, void 0, (function*() {
        const promiseList = [], layers = stage.getChildren();
        yield new Promise((resolve => {
            application_1.application.global.getRequestAnimationFrame()((() => {
                resolve(null);
            }));
        })), layers.forEach((l => {
            l.subLayers.size && l.subLayers.forEach((sl => {
                sl.drawContribution && sl.drawContribution.hooks && sl.drawContribution.rendering && promiseList.push(new Promise((resolve => {
                    sl.drawContribution.hooks.completeDraw.tap("outWait", (() => {
                        sl.drawContribution.hooks.completeDraw.taps = sl.drawContribution.hooks.completeDraw.taps.filter((i => "outWait" !== i.name)), 
                        resolve(null);
                    }));
                })));
            }));
        })), yield Promise.all(promiseList);
    }));
}

function boundStroke(bounds, halfW, miter, pad = 0) {
    return bounds.expand(halfW + (pad / 2 + (miter ? miterAdjustment(miter, halfW) : 0))), 
    bounds;
}

function miterAdjustment(miter, strokeWidth) {
    return miter ? strokeWidth : 0;
}

exports.incrementalAddTo = incrementalAddTo, exports.waitForAllSubLayers = waitForAllSubLayers, 
exports.boundStroke = boundStroke;

let NUMBER_TYPE = 0;

function genNumberType() {
    return NUMBER_TYPE++;
}

exports.genNumberType = genNumberType;
//# sourceMappingURL=tools.js.map

}, function(modId) { var map = {"../application":1689069767703}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767746, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultWindow = exports.WindowHandlerContribution = exports.Window = void 0;

const inversify_1 = require("inversify"), generator_1 = require("../common/generator"), container_1 = require("../container"), tapable_1 = require("../tapable"), constants_1 = require("../constants");

exports.Window = Symbol.for("Window"), exports.WindowHandlerContribution = Symbol.for("WindowHandlerContribution");

let DefaultWindow = class {
    get width() {
        if (this._handler) {
            const wh = this._handler.getWH();
            return this._width = wh.width;
        }
        return this._width;
    }
    get height() {
        if (this._handler) {
            const wh = this._handler.getWH();
            return this._height = wh.height;
        }
        return this._height;
    }
    get dpr() {
        return this._handler.getDpr();
    }
    constructor(global) {
        this.global = global, this.hooks = {
            onChange: new tapable_1.SyncHook([ "x", "y", "width", "height" ])
        }, this._uid = generator_1.Generator.GenAutoIncrementId();
    }
    postInit() {
        this.global.hooks.onSetEnv.tap("window", (() => {
            this.active();
        })), this.active();
    }
    active() {
        const global = this.global;
        if (!global.env || this.actived) return;
        container_1.container.getNamed(exports.WindowHandlerContribution, global.env).configure(this, global), 
        this.actived = !0;
    }
    get style() {
        return this._handler.getStyle();
    }
    set style(style) {
        this._handler.setStyle(style);
    }
    create(params) {
        this._handler.createWindow(params);
        const windowWH = this._handler.getWH();
        this._width = windowWH.width, this._height = windowWH.height, this.title = this._handler.getTitle(), 
        this.resizable = !0;
    }
    setWindowHandler(handler) {
        this._handler = handler;
    }
    setDpr(dpr) {
        return this._handler.setDpr(dpr);
    }
    resize(w, h) {
        return this._handler.resizeWindow(w, h);
    }
    configure() {
        throw new Error("暂不支持");
    }
    release() {
        return this._handler.releaseWindow();
    }
    getContext() {
        return this._handler.getContext();
    }
    getNativeHandler() {
        return this._handler.getNativeHandler();
    }
    getImageBuffer(type) {
        return this._handler.getImageBuffer ? this._handler.getImageBuffer(type) : null;
    }
    addEventListener(type, listener, options) {
        return this._handler.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
        return this._handler.removeEventListener(type, listener, options);
    }
    dispatchEvent(event) {
        return this._handler.dispatchEvent(event);
    }
    getBoundingClientRect() {
        return this._handler.getBoundingClientRect();
    }
    getContainer() {
        return this._handler.container;
    }
    clearViewBox(viewBox, color) {
        this._handler.clearViewBox(viewBox, color);
    }
};

__decorate([ (0, inversify_1.postConstruct)(), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0) ], DefaultWindow.prototype, "postInit", null), 
DefaultWindow = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata("design:paramtypes", [ Object ]) ], DefaultWindow), 
exports.DefaultWindow = DefaultWindow;
//# sourceMappingURL=window.js.map

}, function(modId) { var map = {"../common/generator":1689069767711,"../container":1689069767702,"../tapable":1689069767673,"../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767747, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LayerService = exports.GraphicUtil = exports.TransformUtil = void 0, 
exports.TransformUtil = Symbol.for("TransformUtil"), exports.GraphicUtil = Symbol.for("GraphicUtil"), 
exports.LayerService = Symbol.for("LayerService");
//# sourceMappingURL=constants.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767748, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), render_service_1 = require("./render-service");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(render_service_1.DefaultRenderService).toSelf(), bind(render_service_1.RenderService).toService(render_service_1.DefaultRenderService);
}));
//# sourceMappingURL=render-modules.js.map

}, function(modId) { var map = {"./render-service":1689069767749}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767749, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultRenderService = exports.BeforeRenderConstribution = exports.RenderService = void 0;

const inversify_1 = require("inversify"), render_1 = require("./contributions/render");

exports.RenderService = Symbol.for("RenderService"), exports.BeforeRenderConstribution = Symbol.for("BeforeRenderConstribution");

let DefaultRenderService = class {
    constructor(drawContribution) {
        this.drawContribution = drawContribution;
    }
    prepare(updateBounds) {
        this.renderTreeRoots.forEach((g => {
            this._prepare(g, updateBounds);
        }));
    }
    _prepare(g, updateBounds) {
        g.forEachChildren((g => {
            this._prepare(g, updateBounds);
        })), g.update({
            bounds: updateBounds,
            trans: !0
        });
    }
    prepareRenderList() {}
    beforeDraw(params) {}
    draw(params) {
        this.drawContribution.draw(this, Object.assign({}, this.drawParams));
    }
    afterDraw(params) {}
    render(groups, params) {
        this.renderTreeRoots = groups, this.drawParams = params;
        const updateBounds = params.updateBounds;
        this.prepare(updateBounds), this.prepareRenderList(), this.beforeDraw(params), this.draw(params), 
        this.afterDraw(params);
    }
};

DefaultRenderService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.DrawContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultRenderService), 
exports.DefaultRenderService = DefaultRenderService;
//# sourceMappingURL=render-service.js.map

}, function(modId) { var map = {"./contributions/render":1689069767750}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767750, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./arc-render"), exports), __exportStar(require("./circle-render"), exports), 
__exportStar(require("./line-render"), exports), __exportStar(require("./area-render"), exports), 
__exportStar(require("./path-render"), exports), __exportStar(require("./rect-render"), exports), 
__exportStar(require("./symbol-render"), exports), __exportStar(require("./text-render"), exports), 
__exportStar(require("./graphic-render"), exports), __exportStar(require("./polygon-render"), exports), 
__exportStar(require("./image-render"), exports), __exportStar(require("./symbol"), exports), 
__exportStar(require("./contributions"), exports), __exportStar(require("./utils"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./arc-render":1689069767751,"./circle-render":1689069767814,"./line-render":1689069767816,"./area-render":1689069767819,"./path-render":1689069767822,"./rect-render":1689069767824,"./symbol-render":1689069767827,"./text-render":1689069767829,"./graphic-render":1689069767830,"./polygon-render":1689069767831,"./image-render":1689069767834,"./symbol":1689069767836,"./contributions":1689069767837,"./utils":1689069767752}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767751, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasArcRender = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), utils_1 = require("../../../common/utils"), contribution_provider_1 = require("../../../common/contribution-provider"), utils_2 = require("./utils"), conical_gradient_1 = require("../../../canvas/contributions/browser/conical-gradient"), arc_contribution_render_1 = require("./contributions/arc-contribution-render"), enums_1 = require("../../../common/enums"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasArcRender = class {
    constructor(arcRenderContribitions) {
        this.arcRenderContribitions = arcRenderContribitions, this.numberType = constants_1.ARC_NUMBER_TYPE;
    }
    drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
        const capAngle = _ea - _sa, data = arc.getParsedAngle(), startAngle = data.startAngle;
        let endAngle = data.endAngle;
        endAngle = _ea;
        const deltaAngle = (0, vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;
        let collapsedToLine = !1;
        if (outerRadius < innerRadius) {
            const temp = outerRadius;
            outerRadius = innerRadius, innerRadius = temp;
        }
        const cornerRadius = arc.getParsedCornerRadius(), {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadius, outerCornerRadiusEnd = cornerRadius, innerCornerRadiusEnd = cornerRadius, innerCornerRadiusStart = cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
        let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;
        const xors = outerRadius * (0, vutils_1.cos)(outerStartAngle), yors = outerRadius * (0, 
        vutils_1.sin)(outerStartAngle), xire = innerRadius * (0, vutils_1.cos)(innerEndAngle), yire = innerRadius * (0, 
        vutils_1.sin)(innerEndAngle);
        let xore, yore, xirs, yirs;
        if ((maxInnerCornerRadius > vutils_1.epsilon || maxOuterCornerRadius > vutils_1.epsilon) && (xore = outerRadius * (0, 
        vutils_1.cos)(outerEndAngle), yore = outerRadius * (0, vutils_1.sin)(outerEndAngle), 
        xirs = innerRadius * (0, vutils_1.cos)(innerStartAngle), yirs = innerRadius * (0, 
        vutils_1.sin)(innerStartAngle), deltaAngle < vutils_1.pi)) {
            const oc = (0, utils_2.intersect)(xors, yors, xirs, yirs, xore, yore, xire, yire);
            if (oc) {
                const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / (0, 
                vutils_1.sin)((0, vutils_1.acos)((ax * bx + ay * by) / ((0, vutils_1.sqrt)(ax * ax + ay * ay) * (0, 
                vutils_1.sqrt)(bx * bx + by * by))) / 2), lc = (0, vutils_1.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
                limitedIcr = (0, vutils_1.min)(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), 
                limitedOcr = (0, vutils_1.min)(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
            }
        }
        if (limitedOcr > vutils_1.epsilon) {
            const cornerRadiusStart = (0, vutils_1.min)(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = (0, 
            vutils_1.min)(outerCornerRadiusEnd, limitedOcr), t0 = (0, utils_2.cornerTangents)(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = (0, 
            utils_2.cornerTangents)(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
            if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, (0, vutils_1.atan2)(t0.y01, t0.x01), (0, 
            vutils_1.atan2)(t1.y01, t1.x01), !clockwise); else {
                const a1 = endAngle - capAngle - .03, a2 = (0, vutils_1.atan2)(t1.y11, t1.x11);
                context.arc(cx, cy, outerRadius, a1, a2, !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, (0, 
                vutils_1.atan2)(t1.y11, t1.x11), (0, vutils_1.atan2)(t1.y01, t1.x01), !clockwise);
            }
        } else context.moveTo(cx + xors, cy + yors);
        if (!(innerRadius > vutils_1.epsilon) || innerDeltaAngle < .001) context.lineTo(cx + xire, cy + yire), 
        collapsedToLine = !0; else if (limitedIcr > vutils_1.epsilon) {
            const cornerRadiusStart = (0, vutils_1.min)(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = (0, 
            vutils_1.min)(innerCornerRadiusEnd, limitedIcr), t0 = (0, utils_2.cornerTangents)(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = (0, 
            utils_2.cornerTangents)(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
            if (context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                const arcEndAngle = (0, vutils_1.atan2)(t1.y01, t1.x01);
                context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, (0, vutils_1.atan2)(t0.y01, t0.x01), arcEndAngle, !clockwise);
            } else {
                cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, (0, 
                vutils_1.atan2)(t0.y01, t0.x01), (0, vutils_1.atan2)(t0.y11, t0.x11), !clockwise);
                const a1 = (0, vutils_1.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), a2 = endAngle - capAngle - .03;
                context.arc(cx, cy, innerRadius, a1, a2, clockwise);
            }
        } else context.lineTo(cx + innerRadius * (0, vutils_1.cos)(innerStartAngle), cy + innerRadius * (0, 
        vutils_1.sin)(innerStartAngle));
        return collapsedToLine;
    }
    drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
        const arcAttribute = (0, theme_1.getTheme)(arc, null == params ? void 0 : params.theme).arc, {fill: fill = arcAttribute.fill, background: background, stroke: stroke = arcAttribute.stroke, opacity: opacity = arcAttribute.opacity, fillOpacity: fillOpacity = arcAttribute.fillOpacity, lineWidth: lineWidth = arcAttribute.lineWidth, strokeOpacity: strokeOpacity = arcAttribute.strokeOpacity, visible: visible = arcAttribute.visible, x: originX = arcAttribute.x, y: originY = arcAttribute.y} = arc.attribute, fVisible = (0, 
        utils_2.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_2.strokeVisible)(opacity, strokeOpacity), doFill = (0, 
        utils_2.runFill)(fill), doStroke = (0, utils_2.runStroke)(stroke, lineWidth);
        if (!arc.valid || !visible) return;
        if (!(doFill || doStroke || background)) return;
        if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
        const {outerRadius: outerRadius = arcAttribute.outerRadius, innerRadius: innerRadius = arcAttribute.innerRadius, cap: cap = arcAttribute.cap, forceShowCap: forceShowCap = arcAttribute.forceShowCap} = arc.attribute, {isFullStroke: isFullStroke, stroke: arrayStroke} = (0, 
        utils_1.parseStroke)(stroke);
        if ((doFill || isFullStroke) && (context.beginPath(), (0, utils_2.drawArcPath)(arc, context, x, y, outerRadius, innerRadius), 
        this._arcRenderContribitions || (this._arcRenderContribitions = this.arcRenderContribitions.getContributions() || [], 
        this._arcRenderContribitions.sort(((a, b) => b.order - a.order))), this._arcRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, fillCb, strokeCb);
        })), context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute), 
        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), 
        context.fill())), doStroke && isFullStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), 
        context.stroke()))), !isFullStroke && doStroke) {
            context.beginPath();
            (0, utils_2.drawArcPath)(arc, context, x, y, outerRadius, innerRadius, arrayStroke);
            strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), 
            context.stroke());
        }
        if (cap && forceShowCap) {
            const {startAngle: sa, endAngle: ea} = arc.getParsedAngle();
            if ((0, vutils_1.abs)(ea - sa) >= vutils_1.pi2 - vutils_1.epsilon) {
                context.beginPath();
                const capAngle = Math.abs(outerRadius - innerRadius) / 2 / outerRadius, {endAngle: endAngle = arcAttribute.endAngle, fill: fill = arcAttribute.fill} = arc.attribute, startAngle = endAngle;
                if (this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle), 
                doFill) {
                    const color = fill;
                    if ("conical" === color.gradient) {
                        const lastColor = (0, conical_gradient_1.getConicGradientAt)(0, 0, endAngle, color);
                        fillCb || utils_2.fillVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), 
                        context.fillStyle = lastColor, context.fill());
                    }
                }
                doStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), 
                context.stroke()));
            }
        }
        this._arcRenderContribitions || (this._arcRenderContribitions = this.arcRenderContribitions.getContributions() || []), 
        this._arcRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, fillCb, strokeCb);
        }));
    }
    draw(arc, renderService, drawContext, params) {
        const {context: context} = drawContext;
        if (!context) return;
        const arcAttribute = (0, theme_1.getTheme)(arc, null == params ? void 0 : params.theme).arc;
        context.highPerformanceSave();
        let {x: x = arcAttribute.x, y: y = arcAttribute.y} = arc.attribute;
        if (arc.transMatrix.onlyTranslate()) {
            const point = arc.getOffsetXY(arcAttribute);
            x += point.x, y += point.y, context.setTransformForCurrent();
        } else x = 0, y = 0, context.transformFromMatrix(arc.transMatrix, !0);
        (0, utils_2.drawPathProxy)(arc, context, x, y, drawContext, params) || this.drawShape(arc, context, x, y, drawContext, params), 
        context.highPerformanceRestore();
    }
};

DefaultCanvasArcRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(arc_contribution_render_1.ArcRenderContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasArcRender), 
exports.DefaultCanvasArcRender = DefaultCanvasArcRender;
//# sourceMappingURL=arc-render.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../common/utils":1689069767736,"../../../common/contribution-provider":1689069767672,"./utils":1689069767752,"../../../canvas/contributions/browser/conical-gradient":1689069767753,"./contributions/arc-contribution-render":1689069767754,"../../../common/enums":1689069767685,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767752, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.drawArcPath = exports.cornerTangents = exports.intersect = exports.drawPathProxy = exports.rectStrokeVisible = exports.strokeVisible = exports.rectFillVisible = exports.fillVisible = exports.runStroke = exports.runFill = void 0;

const vutils_1 = require("@visactor/vutils"), render_command_list_1 = require("../../../common/render-command-list"), theme_1 = require("../../../graphic/theme");

function runFill(fill) {
    return !!fill;
}

function runStroke(stroke, lineWidth) {
    let s;
    return s = (0, vutils_1.isArray)(stroke) ? stroke.some((item => item || void 0 === item)) : !!stroke, 
    s && lineWidth > 0;
}

function fillVisible(opacity, fillOpacity) {
    return opacity * fillOpacity > 0;
}

function rectFillVisible(opacity, fillOpacity, width, height) {
    return opacity * fillOpacity > 0 && width > 0 && height > 0;
}

function strokeVisible(opacity, strokeOpacity) {
    return opacity * strokeOpacity > 0;
}

function rectStrokeVisible(opacity, strokeOpacity, width, height) {
    return opacity * strokeOpacity > 0 && width > 0 && height > 0;
}

function drawPathProxy(graphic, context, x, y, drawContext, params, fillCb, strokeCb) {
    if (!graphic.pathProxy) return !1;
    const themeAttributes = (0, theme_1.getTheme)(graphic, null == params ? void 0 : params.theme)[graphic.type], {fill: fill = themeAttributes.fill, stroke: stroke = themeAttributes.stroke, opacity: opacity = themeAttributes.opacity, fillOpacity: fillOpacity = themeAttributes.fillOpacity, lineWidth: lineWidth = themeAttributes.lineWidth, strokeOpacity: strokeOpacity = themeAttributes.strokeOpacity, visible: visible = themeAttributes.visible} = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke, lineWidth);
    if (!visible) return !0;
    if (!doFill && !doStroke) return !0;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return !0;
    context.beginPath();
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    return (0, render_command_list_1.renderCommandList)(path.commandList, context, x, y), 
    context.setShadowStyle && context.setShadowStyle(graphic, graphic.attribute, themeAttributes), 
    doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x, y, themeAttributes), 
    context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x, y, themeAttributes), 
    context.fill())), !0;
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    const x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2;
    let t = y32 * x10 - x32 * y10;
    return t * t < vutils_1.epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, 
    [ x0 + t * x10, y0 + t * y10 ]);
}

function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
    const x01 = x0 - x1, y01 = y0 - y1, lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
    let cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2;
    const cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
    return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), 
    {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
    };
}

function drawArcPath(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = (0, 
    vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (outerRadius < innerRadius) {
        const temp = outerRadius;
        outerRadius = innerRadius, innerRadius = temp;
    }
    if (outerRadius <= vutils_1.epsilon) context.moveTo(cx, cy); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) context.moveTo(cx + outerRadius * (0, 
    vutils_1.cos)(startAngle), cy + outerRadius * (0, vutils_1.sin)(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), 
    innerRadius > vutils_1.epsilon && (context.moveTo(cx + innerRadius * (0, vutils_1.cos)(endAngle), cy + innerRadius * (0, 
    vutils_1.sin)(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise)); else {
        const cornerRadius = arc.getParsedCornerRadius(), {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadius, outerCornerRadiusEnd = cornerRadius, innerCornerRadiusEnd = cornerRadius, innerCornerRadiusStart = cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
        let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;
        const xors = outerRadius * (0, vutils_1.cos)(outerStartAngle), yors = outerRadius * (0, 
        vutils_1.sin)(outerStartAngle), xire = innerRadius * (0, vutils_1.cos)(innerEndAngle), yire = innerRadius * (0, 
        vutils_1.sin)(innerEndAngle);
        let xore, yore, xirs, yirs;
        if ((maxInnerCornerRadius > vutils_1.epsilon || maxOuterCornerRadius > vutils_1.epsilon) && (xore = outerRadius * (0, 
        vutils_1.cos)(outerEndAngle), yore = outerRadius * (0, vutils_1.sin)(outerEndAngle), 
        xirs = innerRadius * (0, vutils_1.cos)(innerStartAngle), yirs = innerRadius * (0, 
        vutils_1.sin)(innerStartAngle), deltaAngle < vutils_1.pi)) {
            const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
            if (oc) {
                const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / (0, 
                vutils_1.sin)((0, vutils_1.acos)((ax * bx + ay * by) / ((0, vutils_1.sqrt)(ax * ax + ay * ay) * (0, 
                vutils_1.sqrt)(bx * bx + by * by))) / 2), lc = (0, vutils_1.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
                limitedIcr = (0, vutils_1.min)(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), 
                limitedOcr = (0, vutils_1.min)(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
            }
        }
        if (outerDeltaAngle < .001) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), 
        collapsedToLine = !0; else if (limitedOcr > vutils_1.epsilon) {
            const cornerRadiusStart = (0, vutils_1.min)(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = (0, 
            vutils_1.min)(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
            limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, (0, vutils_1.atan2)(t0.y01, t0.x01), (0, 
            vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * (0, 
            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * (0, 
            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, (0, 
            vutils_1.atan2)(t0.y01, t0.x01), (0, vutils_1.atan2)(t0.y11, t0.x11), !clockwise), 
            context.arc(cx, cy, outerRadius, (0, vutils_1.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, 
            vutils_1.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, (0, 
            vutils_1.atan2)(t1.y11, t1.x11), (0, vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * (0, 
            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * (0, 
            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * (0, 
            vutils_1.sin)(outerEndAngle));
        } else partStroke && !partStroke[0] || (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise));
        if (!(innerRadius > vutils_1.epsilon) || innerDeltaAngle < .001) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), 
        collapsedToLine = !0; else if (limitedIcr > vutils_1.epsilon) {
            const cornerRadiusStart = (0, vutils_1.min)(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = (0, 
            vutils_1.min)(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
            if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                const arcEndAngle = (0, vutils_1.atan2)(t1.y01, t1.x01);
                !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, (0, 
                vutils_1.atan2)(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + (0, 
                vutils_1.cos)(arcEndAngle), cy + t0.cy + (0, vutils_1.sin)(arcEndAngle));
            } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, (0, 
            vutils_1.atan2)(t0.y01, t0.x01), (0, vutils_1.atan2)(t0.y11, t0.x11), !clockwise), 
            context.arc(cx, cy, innerRadius, (0, vutils_1.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, 
            vutils_1.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, (0, 
            vutils_1.atan2)(t1.y11, t1.x11), (0, vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * (0, 
            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * (0, 
            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
        } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), 
        !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * (0, 
        vutils_1.cos)(innerStartAngle), cy + innerRadius * (0, vutils_1.sin)(innerStartAngle));
    }
    return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * (0, vutils_1.cos)(endAngle), cy + outerRadius * (0, 
    vutils_1.cos)(endAngle)) : context.closePath(), collapsedToLine;
}

exports.runFill = runFill, exports.runStroke = runStroke, exports.fillVisible = fillVisible, 
exports.rectFillVisible = rectFillVisible, exports.strokeVisible = strokeVisible, 
exports.rectStrokeVisible = rectStrokeVisible, exports.drawPathProxy = drawPathProxy, 
exports.intersect = intersect, exports.cornerTangents = cornerTangents, exports.drawArcPath = drawArcPath;
//# sourceMappingURL=utils.js.map

}, function(modId) { var map = {"../../../common/render-command-list":1689069767687,"../../../graphic/theme":1689069767707}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767753, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createConicalGradient = exports.getConicGradientAt = exports.ColorInterpolate = void 0;

const vutils_1 = require("@visactor/vutils"), application_1 = require("../../../application"), interpolate_1 = require("../../../color-string/interpolate");

class ConicalCanvas {
    static GetCanvas() {
        try {
            return ConicalCanvas.canvas || (ConicalCanvas.canvas = application_1.application.global.createCanvas({})), 
            ConicalCanvas.canvas;
        } catch (err) {
            return null;
        }
    }
    static GetCtx() {
        if (!ConicalCanvas.ctx) {
            const conicalCanvas = ConicalCanvas.GetCanvas();
            ConicalCanvas.ctx = conicalCanvas.getContext("2d");
        }
        return ConicalCanvas.ctx;
    }
}

class ColorInterpolate {
    constructor(stops = [], precision = 100) {
        const canvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();
        if (canvas.width = precision, canvas.height = 1, !conicalCtx) return;
        if (conicalCtx.translate(0, 0), !conicalCtx) throw new Error("获取ctx发生错误");
        const gradient = conicalCtx.createLinearGradient(0, 0, precision, 0);
        stops.forEach((stop => {
            gradient.addColorStop(stop[0], stop[1]);
        })), conicalCtx.fillStyle = gradient, conicalCtx.fillRect(0, 0, precision, 1), this.rgbaSet = conicalCtx.getImageData(0, 0, precision, 1).data;
    }
    getColor(offset) {
        const rgba = this.rgbaSet.slice(4 * offset, 4 * offset + 4);
        return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3] / 255})`;
    }
    static GetOrCreate(stops = [], precision = 100) {
        let str = "";
        stops.forEach((item => str += item.join())), str += precision;
        let colorInter = ColorInterpolate.dataMap.get(str);
        return colorInter || (colorInter = new ColorInterpolate(stops, precision), ColorInterpolate.dataMap.set(str, colorInter)), 
        colorInter;
    }
    static SetColorInterpolateInstance(stops, ins) {
        ColorInterpolate.dataMap.set(stops, ins);
    }
    static GetColorInterpolateInstance(stops) {
        return ColorInterpolate.dataMap.get(stops);
    }
}

exports.ColorInterpolate = ColorInterpolate, ColorInterpolate.dataMap = new Map;

class ConicalPatternStore {
    static GetSize(minSize) {
        for (let i = 0; i < ConicalPatternStore.ImageSize.length; i++) if (ConicalPatternStore.ImageSize[i] >= minSize) return ConicalPatternStore.ImageSize[i];
        return minSize;
    }
    static Get(stops, x, y, startAngle, endAngle, w, h) {
        const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle), data = ConicalPatternStore.cache[key];
        if (!data || 0 === data.length) return null;
        for (let i = 0; i < data.length; i++) if (data[i].width >= w && data[i].height >= h) return data[i].pattern;
        return null;
    }
    static Set(stops, x, y, startAngle, endAngle, pattern, w, h) {
        const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);
        ConicalPatternStore.cache[key] ? ConicalPatternStore.cache[key].push({
            width: w,
            height: h,
            pattern: pattern
        }) : ConicalPatternStore.cache[key] = [ {
            width: w,
            height: h,
            pattern: pattern
        } ];
    }
    static GenKey(stops, x, y, startAngle, endAngle) {
        return `${x},${y},${startAngle},${endAngle},${stops.join()}`;
    }
}

function getConicGradientAt(x, y, angle, color) {
    const {stops: stops, startAngle: startAngle, endAngle: endAngle} = color;
    for (;angle < 0; ) angle += vutils_1.pi2;
    for (;angle > vutils_1.pi2; ) angle -= vutils_1.pi2;
    if (angle < startAngle) return stops[0].color;
    if (angle > endAngle) return stops[0].color;
    let startStop, endStop, percent = (angle - startAngle) / (endAngle - startAngle);
    for (let i = 0; i < stops.length; i++) if (stops[i].offset >= percent) {
        startStop = stops[i - 1], endStop = stops[i];
        break;
    }
    return percent = (percent - startStop.offset) / (endStop.offset - startStop.offset), 
    (0, interpolate_1.interpolateColor)(startStop.color, endStop.color, percent, !1);
}

function createConicalGradient(context, stops, x, y, deltaAngle, startAngle, endAngle, minW, minH) {
    const deltaDeg = Math.floor(180 * deltaAngle / Math.PI), conicalCanvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();
    if (!conicalCtx) return null;
    const width = ConicalPatternStore.GetSize(minW), height = ConicalPatternStore.GetSize(minH);
    let pattern = ConicalPatternStore.Get(stops, x, y, startAngle, endAngle, width, height);
    if (pattern) return pattern;
    const r = Math.sqrt(Math.max(Math.max(Math.pow(x, 2) + Math.pow(y, 2), Math.pow(width - x, 2) + Math.pow(y, 2)), Math.max(Math.pow(width - x, 2) + Math.pow(height - y, 2), Math.pow(x, 2) + Math.pow(height - y, 2)))), stepNum = deltaDeg + 1, step = deltaAngle / Math.max(1, stepNum - 1), colorInter = ColorInterpolate.GetOrCreate(stops, stepNum), lineWidth = 2 * Math.PI * r / 360;
    conicalCanvas.width = width, conicalCanvas.height = height, conicalCtx.setTransform(1, 0, 0, 1, 0, 0), 
    conicalCtx.clearRect(0, 0, width, height), conicalCtx.translate(x, y), conicalCtx.rotate(startAngle);
    for (let i = 0, len = stepNum - 1; i < len && !(startAngle + i * step > endAngle); i++) {
        const color = colorInter.getColor(i);
        conicalCtx.beginPath(), conicalCtx.rotate(step), conicalCtx.moveTo(0, 0), conicalCtx.lineTo(r, -2 * lineWidth), 
        conicalCtx.lineTo(r, 0), conicalCtx.fillStyle = color, conicalCtx.closePath(), conicalCtx.fill();
    }
    const imageData = conicalCtx.getImageData(0, 0, width, height);
    return conicalCanvas.width = imageData.width, conicalCanvas.height = imageData.height, 
    conicalCtx.putImageData(imageData, 0, 0), pattern = context.createPattern(conicalCanvas, "no-repeat"), 
    ConicalPatternStore.Set(stops, x, y, startAngle, endAngle, pattern, width, height), 
    pattern;
}

ConicalPatternStore.cache = {}, ConicalPatternStore.ImageSize = [ 20, 40, 80, 160, 320, 640, 1280, 2560 ], 
exports.getConicGradientAt = getConicGradientAt, exports.createConicalGradient = createConicalGradient;
//# sourceMappingURL=conical-gradient.js.map

}, function(modId) { var map = {"../../../application":1689069767703,"../../../color-string/interpolate":1689069767740}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767754, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultArcTextureRenderContribution = exports.DefaultArcBackgroundRenderContribution = exports.DefaultArcRenderContribution = exports.ArcRenderContribution = void 0;

const inversify_1 = require("inversify"), canvas_utils_1 = require("../../../../common/canvas-utils"), base_contribution_render_1 = require("./base-contribution-render"), utils_1 = require("../utils"), enums_1 = require("../../../../common/enums");

exports.ArcRenderContribution = Symbol.for("ArcRenderContribution");

let DefaultArcRenderContribution = class {
    constructor() {
        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, fillCb, strokeCb) {
        const {innerRadius: innerRadius = arcAttribute.innerRadius, outerRadius: outerRadius = arcAttribute.outerRadius, startAngle: startAngle = arcAttribute.startAngle, endAngle: endAngle = arcAttribute.endAngle, opacity: opacity = arcAttribute.opacity, outerBorder: outerBorder, innerBorder: innerBorder} = arc.attribute;
        if (outerBorder) {
            const {distance: distance = arcAttribute.outerBorder.distance} = outerBorder, d = (0, 
            canvas_utils_1.getScaledStroke)(context, distance, context.dpr), deltaAngle = distance / outerRadius;
            if (arc.setAttributes({
                outerRadius: outerRadius + d,
                innerRadius: innerRadius - d,
                startAngle: startAngle - deltaAngle,
                endAngle: endAngle + deltaAngle
            }), context.beginPath(), (0, utils_1.drawArcPath)(arc, context, x, y, outerRadius + d, innerRadius - d), 
            context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute), 
            strokeCb) strokeCb(context, outerBorder, arcAttribute.outerBorder); else if (sVisible) {
                const lastOpacity = arcAttribute.outerBorder.opacity;
                arcAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(arc, outerBorder, x, y, arcAttribute.outerBorder), 
                arcAttribute.outerBorder.opacity = lastOpacity, context.stroke();
            }
        }
        if (innerBorder) {
            const {distance: distance = arcAttribute.innerBorder.distance} = innerBorder, d = (0, 
            canvas_utils_1.getScaledStroke)(context, distance, context.dpr), deltaAngle = distance / outerRadius;
            if (arc.setAttributes({
                outerRadius: outerRadius - d,
                innerRadius: innerRadius + d,
                startAngle: startAngle + deltaAngle,
                endAngle: endAngle - deltaAngle
            }), context.beginPath(), (0, utils_1.drawArcPath)(arc, context, x, y, outerRadius - d, innerRadius + d), 
            context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute), 
            strokeCb) strokeCb(context, innerBorder, arcAttribute.innerBorder); else if (sVisible) {
                const lastOpacity = arcAttribute.innerBorder.opacity;
                arcAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(arc, innerBorder, x, y, arcAttribute.innerBorder), 
                arcAttribute.innerBorder.opacity = lastOpacity, context.stroke();
            }
        }
        arc.setAttributes({
            outerRadius: outerRadius,
            innerRadius: innerRadius,
            startAngle: startAngle,
            endAngle: endAngle
        });
    }
};

DefaultArcRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultArcRenderContribution), 
exports.DefaultArcRenderContribution = DefaultArcRenderContribution;

let DefaultArcBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;
    }
};

DefaultArcBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultArcBackgroundRenderContribution), 
exports.DefaultArcBackgroundRenderContribution = DefaultArcBackgroundRenderContribution;

let DefaultArcTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;
    }
};

DefaultArcTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultArcTextureRenderContribution), 
exports.DefaultArcTextureRenderContribution = DefaultArcTextureRenderContribution;
//# sourceMappingURL=arc-contribution-render.js.map

}, function(modId) { var map = {"../../../../common/canvas-utils":1689069767755,"./base-contribution-render":1689069767756,"../utils":1689069767752,"../../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767755, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createColor = exports.getScaledStroke = void 0;

const vutils_1 = require("@visactor/vutils");

function getScaledStroke(context, width, dpr) {
    let strokeWidth = width;
    const {a: a, b: b, c: c, d: d} = context.currentMatrix, scaleX = Math.sign(a) * Math.sqrt(a * a + b * b), scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);
    return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, 
    strokeWidth);
}

function createColor(context, c, params, offsetX, offsetY) {
    if (!c || !0 === c) return "black";
    let result, color;
    if ((0, vutils_1.isArray)(c)) for (let i = 0; i < c.length && (color = c[i], !color); i++) ; else color = c;
    return "string" == typeof color ? color : ("linear" === color.gradient ? result = createLinearGradient(context, color, params, offsetX, offsetY) : "conical" === color.gradient ? result = createConicGradient(context, color, params, offsetX, offsetY) : "radial" === color.gradient && (result = createRadialGradient(context, color, params, offsetX, offsetY)), 
    result || "orange");
}

function createLinearGradient(context, color, params, offsetX = 0, offsetY = 0) {
    var _a, _b, _c, _d;
    const bounds = params.AABBBounds;
    if (!bounds) return;
    let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
    if (params.attribute) {
        const {scaleX: scaleX = 1, scaleY: scaleY = 1} = params.attribute;
        if (scaleX * scaleY == 0) return;
        w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY;
    }
    const canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);
    return color.stops.forEach((stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    })), canvasGradient;
}

function createRadialGradient(context, color, params, offsetX = 0, offsetY = 0) {
    var _a, _b, _c, _d, _e, _f;
    const bounds = params.AABBBounds;
    if (!bounds) return;
    let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
    if (params.attribute) {
        const {scaleX: scaleX = 1, scaleY: scaleY = 1} = params.attribute;
        if (scaleX * scaleY == 0) return;
        x /= scaleX, y /= scaleY, w /= scaleX, h /= scaleY;
    }
    const canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : .5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : .5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : .5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : .5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : .5));
    return color.stops.forEach((stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    })), canvasGradient;
}

function createConicGradient(context, color, params, offsetX = 0, offsetY = 0) {
    var _a, _b;
    const bounds = params.AABBBounds;
    if (!bounds) return;
    let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
    if (params.attribute) {
        const {scaleX: scaleX = 1, scaleY: scaleY = 1} = params.attribute;
        if (scaleX * scaleY == 0) return;
        w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY;
    }
    const canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);
    return color.stops.forEach((stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    })), canvasGradient.GetPattern(w + x, h + y, undefined);
}

//# sourceMappingURL=canvas-utils.js.map
exports.getScaledStroke = getScaledStroke, exports.createColor = createColor;
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767756, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultBaseTextureRenderContribution = exports.DefaultBaseBackgroundRenderContribution = void 0;

const inversify_1 = require("inversify"), graphic_1 = require("../../../../graphic"), canvas_allocate_1 = require("../../../../allocator/canvas-allocate"), vutils_1 = require("@visactor/vutils"), enums_1 = require("../../../../common/enums");

let DefaultBaseBackgroundRenderContribution = class {
    constructor() {
        this.time = enums_1.BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb, options) {
        const {background: background} = graphic.attribute;
        if (background) if (graphic.backgroundImg && graphic.resources) {
            const res = graphic.resources.get(background);
            if ("success" !== res.state || !res.data) return;
            if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
                const groupAttribute = (0, graphic_1.getTheme)(graphic.parent).group, {scrollX: scrollX = groupAttribute.scrollX, scrollY: scrollY = groupAttribute.scrollY} = graphic.parent.attribute;
                context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);
            }
            context.clip();
            const b = graphic.AABBBounds;
            context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.drawImage(res.data, b.x1, b.y1, b.width(), b.height()), 
            context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
        } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), 
        context.fillStyle = background, context.fill(), context.highPerformanceRestore();
    }
};

DefaultBaseBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultBaseBackgroundRenderContribution), 
exports.DefaultBaseBackgroundRenderContribution = DefaultBaseBackgroundRenderContribution;

let DefaultBaseTextureRenderContribution = class {
    constructor() {
        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, 
        this.order = 10;
    }
    createCommonPattern(size, padding, color, targetContext, cb) {
        const r = (size - 2 * padding) / 2, canvas = canvas_allocate_1.canvasAllocate.allocate({
            width: size,
            height: size,
            dpr: 1
        }), ctx = canvas.getContext("2d");
        if (!ctx) return null;
        ctx.clearRect(0, 0, size, size), cb(r, ctx);
        const pattern = targetContext.createPattern(canvas.nativeCanvas, "repeat");
        return canvas_allocate_1.canvasAllocate.free(canvas), pattern;
    }
    createCirclePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            ctx.fillStyle = color, ctx.arc(r, r, r, 0, vutils_1.pi2), ctx.fill();
        }));
    }
    createDiamondPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            const x = size / 2, y = x;
            ctx.fillStyle = color, ctx.moveTo(x, y - r), ctx.lineTo(r + x, y), ctx.lineTo(x, y + r), 
            ctx.lineTo(x - r, y), ctx.closePath(), ctx.fill();
        }));
    }
    createRectPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            const x = padding, y = x;
            ctx.fillStyle = color, ctx.fillRect(x, y, 2 * r, 2 * r);
        }));
    }
    createVerticalLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            const x = padding;
            ctx.fillStyle = color, ctx.fillRect(x, 0, 2 * r, size);
        }));
    }
    createHorizontalLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            const y = padding;
            ctx.fillStyle = color, ctx.fillRect(0, y, size, 2 * r);
        }));
    }
    createBiasLRLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(0, 0), ctx.lineTo(size, size);
            const dx = size / 2, dy = -dx;
            ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), 
            ctx.stroke();
        }));
    }
    createBiasRLLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(size, 0), ctx.lineTo(0, size);
            const dx = size / 2, dy = dx;
            ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), 
            ctx.lineTo(-dx, -dy + size), ctx.stroke();
        }));
    }
    createGridPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {
            const x = padding, y = x;
            ctx.fillStyle = color, ctx.fillRect(x, y, r, r), ctx.fillRect(x + r, y + r, r, r);
        }));
    }
    initTextureMap(ctx, stage) {
        this.textureMap = new Map;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb, options) {
        this.textureMap || this.initTextureMap(context, graphic.stage);
        const {texture: texture = graphicAttribute.texture, textureColor: textureColor = graphicAttribute.textureColor, textureSize: textureSize = graphicAttribute.textureSize, texturePadding: texturePadding = graphicAttribute.texturePadding} = graphic.attribute;
        if (!texture) return;
        let pattern = this.textureMap.get(texture);
        if (!pattern) switch (texture) {
          case "circle":
            pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "diamond":
            pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
            break;

          case "rect":
            pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
            break;

          case "vertical-line":
            pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "horizontal-line":
            pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "bias-lr":
            pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "bias-rl":
            pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "grid":
            pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
        }
        pattern && (context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), 
        context.fillStyle = pattern, context.fill(), context.highPerformanceRestore());
    }
};

DefaultBaseTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultBaseTextureRenderContribution), 
exports.DefaultBaseTextureRenderContribution = DefaultBaseTextureRenderContribution;
//# sourceMappingURL=base-contribution-render.js.map

}, function(modId) { var map = {"../../../../graphic":1689069767757,"../../../../allocator/canvas-allocate":1689069767813,"../../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767757, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./node-tree"), exports), __exportStar(require("./circle"), exports), 
__exportStar(require("./text"), exports), __exportStar(require("./symbol"), exports), 
__exportStar(require("./builtin-symbol"), exports), __exportStar(require("./line"), exports), 
__exportStar(require("./rect"), exports), __exportStar(require("./rect3d"), exports), 
__exportStar(require("./glyph"), exports), __exportStar(require("./richtext"), exports), 
__exportStar(require("./path"), exports), __exportStar(require("./area"), exports), 
__exportStar(require("./image"), exports), __exportStar(require("./arc"), exports), 
__exportStar(require("./arc3d"), exports), __exportStar(require("./group"), exports), 
__exportStar(require("./polygon"), exports), __exportStar(require("./pyramid3d"), exports), 
__exportStar(require("./config"), exports), __exportStar(require("./graphic-service/graphic-service"), exports), 
__exportStar(require("./graphic-creator"), exports), __exportStar(require("./builtin-symbol"), exports), 
__exportStar(require("./graphic"), exports), __exportStar(require("./bounds"), exports), 
__exportStar(require("./theme"), exports), __exportStar(require("./tools"), exports), 
__exportStar(require("./constants"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./node-tree":1689069767710,"./circle":1689069767758,"./text":1689069767759,"./symbol":1689069767762,"./builtin-symbol":1689069767763,"./line":1689069767783,"./rect":1689069767784,"./rect3d":1689069767785,"./glyph":1689069767786,"./richtext":1689069767787,"./path":1689069767795,"./area":1689069767796,"./image":1689069767794,"./arc":1689069767797,"./arc3d":1689069767798,"./group":1689069767708,"./polygon":1689069767799,"./pyramid3d":1689069767800,"./config":1689069767680,"./graphic-service/graphic-service":1689069767801,"./graphic-creator":1689069767809,"./graphic":1689069767709,"./bounds":1689069767812,"./theme":1689069767707,"./tools":1689069767745,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767758, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Circle = void 0;

const graphic_1 = require("./graphic"), custom_path2d_1 = require("../common/custom-path2d"), utils_1 = require("../common/utils"), theme_1 = require("./theme"), application_1 = require("../application"), constants_1 = require("./constants"), CIRCLE_UPDATE_TAG_KEY = [ "radius", "startAngle", "endAngle", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Circle extends graphic_1.Graphic {
    constructor(params = {
        radius: 1
    }) {
        super(params), this.type = "circle", this.numberType = constants_1.CIRCLE_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {startAngle: startAngle, endAngle: endAngle, radius: radius} = this.attribute;
        return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
    }
    doUpdateAABBBounds(full) {
        const circleTheme = (0, theme_1.getTheme)(this).circle;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateCircleAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).circle, this._AABBBounds, full, this), {boundsPadding: boundsPadding = circleTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return (0, theme_1.getTheme)(this).circle[name];
    }
    needUpdateTags(keys) {
        for (let i = 0; i < CIRCLE_UPDATE_TAG_KEY.length; i++) {
            const attrKey = CIRCLE_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < CIRCLE_UPDATE_TAG_KEY.length; i++) {
            if (key === CIRCLE_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    toCustomPath() {
        var _a, _b, _c;
        const attribute = this.attribute, radius = null !== (_a = attribute.radius) && void 0 !== _a ? _a : this.getDefaultAttribute("radius"), startAngle = null !== (_b = attribute.startAngle) && void 0 !== _b ? _b : this.getDefaultAttribute("startAngle"), endAngle = null !== (_c = attribute.endAngle) && void 0 !== _c ? _c : this.getDefaultAttribute("endAngle"), path = new custom_path2d_1.CustomPath2D;
        return path.arc(0, 0, radius, startAngle, endAngle), path;
    }
    clone() {
        return new Circle(Object.assign({}, this.attribute));
    }
}

exports.Circle = Circle;
//# sourceMappingURL=circle.js.map

}, function(modId) { var map = {"./graphic":1689069767709,"../common/custom-path2d":1689069767681,"../common/utils":1689069767736,"./theme":1689069767707,"../application":1689069767703,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767759, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Text = void 0;

const text_1 = require("../common/text"), layout_1 = require("../core/contributions/textMeasure/layout"), application_1 = require("../application"), graphic_1 = require("./graphic"), theme_1 = require("./theme"), utils_1 = require("../common/utils"), constants_1 = require("./constants"), TEXT_UPDATE_TAG_KEY = [ "text", "maxLineWidth", "fontSize", "fontFamily", "fontWeight", "ellipsis", "lineHeight", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Text extends graphic_1.Graphic {
    get font() {
        const textTheme = (0, theme_1.getTheme)(this).text;
        return this._font || (this._font = (0, text_1.getContextFont)(this.attribute, textTheme)), 
        this._font;
    }
    get clipedText() {
        var _a;
        const attribute = this.attribute, textTheme = (0, theme_1.getTheme)(this).text;
        if (Array.isArray(attribute.text)) return;
        const {maxLineWidth: maxLineWidth = textTheme.maxLineWidth} = attribute;
        return Number.isFinite(maxLineWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();
    }
    get clipedWidth() {
        if (!Array.isArray(this.attribute.text)) return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
    }
    get cliped() {
        const textTheme = (0, theme_1.getTheme)(this).text, attribute = this.attribute;
        if (Array.isArray(attribute.text)) return;
        const {maxLineWidth: maxLineWidth = textTheme.maxLineWidth} = attribute;
        return !!Number.isFinite(maxLineWidth) && (this.tryUpdateAABBBounds(), this.clipedText === attribute.text);
    }
    get multilineLayout() {
        if (Array.isArray(this.attribute.text)) return this.tryUpdateAABBBounds(), this.cache.layoutData;
    }
    constructor(params = {
        text: "",
        fontSize: 16
    }) {
        super(params), this.type = "text", this.numberType = constants_1.TEXT_NUMBER_TYPE, 
        this.cache = {};
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {text: text} = this.attribute;
        return null != text && "" !== text;
    }
    doUpdateAABBBounds() {
        const textTheme = (0, theme_1.getTheme)(this).text;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateTextAABBBounds(attribute, textTheme, this._AABBBounds, this), {boundsPadding: boundsPadding = textTheme.boundsPadding} = this.attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    updateSingallineAABBBounds(text) {
        var _a;
        const textTheme = (0, theme_1.getTheme)(this).text, textMeasure = application_1.application.graphicUtil.textMeasure;
        let width, str;
        const buf = 2, attribute = this.attribute, {maxLineWidth: maxLineWidth = textTheme.maxLineWidth, ellipsis: ellipsis = textTheme.ellipsis, textAlign: textAlign = textTheme.textAlign, textBaseline: textBaseline = textTheme.textBaseline, fontSize: fontSize = textTheme.fontSize, stroke: stroke = textTheme.stroke, lineHeight: lineHeight = (null !== (_a = attribute.lineHeight) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf), lineWidth: lineWidth = textTheme.lineWidth} = attribute;
        if (!this.shouldUpdateShape() && this.cache) {
            width = this.cache.clipedWidth;
            const dx = (0, text_1.textDrawOffsetX)(textAlign, width), dy = (0, text_1.textLayoutOffsetY)(textBaseline, lineHeight, fontSize);
            return this._AABBBounds.set(dx, dy, dx + width, dy + lineHeight), stroke && this._AABBBounds.expand(lineWidth / 2), 
            this._AABBBounds;
        }
        if (Number.isFinite(maxLineWidth)) {
            if (ellipsis) {
                const strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffix(text.toString(), {
                    fontSize: fontSize
                }, maxLineWidth, strEllipsis);
                str = data.str, width = data.width;
            } else {
                const data = textMeasure.clipText(text.toString(), {
                    fontSize: fontSize
                }, maxLineWidth);
                str = data.str, width = data.width;
            }
            this.cache.clipedText = str, this.cache.clipedWidth = width;
        } else width = textMeasure.measureTextWidth(text.toString(), {
            fontSize: fontSize
        }), this.cache.clipedText = text.toString(), this.cache.clipedWidth = width;
        this.clearUpdateShapeTag();
        const dx = (0, text_1.textDrawOffsetX)(textAlign, width), dy = (0, text_1.textLayoutOffsetY)(textBaseline, lineHeight, fontSize);
        return this._AABBBounds.set(dx, dy, dx + width, dy + lineHeight), stroke && this._AABBBounds.expand(lineWidth / 2), 
        this._AABBBounds;
    }
    updateMultilineAABBBounds(text) {
        var _a;
        const textTheme = (0, theme_1.getTheme)(this).text, attribute = this.attribute, {fontFamily: fontFamily = textTheme.fontFamily, textAlign: textAlign = textTheme.textAlign, textBaseline: textBaseline = textTheme.textBaseline, fontSize: fontSize = textTheme.fontSize, lineHeight: lineHeight = attribute.lineHeight || attribute.fontSize || textTheme.fontSize, ellipsis: ellipsis = textTheme.ellipsis, maxLineWidth: maxLineWidth, stroke: stroke = textTheme.stroke, lineWidth: lineWidth = textTheme.lineWidth} = attribute;
        if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
            const bbox = this.cache.layoutData.bbox;
            return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), 
            stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        const textMeasure = application_1.application.graphicUtil.textMeasure, layoutData = new layout_1.CanvasTextLayout(fontFamily, {
            fontSize: fontSize
        }, textMeasure).GetLayoutByLines(text, textAlign, textBaseline, lineHeight, !0 === ellipsis ? textTheme.ellipsis : ellipsis || void 0, maxLineWidth), {bbox: bbox} = layoutData;
        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), 
        stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return (0, theme_1.getTheme)(this).text[name];
    }
    needUpdateTags(keys) {
        for (let i = 0; i < TEXT_UPDATE_TAG_KEY.length; i++) {
            const attrKey = TEXT_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < TEXT_UPDATE_TAG_KEY.length; i++) {
            if (key === TEXT_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    clone() {
        return new Text(Object.assign({}, this.attribute));
    }
}

exports.Text = Text;
//# sourceMappingURL=text.js.map

}, function(modId) { var map = {"../common/text":1689069767760,"../core/contributions/textMeasure/layout":1689069767761,"../application":1689069767703,"./graphic":1689069767709,"./theme":1689069767707,"../common/utils":1689069767736,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767760, function(require, module, exports) {


function getContextFont(text, defaultAttr = {}, fontSizeScale) {
    fontSizeScale || (fontSizeScale = 1);
    const {fontStyle: fontStyle = defaultAttr.fontStyle, fontVariant: fontVariant = defaultAttr.fontVariant, fontWeight: fontWeight = defaultAttr.fontWeight, fontSize: fontSize = defaultAttr.fontSize, fontFamily: fontFamily = defaultAttr.fontFamily} = text;
    return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
}

function textDrawOffsetY(baseline, h) {
    return "top" === baseline ? Math.ceil(.79 * h) : "middle" === baseline ? Math.round(.3 * h) : "bottom" === baseline ? Math.round(-.21 * h) : 0;
}

function textDrawOffsetX(textAlign, width) {
    return "end" === textAlign || "right" === textAlign ? -width : "center" === textAlign ? -width / 2 : 0;
}

function textLayoutOffsetY(baseline, lineHeight, fontSize) {
    return "middle" === baseline ? -lineHeight / 2 : "top" === baseline ? 0 : "bottom" === baseline ? -lineHeight : baseline && "alphabetic" !== baseline ? 0 : (fontSize || (fontSize = lineHeight), 
    -(lineHeight - fontSize) / 2 - .79 * fontSize);
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.textLayoutOffsetY = exports.textDrawOffsetX = exports.textDrawOffsetY = exports.getContextFont = void 0, 
exports.getContextFont = getContextFont, exports.textDrawOffsetY = textDrawOffsetY, 
exports.textDrawOffsetX = textDrawOffsetX, exports.textLayoutOffsetY = textLayoutOffsetY;
//# sourceMappingURL=text.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767761, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CanvasTextLayout = void 0;

class CanvasTextLayout {
    constructor(fontFamily, options, textMeasure) {
        this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure;
    }
    LayoutBBox(bbox, textAlign, textBaseline) {
        if ("left" === textAlign || "start" === textAlign) bbox.xOffset = 0; else if ("center" === textAlign) bbox.xOffset = bbox.width / -2; else {
            if ("right" !== textAlign && "end" !== textAlign) throw new Error("非法的textAlign");
            bbox.xOffset = -bbox.width;
        }
        return bbox.yOffset = "top" === textBaseline ? 0 : "middle" === textBaseline ? bbox.height / -2 : "alphabetic" === textBaseline ? -.79 * bbox.height : -bbox.height, 
        bbox;
    }
    GetLayout(str, width, height, textAlign, textBaseline, lineHeight, suffix, miniApp) {
        const linesLayout = [], bboxWH = [ width, height ], bboxOffset = [ 0, 0 ];
        for (;str.length > 0; ) {
            const {str: clipText} = this.textMeasure.clipTextWithSuffix(str, this.textOptions, width, suffix);
            linesLayout.push({
                str: clipText,
                width: this.textMeasure.measureTextWidth(clipText, this.textOptions)
            }), str = str.substring(clipText.length);
        }
        "left" === textAlign || "start" === textAlign || ("center" === textAlign ? bboxOffset[0] = bboxWH[0] / -2 : "right" !== textAlign && "end" !== textAlign || (bboxOffset[0] = -bboxWH[0])), 
        "top" === textBaseline || ("middle" === textBaseline ? bboxOffset[1] = bboxWH[1] / -2 : "bottom" === textBaseline && (bboxOffset[1] = -bboxWH[1]));
        const bbox = {
            xOffset: bboxOffset[0],
            yOffset: bboxOffset[1],
            width: bboxWH[0],
            height: bboxWH[1]
        };
        return this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    }
    GetLayoutByLines(lines, textAlign, textBaseline, lineHeight, suffix = "", lineWidth) {
        lines = lines.map((l => l.toString()));
        const linesLayout = [], bboxWH = [ 0, 0 ];
        if ("number" == typeof lineWidth && lineWidth !== 1 / 0) {
            let width;
            for (let i = 0, len = lines.length; i < len; i++) width = Math.min(this.textMeasure.measureTextWidth(lines[i], this.textOptions), lineWidth), 
            linesLayout.push({
                str: this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, width, suffix).str,
                width: width
            });
            bboxWH[0] = lineWidth;
        } else {
            let width, text;
            lineWidth = 0;
            for (let i = 0, len = lines.length; i < len; i++) text = lines[i], width = this.textMeasure.measureTextWidth(text, this.textOptions), 
            lineWidth = Math.max(lineWidth, width), linesLayout.push({
                str: text,
                width: width
            });
            bboxWH[0] = lineWidth;
        }
        bboxWH[1] = linesLayout.length * lineHeight;
        const bbox = {
            xOffset: 0,
            yOffset: 0,
            width: bboxWH[0],
            height: bboxWH[1]
        };
        return this.LayoutBBox(bbox, textAlign, textBaseline), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    }
    layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
        const origin = [ 0, 0 ], totalLineHeight = lines.length * lineHeight;
        "top" === textBaseline || ("middle" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : "bottom" === textBaseline && (origin[1] = bbox.height - totalLineHeight));
        for (let i = 0; i < lines.length; i++) this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
        return {
            bbox: bbox,
            lines: lines,
            fontFamily: this.fontFamily,
            fontSize: this.textOptions.fontSize,
            fontWeight: this.textOptions.fontWeight,
            lineHeight: lineHeight,
            textAlign: textAlign,
            textBaseline: textBaseline
        };
    }
    lineOffset(bbox, line, textAlign, textBaseline, lineHeight, origin) {
        return "left" === textAlign || "start" === textAlign ? line.leftOffset = 0 : "center" === textAlign ? line.leftOffset = (bbox.width - line.width) / 2 : "right" !== textAlign && "end" !== textAlign || (line.leftOffset = bbox.width - line.width), 
        line.topOffset = (lineHeight - this.textOptions.fontSize) / 2 + .79 * this.textOptions.fontSize + origin[1], 
        origin[1] += lineHeight, line;
    }
}

exports.CanvasTextLayout = CanvasTextLayout;
//# sourceMappingURL=layout.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767762, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Symbol = void 0;

const vutils_1 = require("@visactor/vutils"), builtin_symbol_1 = require("./builtin-symbol"), graphic_1 = require("./graphic"), utils_1 = require("../common/utils"), theme_1 = require("./theme"), application_1 = require("../application"), custom_path2d_1 = require("../common/custom-path2d"), constants_1 = require("./constants"), SYMBOL_UPDATE_TAG_KEY = [ "symbolType", "size", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Symbol extends graphic_1.Graphic {
    constructor(params = {
        symbolType: "circle"
    }) {
        super(params), this.type = "symbol", this.numberType = constants_1.SYMBOL_NUMBER_TYPE;
    }
    getParsedPath() {
        return this.shouldUpdateShape() && (this.doUpdateParsedPath(), this.clearUpdateShapeTag()), 
        this._parsedPath;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {size: size} = this.attribute;
        return (0, vutils_1.isArray)(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
    }
    doUpdateParsedPath() {
        const symbolTheme = (0, theme_1.getTheme)(this).symbol, {symbolType: symbolType = symbolTheme.symbolType} = this.attribute;
        let path = builtin_symbol_1.builtinSymbolsMap[symbolType];
        if (path) return this._parsedPath = path, path;
        if (path = Symbol.userSymbolMap[symbolType], path) return this._parsedPath = path, 
        path;
        const cache = (new custom_path2d_1.CustomPath2D).fromString(symbolType), width = cache.bounds.width(), height = cache.bounds.height(), scale = 1 / (0, 
        vutils_1.max)(width, height);
        return cache.transform(0, 0, scale, scale), this._parsedPath = new builtin_symbol_1.CustomSymbolClass(symbolType, cache), 
        Symbol.userSymbolMap[symbolType] = this._parsedPath, this._parsedPath;
    }
    doUpdateAABBBounds(full) {
        const symbolTheme = (0, theme_1.getTheme)(this).symbol;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateSymbolAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).symbol, this._AABBBounds, full, this), {boundsPadding: boundsPadding = symbolTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return (0, theme_1.getTheme)(this).symbol[name];
    }
    needUpdateTags(keys) {
        for (let i = 0; i < SYMBOL_UPDATE_TAG_KEY.length; i++) {
            const attrKey = SYMBOL_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < SYMBOL_UPDATE_TAG_KEY.length; i++) {
            if (key === SYMBOL_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    toCustomPath() {
        const symbolInstance = this.getParsedPath(), size = this.attribute.size, formattedSize = (0, 
        vutils_1.isArray)(size) ? size : [ size, size ];
        return symbolInstance.path ? (new custom_path2d_1.CustomPath2D).fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : (new custom_path2d_1.CustomPath2D).fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
    }
    clone() {
        return new Symbol(Object.assign({}, this.attribute));
    }
}

exports.Symbol = Symbol, Symbol.userSymbolMap = {};
//# sourceMappingURL=symbol.js.map

}, function(modId) { var map = {"./builtin-symbol":1689069767763,"./graphic":1689069767709,"../common/utils":1689069767736,"./theme":1689069767707,"../application":1689069767703,"../common/custom-path2d":1689069767681,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767763, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
}, __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.builtinSymbolsMap = exports.builtinSymbols = void 0;

const circle_1 = __importDefault(require("./circle")), cross_1 = __importDefault(require("./cross")), diamond_1 = __importDefault(require("./diamond")), square_1 = __importDefault(require("./square")), triangle_1 = __importDefault(require("./triangle")), star_1 = __importDefault(require("./star")), arrow_1 = __importDefault(require("./arrow")), wedge_1 = __importDefault(require("./wedge")), stroke_1 = __importDefault(require("./stroke")), wye_1 = __importDefault(require("./wye")), triangle_left_1 = __importDefault(require("./triangle-left")), triangle_right_1 = __importDefault(require("./triangle-right")), triangle_up_1 = __importDefault(require("./triangle-up")), triangle_down_1 = __importDefault(require("./triangle-down")), thin_triangle_1 = __importDefault(require("./thin-triangle")), arrow2_left_1 = __importDefault(require("./arrow2-left")), arrow2_right_1 = __importDefault(require("./arrow2-right")), rect_1 = __importDefault(require("./rect"));

exports.builtinSymbols = [ circle_1.default, cross_1.default, diamond_1.default, square_1.default, thin_triangle_1.default, triangle_1.default, star_1.default, arrow_1.default, wedge_1.default, stroke_1.default, wye_1.default, triangle_left_1.default, triangle_right_1.default, triangle_up_1.default, triangle_down_1.default, arrow2_left_1.default, arrow2_right_1.default, rect_1.default ], 
exports.builtinSymbolsMap = {}, exports.builtinSymbols.forEach((symbol => {
    exports.builtinSymbolsMap[symbol.type] = symbol;
})), __exportStar(require("./utils"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./circle":1689069767764,"./cross":1689069767765,"./diamond":1689069767766,"./square":1689069767767,"./triangle":1689069767768,"./star":1689069767770,"./arrow":1689069767771,"./wedge":1689069767772,"./stroke":1689069767773,"./wye":1689069767774,"./triangle-left":1689069767775,"./triangle-right":1689069767776,"./triangle-up":1689069767769,"./triangle-down":1689069767777,"./thin-triangle":1689069767778,"./arrow2-left":1689069767779,"./arrow2-right":1689069767780,"./rect":1689069767781,"./utils":1689069767782}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767764, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CircleSymbol = exports.circle = void 0;

const vutils_1 = require("@visactor/vutils");

function circle(ctx, r, x, y, z) {
    return z ? ctx.arc(x, y, r, 0, vutils_1.tau, !1, z) : ctx.arc(x, y, r, 0, vutils_1.tau), 
    !1;
}

exports.circle = circle;

class CircleSymbol {
    constructor() {
        this.type = "circle", this.pathStr = "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0";
    }
    draw(ctx, size, x, y, z) {
        return circle(ctx, size / 2, x, y, z);
    }
    drawOffset(ctx, size, x, y, offset, z) {
        return circle(ctx, size / 2 + offset, x, y, z);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.CircleSymbol = CircleSymbol, exports.default = new CircleSymbol;
//# sourceMappingURL=circle.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767765, function(require, module, exports) {


function cross(ctx, r, x, y, z) {
    return ctx.moveTo(-3 * r + x, -r + y, z), ctx.lineTo(-r + x, -r + y, z), ctx.lineTo(-r + x, -3 * r + y, z), 
    ctx.lineTo(r + x, -3 * r + y, z), ctx.lineTo(r + x, -r + y, z), ctx.lineTo(3 * r + x, -r + y, z), 
    ctx.lineTo(3 * r + x, r + y, z), ctx.lineTo(r + x, r + y, z), ctx.lineTo(r + x, 3 * r + y, z), 
    ctx.lineTo(-r + x, 3 * r + y, z), ctx.lineTo(-r + x, r + y, z), ctx.lineTo(-3 * r + x, r + y, z), 
    ctx.closePath(), !0;
}

function crossOffset(ctx, r, x, y, offset, z) {
    return ctx.moveTo(-3 * r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -r + y - offset, z), 
    ctx.lineTo(-r + x - offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -3 * r + y - offset, z), 
    ctx.lineTo(r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, -r + y - offset, z), 
    ctx.lineTo(3 * r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, r + y + offset, z), 
    ctx.lineTo(r + x + offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, 3 * r + y + offset, z), 
    ctx.lineTo(-r + x - offset, r + y + offset, z), ctx.lineTo(-3 * r + x - offset, r + y + offset, z), 
    ctx.closePath(), !0;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CrossSymbol = exports.crossOffset = exports.cross = void 0, exports.cross = cross, 
exports.crossOffset = crossOffset;

class CrossSymbol {
    constructor() {
        this.type = "cross", this.pathStr = "M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z";
    }
    draw(ctx, size, x, y, z) {
        return cross(ctx, size / 6, x, y, z);
    }
    drawOffset(ctx, size, x, y, offset, z) {
        return crossOffset(ctx, size / 6, x, y, offset, z);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.CrossSymbol = CrossSymbol, exports.default = new CrossSymbol;
//# sourceMappingURL=cross.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767766, function(require, module, exports) {


function diamond(ctx, r, x, y, z) {
    return ctx.moveTo(x, y - r, z), ctx.lineTo(r + x, y, z), ctx.lineTo(x, y + r, z), 
    ctx.lineTo(x - r, y, z), ctx.closePath(), !0;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DiamondSymbol = exports.diamond = void 0, exports.diamond = diamond;

class DiamondSymbol {
    constructor() {
        this.type = "diamond", this.pathStr = "M-0.5,0L0,-0.5L0.5,0L0,0.5Z";
    }
    draw(ctx, size, x, y, z) {
        return diamond(ctx, size / 2, x, y, z);
    }
    drawFitDir(ctx, size, x, y, z) {
        return diamond(ctx, size / 2, x, y, z);
    }
    drawOffset(ctx, size, x, y, offset, z) {
        return diamond(ctx, size / 2 + offset, x, y, z);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.DiamondSymbol = DiamondSymbol, exports.default = new DiamondSymbol;
//# sourceMappingURL=diamond.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767767, function(require, module, exports) {


function square(ctx, r, x, y) {
    const wh = 2 * r;
    return ctx.rect(x - r, y - r, wh, wh), !1;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.SquareSymbol = exports.square = void 0, exports.square = square;

class SquareSymbol {
    constructor() {
        this.type = "square", this.pathStr = "M-0.5,-0.5h1v1h-1Z";
    }
    draw(ctx, size, x, y) {
        return square(ctx, size / 2, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        return square(ctx, size / 2 + offset, x, y);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.SquareSymbol = SquareSymbol, exports.default = new SquareSymbol;
//# sourceMappingURL=square.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767768, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TriangleSymbol = exports.triangle = void 0;

const triangle_up_1 = require("./triangle-up");

exports.triangle = triangle_up_1.trianglUp;

class TriangleSymbol extends triangle_up_1.TriangleUpSymbol {
    constructor() {
        super(...arguments), this.type = "triangle";
    }
}

exports.TriangleSymbol = TriangleSymbol, exports.default = new TriangleSymbol;
//# sourceMappingURL=triangle.js.map

}, function(modId) { var map = {"./triangle-up":1689069767769}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767769, function(require, module, exports) {


function trianglUp(ctx, r, x, y) {
    return ctx.moveTo(x + r, r + y), ctx.lineTo(x - r, r + y), ctx.lineTo(x, y - r), 
    ctx.closePath(), !0;
}

function trianglUpOffset(ctx, r, x, y, offset) {
    return ctx.moveTo(x + r + 2 * offset, r + y + offset), ctx.lineTo(x - r - 2 * offset, r + y + offset), 
    ctx.lineTo(x, y - r - 2 * offset), ctx.closePath(), !0;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TriangleUpSymbol = exports.trianglUpOffset = exports.trianglUp = void 0, 
exports.trianglUp = trianglUp, exports.trianglUpOffset = trianglUpOffset;

class TriangleUpSymbol {
    constructor() {
        this.type = "triangleUp", this.pathStr = "M0.5,0.5 L-0.5,0.5 L0,-0.5 Z";
    }
    draw(ctx, size, x, y) {
        return trianglUp(ctx, size / 2, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        return trianglUpOffset(ctx, size / 2, x, y, offset);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.TriangleUpSymbol = TriangleUpSymbol, exports.default = new TriangleUpSymbol;
//# sourceMappingURL=triangle-up.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767770, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.StarSymbol = exports.star = void 0;

const vutils_1 = require("@visactor/vutils"), kr = Math.sin(Math.PI / 10) / Math.sin(7 * Math.PI / 10), kx = Math.sin(vutils_1.tau / 10) * kr, ky = -Math.cos(vutils_1.tau / 10) * kr;

function star(ctx, r, transX, transY) {
    const x = kx * r, y = ky * r;
    ctx.moveTo(transX, -r + transY), ctx.lineTo(x + transX, y + transY);
    for (let i = 1; i < 5; ++i) {
        const a = vutils_1.tau * i / 5, c = Math.cos(a), s = Math.sin(a);
        ctx.lineTo(s * r + transX, -c * r + transY), ctx.lineTo(c * x - s * y + transX, s * x + c * y + transY);
    }
    return ctx.closePath(), !0;
}

exports.star = star;

class StarSymbol {
    constructor() {
        this.type = "star", this.pathStr = "M4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,-4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,4.51351666838205,0";
    }
    draw(ctx, size, transX, transY) {
        return star(ctx, size / 2, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        return star(ctx, size / 2 + offset, transX, transY);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.StarSymbol = StarSymbol, exports.default = new StarSymbol;
//# sourceMappingURL=star.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767771, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ArrowSymbol = exports.arrow = void 0;

const vutils_1 = require("@visactor/vutils"), sqrt3 = (0, vutils_1.sqrt)(3);

function arrow(ctx, r, transX, transY) {
    const triangleH = r, trangleBottomSide = triangleH / sqrt3, rectW = trangleBottomSide / 5, rectH = r;
    return ctx.moveTo(0 + transX, -triangleH + transY), ctx.lineTo(trangleBottomSide / 2 + transX, transY), 
    ctx.lineTo(rectW / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, rectH + transY), 
    ctx.lineTo(-rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, transY), 
    ctx.lineTo(-trangleBottomSide / 2 + transX, transY), ctx.closePath(), !0;
}

exports.arrow = arrow;

class ArrowSymbol {
    constructor() {
        this.type = "arrow", this.pathStr = "M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z";
    }
    draw(ctx, size, transX, transY) {
        return arrow(ctx, size / 2, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        return arrow(ctx, size / 2 + offset, transX, transY);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.ArrowSymbol = ArrowSymbol, exports.default = new ArrowSymbol;
//# sourceMappingURL=arrow.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767772, function(require, module, exports) {


function wedge(ctx, r, transX, transY) {
    const h = 2 * r;
    return ctx.moveTo(transX, -r + transY), ctx.lineTo(h / 3 / 2 + transX, r + transY), 
    ctx.lineTo(-h / 3 / 2 + transX, r + transY), ctx.closePath(), !0;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.WedgeSymbol = exports.wedge = void 0, exports.wedge = wedge;

class WedgeSymbol {
    constructor() {
        this.type = "wedge", this.pathStr = "M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z";
    }
    draw(ctx, size, transX, transY) {
        return wedge(ctx, size / 2, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        return wedge(ctx, size / 2 + offset, transX, transY);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.WedgeSymbol = WedgeSymbol, exports.default = new WedgeSymbol;
//# sourceMappingURL=wedge.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767773, function(require, module, exports) {


function stroke(ctx, r, transX, transY) {
    return ctx.moveTo(-r + transX, transY), ctx.lineTo(transX, r + transY), !1;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.StrokeSymbol = exports.stroke = void 0, exports.stroke = stroke;

class StrokeSymbol {
    constructor() {
        this.type = "stroke", this.pathStr = "";
    }
    draw(ctx, size, transX, transY) {
        return stroke(ctx, size / 2, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        return stroke(ctx, size / 2 + offset, transX, transY);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.StrokeSymbol = StrokeSymbol, exports.default = new StrokeSymbol;
//# sourceMappingURL=stroke.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767774, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.WyeSymbol = exports.wye = void 0;

const vutils_1 = require("@visactor/vutils"), c = -.5, s = (0, vutils_1.sqrt)(3) / 2, k = 1 / (0, 
vutils_1.sqrt)(12), a = 3 * (k / 2 + 1);

function wye(ctx, r, transX, transY) {
    const x0 = r / 2, y0 = r * k, x1 = x0, y1 = r * k + r, x2 = -x1, y2 = y1;
    return ctx.moveTo(x0 + transX, y0 + transY), ctx.lineTo(x1 + transX, y1 + transY), 
    ctx.lineTo(x2 + transX, y2 + transY), ctx.lineTo(c * x0 - s * y0 + transX, s * x0 + c * y0 + transY), 
    ctx.lineTo(c * x1 - s * y1 + transX, s * x1 + c * y1 + transY), ctx.lineTo(c * x2 - s * y2 + transX, s * x2 + c * y2 + transY), 
    ctx.lineTo(c * x0 + s * y0 + transX, c * y0 - s * x0 + transY), ctx.lineTo(c * x1 + s * y1 + transX, c * y1 - s * x1 + transY), 
    ctx.lineTo(c * x2 + s * y2 + transX, c * y2 - s * x2 + transY), ctx.closePath(), 
    !1;
}

exports.wye = wye;

class WyeSymbol {
    constructor() {
        this.type = "wye", this.pathStr = "M4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,-4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,4.51351666838205,0";
    }
    draw(ctx, size, transX, transY) {
        return wye(ctx, size / 2, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        return wye(ctx, size / 2 + offset, transX, transY);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.WyeSymbol = WyeSymbol, exports.default = new WyeSymbol;
//# sourceMappingURL=wye.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767775, function(require, module, exports) {


function trianglLeft(ctx, r, x, y) {
    return ctx.moveTo(-r + x, y), ctx.lineTo(r + x, r + y), ctx.lineTo(r + x, y - r), 
    ctx.closePath(), !0;
}

function trianglLeftOffset(ctx, r, x, y, offset) {
    return ctx.moveTo(-r + x - 2 * offset, y), ctx.lineTo(r + x + offset, r + y + 2 * offset), 
    ctx.lineTo(r + x + offset, y - r - 2 * offset), ctx.closePath(), !0;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TriangleLeftSymbol = exports.trianglLeftOffset = exports.trianglLeft = void 0, 
exports.trianglLeft = trianglLeft, exports.trianglLeftOffset = trianglLeftOffset;

class TriangleLeftSymbol {
    constructor() {
        this.type = "triangleLeft", this.pathStr = "M-0.5,0 L0.5,0.5 L0.5,-0.5 Z";
    }
    draw(ctx, size, x, y) {
        return trianglLeft(ctx, size / 2, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        return trianglLeftOffset(ctx, size / 2, x, y, offset);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.TriangleLeftSymbol = TriangleLeftSymbol, exports.default = new TriangleLeftSymbol;
//# sourceMappingURL=triangle-left.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767776, function(require, module, exports) {


function trianglRight(ctx, r, x, y) {
    return ctx.moveTo(x - r, r + y), ctx.lineTo(r + x, y), ctx.lineTo(x - r, y - r), 
    ctx.closePath(), !0;
}

function trianglRightOffset(ctx, r, x, y, offset) {
    return ctx.moveTo(x - r - offset, r + y + 2 * offset), ctx.lineTo(r + x + 2 * offset, y), 
    ctx.lineTo(x - r - offset, y - r - 2 * offset), ctx.closePath(), !0;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TriangleRightSymbol = exports.trianglRightOffset = exports.trianglRight = void 0, 
exports.trianglRight = trianglRight, exports.trianglRightOffset = trianglRightOffset;

class TriangleRightSymbol {
    constructor() {
        this.type = "triangleRight", this.pathStr = "M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z";
    }
    draw(ctx, size, x, y) {
        return trianglRight(ctx, size / 2, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        return trianglRightOffset(ctx, size / 2, x, y, offset);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.TriangleRightSymbol = TriangleRightSymbol, exports.default = new TriangleRightSymbol;
//# sourceMappingURL=triangle-right.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767777, function(require, module, exports) {


function trianglDown(ctx, r, x, y) {
    return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y - r), ctx.lineTo(x, y + r), 
    ctx.closePath(), !0;
}

function trianglDownOffset(ctx, r, x, y, offset) {
    return ctx.moveTo(x - r - 2 * offset, y - r - offset), ctx.lineTo(x + r + 2 * offset, y - r - offset), 
    ctx.lineTo(x, y + r + 2 * offset), ctx.closePath(), !0;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TriangleDownSymbol = exports.trianglDownOffset = exports.trianglDown = void 0, 
exports.trianglDown = trianglDown, exports.trianglDownOffset = trianglDownOffset;

class TriangleDownSymbol {
    constructor() {
        this.type = "triangleDown", this.pathStr = "M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z";
    }
    draw(ctx, size, x, y) {
        return trianglDown(ctx, size / 2, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        return trianglDownOffset(ctx, size / 2, x, y, offset);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.TriangleDownSymbol = TriangleDownSymbol, exports.default = new TriangleDownSymbol;
//# sourceMappingURL=triangle-down.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767778, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ThinTriangleSymbol = exports.thinTriangle = void 0;

const vutils_1 = require("@visactor/vutils"), triangle_up_1 = require("./triangle-up"), sqrt3 = (0, 
vutils_1.sqrt)(3);

function thinTriangle(ctx, r, x, y) {
    const h = r * sqrt3;
    return ctx.moveTo(x, y + -h / 3 * 2), ctx.lineTo(r + x, y + h), ctx.lineTo(x - r, y + h), 
    ctx.closePath(), !0;
}

exports.thinTriangle = thinTriangle;

class ThinTriangleSymbol extends triangle_up_1.TriangleUpSymbol {
    constructor() {
        super(...arguments), this.type = "thinTriangle", this.pathStr = "M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z";
    }
    draw(ctx, size, x, y) {
        return thinTriangle(ctx, size / 2 / sqrt3, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        return thinTriangle(ctx, size / 2 / sqrt3 + offset, x, y);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.ThinTriangleSymbol = ThinTriangleSymbol, exports.default = new ThinTriangleSymbol;
//# sourceMappingURL=thin-triangle.js.map

}, function(modId) { var map = {"./triangle-up":1689069767769}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767779, function(require, module, exports) {


function arrow2Left(ctx, r, transX, transY) {
    const r2 = 2 * r;
    return ctx.moveTo(r + transX, transY - r2), ctx.lineTo(transX - r, transY), ctx.lineTo(r + transX, r2 + transY), 
    !0;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Arrow2LeftSymbol = exports.arrow2Left = void 0, exports.arrow2Left = arrow2Left;

class Arrow2LeftSymbol {
    constructor() {
        this.type = "arrow2Left", this.pathStr = "M 0.25 -0.5 L -0.25 0 l 0.5 0.5";
    }
    draw(ctx, size, transX, transY) {
        return arrow2Left(ctx, size / 4, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        return arrow2Left(ctx, size / 4 + offset, transX, transY);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.Arrow2LeftSymbol = Arrow2LeftSymbol, exports.default = new Arrow2LeftSymbol;
//# sourceMappingURL=arrow2-left.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767780, function(require, module, exports) {


function arrow2Right(ctx, r, transX, transY) {
    const r2 = 2 * r;
    return ctx.moveTo(transX - r, transY - r2), ctx.lineTo(transX + r, transY), ctx.lineTo(transX - r, r2 + transY), 
    !0;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Arrow2RightSymbol = exports.arrow2Right = void 0, exports.arrow2Right = arrow2Right;

class Arrow2RightSymbol {
    constructor() {
        this.type = "arrow2Right", this.pathStr = "M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5";
    }
    draw(ctx, size, transX, transY) {
        return arrow2Right(ctx, size / 4, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        return arrow2Right(ctx, size / 4 + offset, transX, transY);
    }
    bounds(size, bounds) {
        const r = size / 2;
        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;
    }
}

exports.Arrow2RightSymbol = Arrow2RightSymbol, exports.default = new Arrow2RightSymbol;
//# sourceMappingURL=arrow2-right.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767781, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.RectSymbol = exports.rect = void 0;

const vutils_1 = require("@visactor/vutils");

function rect(ctx, size, x, y) {
    return ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]), !1;
}

exports.rect = rect;

class RectSymbol {
    constructor() {
        this.type = "rect", this.pathStr = "M-0.5,-0.5h1v1h-1Z";
    }
    draw(ctx, size, x, y) {
        return rect(ctx, (0, vutils_1.isNumber)(size) ? [ size, size ] : size, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        return rect(ctx, (0, vutils_1.isNumber)(size) ? [ size + 2 * offset, size + 2 * offset ] : [ size[0] + 2 * offset, size[1] + 2 * offset ], x, y);
    }
    bounds(size, bounds) {
        const rectSize = (0, vutils_1.isNumber)(size) ? [ size, size ] : size;
        bounds.x1 = -rectSize[0] / 2, bounds.x2 = rectSize[0] / 2, bounds.y1 = -rectSize[1] / 2, 
        bounds.y2 = rectSize[1] / 2;
    }
}

exports.RectSymbol = RectSymbol, exports.default = new RectSymbol;
//# sourceMappingURL=rect.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767782, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CustomSymbolClass = void 0;

const render_command_list_1 = require("../../common/render-command-list");

class CustomSymbolClass {
    constructor(type, path) {
        this.pathStr = "", this.type = type, this.path = path;
    }
    drawOffset(ctx, size, x, y, offset) {
        return (0, render_command_list_1.renderCommandList)(this.path.commandList, ctx, x, y, size + offset, size + offset), 
        !1;
    }
    draw(ctx, size, x, y) {
        return (0, render_command_list_1.renderCommandList)(this.path.commandList, ctx, x, y, size, size), 
        !1;
    }
    bounds(size, bounds) {
        this.path.bounds && (bounds.x1 = this.path.bounds.x1 * size, bounds.y1 = this.path.bounds.y1 * size, 
        bounds.x2 = this.path.bounds.x2 * size, bounds.y2 = this.path.bounds.y2 * size);
    }
}

exports.CustomSymbolClass = CustomSymbolClass;
//# sourceMappingURL=utils.js.map

}, function(modId) { var map = {"../../common/render-command-list":1689069767687}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767783, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Line = void 0;

const graphic_1 = require("./graphic"), theme_1 = require("./theme"), application_1 = require("../application"), utils_1 = require("../common/utils"), custom_path2d_1 = require("../common/custom-path2d"), constants_1 = require("./constants"), LINE_UPDATE_TAG_KEY = [ "segments", "points", "curveType", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Line extends graphic_1.Graphic {
    constructor(params = {}) {
        super(params), this.type = "line", this.numberType = constants_1.LINE_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {points: points, segments: segments} = this.attribute;
        return segments ? 0 !== segments.length : !!points && !(points.length <= 1);
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = (0, utils_1.pointsInterpolation)(lastStepVal, nextStepVal, ratio));
    }
    doUpdateAABBBounds() {
        const lineTheme = (0, theme_1.getTheme)(this).line;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateLineAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).line, this._AABBBounds, this), {boundsPadding: boundsPadding = lineTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return (0, theme_1.getTheme)(this).line[name];
    }
    needUpdateTags(keys) {
        for (let i = 0; i < LINE_UPDATE_TAG_KEY.length; i++) {
            const attrKey = LINE_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < LINE_UPDATE_TAG_KEY.length; i++) {
            if (key === LINE_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    toCustomPath() {
        const attribute = this.attribute, path = new custom_path2d_1.CustomPath2D, segments = attribute.segments, parsePoints = points => {
            if (points && points.length) {
                let isFirst = !0;
                points.forEach((point => {
                    !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), 
                    isFirst = !1);
                }));
            }
        };
        return segments && segments.length ? segments.forEach((seg => {
            parsePoints(seg.points);
        })) : attribute.points && parsePoints(attribute.points), path;
    }
    clone() {
        return new Line(Object.assign({}, this.attribute));
    }
}

exports.Line = Line;
//# sourceMappingURL=line.js.map

}, function(modId) { var map = {"./graphic":1689069767709,"./theme":1689069767707,"../application":1689069767703,"../common/utils":1689069767736,"../common/custom-path2d":1689069767681,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767784, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Rect = void 0;

const graphic_1 = require("./graphic"), custom_path2d_1 = require("../common/custom-path2d"), utils_1 = require("../common/utils"), theme_1 = require("./theme"), application_1 = require("../application"), constants_1 = require("./constants"), RECT_UPDATE_TAG_KEY = [ "width", "height", "cornerRadius", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Rect extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "rect", this.numberType = constants_1.RECT_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {width: width, height: height} = this.attribute;
        return this._validNumber(width) && this._validNumber(height);
    }
    doUpdateAABBBounds() {
        const rectTheme = (0, theme_1.getTheme)(this).rect;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateRectAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).rect, this._AABBBounds, this), {boundsPadding: boundsPadding = rectTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return (0, theme_1.getTheme)(this).rect[name];
    }
    needUpdateTags(keys) {
        for (let i = 0; i < RECT_UPDATE_TAG_KEY.length; i++) {
            const attrKey = RECT_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < RECT_UPDATE_TAG_KEY.length; i++) {
            if (key === RECT_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    toCustomPath() {
        const attribute = this.attribute, width = attribute.width, height = attribute.height, path = new custom_path2d_1.CustomPath2D;
        return path.moveTo(0, 0), path.rect(0, 0, width, height), path;
    }
    clone() {
        return new Rect(Object.assign({}, this.attribute));
    }
}

exports.Rect = Rect;
//# sourceMappingURL=rect.js.map

}, function(modId) { var map = {"./graphic":1689069767709,"../common/custom-path2d":1689069767681,"../common/utils":1689069767736,"./theme":1689069767707,"../application":1689069767703,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767785, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Rect3d = void 0;

const vutils_1 = require("@visactor/vutils"), rect_1 = require("./rect"), theme_1 = require("./theme"), constants_1 = require("./constants"), CUBE_VERTICES = [ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 1, 1, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 1 ], [ 1, 1, 1 ], [ 0, 1, 1 ] ];

class Rect3d extends rect_1.Rect {
    constructor(params) {
        super(params), this.type = "rect3d", this.numberType = constants_1.RECT3D_NUMBER_TYPE;
    }
    findFace() {
        const faces = {
            polygons: [],
            vertices: [],
            edges: []
        }, rectTheme = (0, theme_1.getTheme)(this).rect3d, {width: width = rectTheme.width, height: height = rectTheme.width, length: length = (0, 
        vutils_1.min)(rectTheme.width, rectTheme.height)} = this.attribute;
        for (let i = 0; i < CUBE_VERTICES.length; i++) {
            const v = CUBE_VERTICES[i];
            faces.vertices.push([ v[0] * width, v[1] * height, v[2] * length ]);
        }
        return faces.polygons.push({
            polygon: [ 0, 1, 5, 4 ],
            normal: [ 0, -1, 0 ]
        }), faces.polygons.push({
            polygon: [ 2, 3, 7, 6 ],
            normal: [ 0, 1, 0 ]
        }), faces.polygons.push({
            polygon: [ 4, 7, 3, 0 ],
            normal: [ -1, 0, 0 ]
        }), faces.polygons.push({
            polygon: [ 1, 2, 6, 5 ],
            normal: [ 1, 0, 0 ]
        }), faces.polygons.push({
            polygon: [ 0, 1, 2, 3 ],
            normal: [ 0, 0, -1 ]
        }), faces.polygons.push({
            polygon: [ 4, 5, 6, 7 ],
            normal: [ 0, 0, 1 ]
        }), faces.edges = [ [ 0, 1 ], [ 1, 2 ], [ 2, 3 ], [ 3, 0 ], [ 4, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 4 ], [ 0, 4 ], [ 3, 7 ], [ 1, 5 ], [ 2, 6 ] ], 
        faces;
    }
}

exports.Rect3d = Rect3d;
//# sourceMappingURL=rect3d.js.map

}, function(modId) { var map = {"./rect":1689069767784,"./theme":1689069767707,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767786, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Glyph = void 0;

const graphic_1 = require("./graphic"), theme_1 = require("./theme"), application_1 = require("../application"), constants_1 = require("./constants");

class Glyph extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "glyph", this.numberType = constants_1.GLYPH_NUMBER_TYPE, 
        this.subGraphic = [], this._onInit && this._onInit(this), this.valid = this.isValid();
    }
    setSubGraphic(subGraphic) {
        this.detachSubGraphic(), this.subGraphic = subGraphic, subGraphic.forEach((g => {
            g.glyphHost = this, Object.setPrototypeOf(g.attribute, this.attribute);
        })), this.valid = this.isValid(), this.addUpdateBoundTag();
    }
    detachSubGraphic() {
        this.subGraphic.forEach((g => {
            g.glyphHost = null, Object.setPrototypeOf(g.attribute, {});
        }));
    }
    getSubGraphic() {
        return this.subGraphic;
    }
    onInit(cb) {
        this._onInit = cb;
    }
    onUpdate(cb) {
        this._onUpdate = cb;
    }
    isValid() {
        return !0;
    }
    setAttribute(key, value, forceUpdateTag, context) {
        super.setAttribute(key, value, forceUpdateTag, context), this.subGraphic.forEach((g => {
            g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
        }));
    }
    setAttributes(params, forceUpdateTag = !1, context) {
        super.setAttributes(params, forceUpdateTag, context), this.subGraphic.forEach((g => {
            g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
        }));
    }
    translate(x, y) {
        return super.translate(x, y), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    translateTo(x, y) {
        return super.translateTo(x, y), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    scale(scaleX, scaleY, scaleCenter) {
        return super.scale(scaleX, scaleY, scaleCenter), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    scaleTo(scaleX, scaleY) {
        return super.scaleTo(scaleX, scaleY), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    rotate(angle) {
        return super.rotate(angle), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    rotateTo(angle) {
        return super.rotate(angle), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    doUpdateAABBBounds() {
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const bounds = application_1.application.graphicService.updateGlyphAABBBounds(this.attribute, (0, 
        theme_1.getTheme)(this).glyph, this._AABBBounds, this);
        return this.clearUpdateBoundTag(), bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    needUpdateTags(keys) {
        return !1;
    }
    needUpdateTag(key) {
        return !1;
    }
    useStates(states, hasAnimation) {
        var _a;
        if (!states.length) return void this.clearStates(hasAnimation);
        if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some(((stateName, index) => this.currentStates[index] !== stateName)))) return;
        const stateAttrs = {}, subAttrs = this.subGraphic.map((() => ({})));
        states.forEach((stateName => {
            var _a;
            const attrs = this.glyphStateProxy ? this.glyphStateProxy(stateName, states) : this.glyphStates[stateName];
            attrs && (Object.assign(stateAttrs, attrs.attributes), (null === (_a = attrs.subAttributes) || void 0 === _a ? void 0 : _a.length) && subAttrs.forEach(((subAttrs, index) => {
                Object.assign(subAttrs, attrs.subAttributes[index]);
            })));
        })), this.subGraphic.forEach(((graphic, index) => {
            graphic.updateNormalAttrs(subAttrs[index]), graphic.applyStateAttrs(subAttrs[index], states, hasAnimation);
        })), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
    }
    clearStates(hasAnimation) {
        this.hasState() && this.normalAttrs && (this.subGraphic.forEach((graphic => {
            graphic.applyStateAttrs(graphic.normalAttrs, this.currentStates, hasAnimation, !0), 
            graphic.normalAttrs = null;
        })), this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0), 
        this.normalAttrs = null, this.currentStates = []);
    }
    clone() {
        const glyph = new Glyph(Object.assign({}, this.attribute));
        return glyph.setSubGraphic(this.subGraphic.map((g => g.clone()))), glyph;
    }
}

exports.Glyph = Glyph;
//# sourceMappingURL=glyph.js.map

}, function(modId) { var map = {"./graphic":1689069767709,"./theme":1689069767707,"../application":1689069767703,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767787, function(require, module, exports) {


var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.RichText = void 0;

const graphic_1 = require("./graphic"), config_1 = require("./config"), frame_1 = __importDefault(require("./richtext/frame")), paragraph_1 = __importDefault(require("./richtext/paragraph")), wrapper_1 = __importDefault(require("./richtext/wrapper")), theme_1 = require("./theme"), icon_1 = require("./richtext/icon"), application_1 = require("../application"), utils_1 = require("../common/utils"), constants_1 = require("./constants"), RICHTEXT_UPDATE_TAG_KEY = [ "width", "height", "ellipsis", "wordBreak", "verticalDirection", "maxHeight", "maxWidth", "textAlign", "textBaseline", "textConfig", "layoutDirection", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class RichText extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "richtext", this._currentHoverIcon = null, this.numberType = constants_1.RICHTEXT_NUMBER_TYPE;
    }
    get width() {
        var _a;
        return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.width;
    }
    set width(w) {
        this.attribute.width !== w && (this.attribute.width = w, this.addUpdateShapeAndBoundsTag());
    }
    get height() {
        var _a;
        return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.height;
    }
    set height(h) {
        this.attribute.height !== h && (this.attribute.height = h, this.addUpdateShapeAndBoundsTag());
    }
    get maxWidth() {
        return this.attribute.maxWidth;
    }
    set maxWidth(mw) {
        this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());
    }
    get maxHeight() {
        return this.attribute.maxHeight;
    }
    set maxHeight(mh) {
        this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());
    }
    get ellipsis() {
        var _a;
        return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.ellipsis;
    }
    set ellipsis(e) {
        this.attribute.ellipsis !== e && (this.attribute.ellipsis = e, this.addUpdateShapeAndBoundsTag());
    }
    get wordBreak() {
        var _a;
        return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.wordBreak;
    }
    set wordBreak(wb) {
        this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());
    }
    get verticalDirection() {
        var _a;
        return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.verticalDirection;
    }
    set verticalDirection(vd) {
        this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, 
        this.addUpdateShapeAndBoundsTag());
    }
    get textAlign() {
        var _a;
        return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.textAlign;
    }
    set textAlign(align) {
        this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());
    }
    get textBaseline() {
        var _a;
        return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.textBaseline;
    }
    set textBaseline(baseline) {
        this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, 
        this.addUpdateShapeAndBoundsTag());
    }
    get textConfig() {
        var _a;
        return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.textConfig;
    }
    set textConfig(config) {
        this.attribute.textConfig = config, this.addUpdateShapeAndBoundsTag();
    }
    doUpdateAABBBounds() {
        const richTextTheme = (0, theme_1.getTheme)(this).richtext;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateRichTextAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).richtext, this._AABBBounds, this), {boundsPadding: boundsPadding = richTextTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return config_1.DefaultRichTextAttribute[name];
    }
    needUpdateTags(keys) {
        for (let i = 0; i < RICHTEXT_UPDATE_TAG_KEY.length; i++) {
            const attrKey = RICHTEXT_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < RICHTEXT_UPDATE_TAG_KEY.length; i++) {
            if (key === RICHTEXT_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    getFrameCache() {
        return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), 
        this._frameCache;
    }
    doUpdateFrameCache() {
        var _a;
        const {textConfig: textConfig, maxWidth: maxWidth, maxHeight: maxHeight, width: width, height: height, ellipsis: ellipsis, wordBreak: wordBreak, verticalDirection: verticalDirection, textAlign: textAlign, textBaseline: textBaseline, layoutDirection: layoutDirection, singleLine: singleLine} = this.attribute, paragraphs = [];
        for (let i = 0; i < textConfig.length; i++) if ("image" in textConfig[i]) {
            const config = textConfig[i], iconCache = config.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config.id);
            if (iconCache) paragraphs.push(iconCache); else {
                const icon = new icon_1.RichTextIcon(config);
                icon.successCallback = () => {
                    var _a;
                    this.addUpdateBoundTag(), null === (_a = this.stage) || void 0 === _a || _a.renderNextFrame();
                }, icon.richtextId = config.id, paragraphs.push(icon);
            }
        } else if (textConfig[i].text.includes("\n")) {
            const textParts = textConfig[i].text.split("\n");
            for (let j = 0; j < textParts.length; j++) paragraphs.push(new paragraph_1.default(textParts[j], 0 !== j, textConfig[i]));
        } else paragraphs.push(new paragraph_1.default(textConfig[i].text, !1, textConfig[i]));
        const frameHeight = "number" == typeof maxHeight && (!height || height > maxHeight) ? maxHeight : height, frameWidth = "number" == typeof maxWidth && (!width || width > maxWidth) ? maxWidth : width, frame = new frame_1.default(0, 0, frameWidth || 0, frameHeight || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || "horizontal", "number" == typeof maxWidth && (!width || width > maxWidth), "number" == typeof maxHeight && (!height || height > maxHeight), singleLine || !1, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons), wrapper = new wrapper_1.default(frame);
        for (let i = 0; i < paragraphs.length; i++) wrapper.deal(paragraphs[i]);
        wrapper.send(), this._frameCache = frame;
    }
    clone() {
        return new RichText(Object.assign({}, this.attribute));
    }
    setStage(stage, layer) {
        super.setStage(stage, layer);
        this.getFrameCache().icons.forEach((icon => {
            icon.setStage(stage, layer);
        }));
    }
    bindIconEvent() {
        this.addEventListener("pointermove", (e => {
            var _a, _b, _c, _d, _e;
            const pickedIcon = this.pickIcon(e.global);
            pickedIcon && pickedIcon === this._currentHoverIcon || (pickedIcon ? (null === (_a = this._currentHoverIcon) || void 0 === _a || _a.setHoverState(!1), 
            this._currentHoverIcon = pickedIcon, this._currentHoverIcon.setHoverState(!0), null === (_b = this.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), 
            null === (_c = this.stage) || void 0 === _c || _c.renderNextFrame()) : !pickedIcon && this._currentHoverIcon && (this._currentHoverIcon.setHoverState(!1), 
            this._currentHoverIcon = null, null === (_d = this.stage) || void 0 === _d || _d.setCursor(), 
            null === (_e = this.stage) || void 0 === _e || _e.renderNextFrame()));
        })), this.addEventListener("pointerleave", (e => {
            var _a, _b;
            this._currentHoverIcon && (this._currentHoverIcon.setHoverState(!1), this._currentHoverIcon = null, 
            null === (_a = this.stage) || void 0 === _a || _a.setCursor(), null === (_b = this.stage) || void 0 === _b || _b.renderNextFrame());
        }));
    }
    pickIcon(point) {
        const frameCache = this.getFrameCache(), {e: x, f: y} = this.globalTransMatrix;
        let pickIcon;
        return frameCache.icons.forEach((icon => {
            var _a, _b;
            icon.AABBBounds.containsPoint({
                x: point.x - x,
                y: point.y - y
            }) && (pickIcon = icon, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x, 
            pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y);
        })), pickIcon;
    }
}

exports.RichText = RichText;
//# sourceMappingURL=richtext.js.map

}, function(modId) { var map = {"./graphic":1689069767709,"./config":1689069767680,"./richtext/frame":1689069767788,"./richtext/paragraph":1689069767790,"./richtext/wrapper":1689069767791,"./theme":1689069767707,"./richtext/icon":1689069767793,"../application":1689069767703,"../common/utils":1689069767736,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767788, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const utils_1 = require("./utils");

class Frame {
    constructor(left, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {
        this.left = left, this.top = top, this.width = width, this.height = height, this.actualHeight = 0, 
        this.bottom = top + height, this.right = left + width, this.ellipsis = ellipsis, 
        this.wordBreak = wordBreak, this.verticalDirection = verticalDirection, this.lines = [], 
        this.globalAlign = globalAlign, this.globalBaseline = globalBaseline, this.layoutDirection = layoutDirection, 
        this.directionKey = utils_1.DIRECTION_KEY[this.layoutDirection], this.isWidthMax = isWidthMax, 
        this.isHeightMax = isHeightMax, this.singleLine = singleLine, icons ? (icons.clear(), 
        this.icons = icons) : this.icons = new Map;
    }
    draw(ctx, drawIcon) {
        const {width: actualWidth, height: actualHeight} = this.getActualSize(), width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
        let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
        height = Math.min(height, actualHeight);
        let deltaY = 0;
        switch (this.globalBaseline) {
          case "top":
            deltaY = 0;
            break;

          case "middle":
            deltaY = -height / 2;
            break;

          case "bottom":
            deltaY = -height;
        }
        let deltaX = 0;
        switch (this.globalAlign) {
          case "left":
            deltaX = 0;
            break;

          case "center":
            deltaX = -width / 2;
            break;

          case "right":
            deltaX = -width;
        }
        let frameHeight = this[this.directionKey.height];
        this.singleLine && (frameHeight = this.lines[0].height + 1);
        let lastLineTag = !1;
        if ("middle" === this.verticalDirection) if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
            const {top: top, height: height} = this.lines[i];
            if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;
            let lastLine = !1;
            this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, 
            lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon);
        } else {
            const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
            "vertical" === this.layoutDirection ? deltaX += detalHeight : deltaY += detalHeight;
            for (let i = 0; i < this.lines.length; i++) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon);
        } else if ("bottom" === this.verticalDirection && "vertical" !== this.layoutDirection) for (let i = 0; i < this.lines.length; i++) {
            const {top: top, height: height} = this.lines[i], y = frameHeight - this.lines[i].top - this.lines[i].height;
            if (0 === frameHeight) this.lines[i].draw(ctx, !1, deltaX, y + deltaY, drawIcon); else {
                if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) return lastLineTag;
                {
                    let lastLine = !1;
                    this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top] && (lastLine = !0, 
                    lastLineTag = !0), this.lines[i].draw(ctx, lastLine, deltaX, y + deltaY, drawIcon);
                }
            }
        } else {
            "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && this.singleLine && this.isWidthMax && (deltaX += this.lines[0].height + 1);
            for (let i = 0; i < this.lines.length; i++) {
                "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && (deltaX -= this.lines[i].height + this.lines[i].top);
                const {top: top, height: height} = this.lines[i];
                if (0 === frameHeight) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon); else {
                    if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;
                    {
                        let lastLine = !1;
                        this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, 
                        lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon);
                    }
                }
            }
        }
        return lastLineTag;
    }
    getActualSize() {
        return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();
    }
    getRawActualSize() {
        let width = 0, height = 0;
        for (let i = 0; i < this.lines.length; i++) {
            const line = this.lines[i];
            line.actualWidth > width && (width = line.actualWidth), height += line.height;
        }
        return {
            width: "vertical" === this.layoutDirection ? height : width,
            height: "vertical" === this.layoutDirection ? width : height
        };
    }
    getActualSizeWidthEllipsis() {
        let widthBound = 0, heightBound = 0;
        const {width: actualWidth, height: actualHeight} = this.getRawActualSize();
        this.width;
        let height = this.height || actualHeight || 0;
        height = Math.min(height, actualHeight);
        let frameHeight = this[this.directionKey.height];
        if (this.singleLine && (frameHeight = this.lines[0].height + 1), "middle" === this.verticalDirection) if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
            const {top: top, height: height} = this.lines[i];
            if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ; else if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
                const lineWidth = this.lines[i].getWidthWithEllips();
                lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
            } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), 
            heightBound += this.lines[i].height;
        } else {
            Math.floor((frameHeight - this.actualHeight) / 2);
            for (let i = 0; i < this.lines.length; i++) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), 
            heightBound += this.lines[i].height;
        } else if ("bottom" === this.verticalDirection) for (let i = 0; i < this.lines.length; i++) {
            const {top: top, height: height} = this.lines[i], y = frameHeight - this.lines[i].top - this.lines[i].height;
            if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), 
            heightBound += this.lines[i].height; else if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) ; else {
                if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
                    const lineWidth = this.lines[i].getWidthWithEllips();
                    lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
                } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), 
                heightBound += this.lines[i].height;
            }
        } else for (let i = 0; i < this.lines.length; i++) {
            const {top: top, height: height} = this.lines[i];
            if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), 
            heightBound += this.lines[i].height; else if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ; else {
                if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
                    const lineWidth = this.lines[i].getWidthWithEllips();
                    lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
                } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), 
                heightBound += this.lines[i].height;
            }
        }
        return {
            width: "vertical" === this.layoutDirection ? heightBound : widthBound,
            height: "vertical" === this.layoutDirection ? widthBound : heightBound
        };
    }
}

exports.default = Frame;
//# sourceMappingURL=frame.js.map

}, function(modId) { var map = {"./utils":1689069767789}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767789, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getFontString = exports.measureTextCanvas = exports.measureTextDom = exports.testLetter = exports.getStrByWithCanvas = exports.getStrByWithDom = exports.prepareContext = exports.applyStrokeStyle = exports.applyFillStyle = exports.regFirstSpace = exports.regLetter = exports.DIRECTION_KEY = void 0;

const application_1 = require("../../application");

exports.DIRECTION_KEY = {
    horizontal: {
        width: "width",
        height: "height",
        left: "left",
        top: "top",
        x: "x",
        y: "y",
        bottom: "bottom"
    },
    vertical: {
        width: "height",
        height: "width",
        left: "top",
        top: "left",
        x: "y",
        y: "x",
        bottom: "right"
    }
};

const defaultFormatting = {
    fontSize: 16,
    fontFamily: "sans-serif",
    fill: !0,
    stroke: !1,
    fontWeight: "normal",
    lineHeight: "normal",
    fontStyle: "normal",
    textDecoration: "none",
    textAlign: "left",
    script: "normal"
}, nbsp = String.fromCharCode(160);

exports.regLetter = /\w|\(|\)/;

const regPunctuation = /[.?!,;:/，。？！、；：]/;

function applyFillStyle(ctx, character) {
    const fillStyle = character && character.fill || defaultFormatting.fill;
    if (!fillStyle) return void (ctx.globalAlpha = 0);
    ctx.globalAlpha = 1, ctx.fillStyle = fillStyle;
    let fontSize = character.fontSize || 16;
    switch (character.script) {
      case "super":
      case "sub":
        fontSize *= .8;
    }
    ctx.setTextStyle({
        textAlign: "left",
        textBaseline: character.textBaseline || "alphabetic",
        fontStyle: character.fontStyle || "",
        fontWeight: character.fontWeight || "",
        fontSize: fontSize,
        fontFamily: character.fontFamily || "sans-serif"
    });
}

function applyStrokeStyle(ctx, character) {
    const strokeStyle = character && character.stroke || defaultFormatting.stroke;
    if (!strokeStyle) return void (ctx.globalAlpha = 0);
    ctx.globalAlpha = 1, ctx.lineWidth = 1, ctx.strokeStyle = strokeStyle;
    let fontSize = character.fontSize || 16;
    switch (character.script) {
      case "super":
      case "sub":
        fontSize *= .8;
    }
    ctx.setTextStyle({
        textAlign: "left",
        textBaseline: character.textBaseline || "alphabetic",
        fontStyle: character.fontStyle || "",
        fontWeight: character.fontWeight || "",
        fontSize: fontSize,
        fontFamily: character.fontFamily || "sans-serif"
    });
}

function prepareContext(ctx) {
    ctx.setTextStyle({
        textAlign: "left",
        textBaseline: "bottom"
    });
}

function getStrByWithDom(desc, width, style, guessIndex, needTestLetter) {
    desc = desc.replace(/\s/g, nbsp);
    const span = document.createElement("span");
    span.setAttribute("style", style), span.style.visibility = "hidden", span.style.whiteSpace = "nowrap", 
    document.body.appendChild(span);
    let index = guessIndex, temp = desc.slice(0, index);
    span.innerText = temp;
    let tempWidth = span.offsetWidth, tempNext = desc.slice(0, index + 1);
    span.innerText = tempNext;
    let tempWidthNext = span.offsetWidth;
    for (;tempWidth > width || tempWidthNext <= width; ) tempWidth > width ? index-- : index++, 
    temp = desc.slice(0, index), span.innerText = temp, tempWidth = span.offsetWidth, 
    tempNext = desc.slice(0, index + 1), span.innerText = tempNext, tempWidthNext = span.offsetWidth;
    return needTestLetter && (index = testLetter(desc, index)), document.body.removeChild(span), 
    index;
}

function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
    if (!width || width <= 0) return 0;
    const textMeasure = application_1.application.graphicUtil.textMeasure;
    let index = guessIndex, temp = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
    for (;tempWidth > width || tempWidthNext <= width; ) {
        if (tempWidth > width ? index-- : index++, index > desc.length) {
            index = desc.length;
            break;
        }
        if (index < 0) {
            index = 0;
            break;
        }
        temp = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp, character).width), 
        tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
    }
    return needTestLetter && (index = testLetter(desc, index)), index;
}

function testLetter(string, index) {
    let i = index;
    for (;exports.regLetter.test(string[i - 1]) && exports.regLetter.test(string[i]) || regPunctuation.test(string[i]); ) if (i--, 
    i <= 0) return index;
    return i;
}

function measureTextDom(text, style) {
    var _a;
    let div;
    const span = document.createElement("span"), block = document.createElement("div");
    div = document.createElement("div"), block.style.display = "inline-block", block.style.width = "1px", 
    block.style.height = "0", div.style.visibility = "hidden", div.style.position = "absolute", 
    div.style.top = "0", div.style.left = "0", div.style.width = "500px", div.style.height = "200px", 
    div.style.whiteSpace = "nowrap", div.appendChild(span), div.appendChild(block), 
    document.body.appendChild(div);
    const result = {};
    try {
        span.setAttribute("style", style), span.style.whiteSpace = "nowrap", span.style.display = "inline-block", 
        span.innerHTML = "", span.appendChild(document.createTextNode(text.replace(/\s/g, nbsp))), 
        block.style.verticalAlign = "baseline", result.ascent = block.offsetTop - span.offsetTop, 
        block.style.verticalAlign = "bottom", result.height = block.offsetTop - span.offsetTop, 
        result.descent = result.height - result.ascent, result.width = span.offsetWidth;
    } finally {
        null === (_a = div.parentNode) || void 0 === _a || _a.removeChild(div), div = null;
    }
    return result;
}

function measureTextCanvas(text, character) {
    const measurement = application_1.application.graphicUtil.textMeasure.measureText(text, character), result = {
        ascent: 0,
        height: 0,
        descent: 0,
        width: 0
    };
    return "number" != typeof measurement.actualBoundingBoxAscent || "number" != typeof measurement.actualBoundingBoxDescent ? (result.width = Math.floor(measurement.width), 
    result.height = character.fontSize || 0, result.ascent = result.height, result.descent = 0) : (result.width = Math.floor(measurement.width), 
    result.height = Math.floor(measurement.actualBoundingBoxAscent + measurement.actualBoundingBoxDescent), 
    result.ascent = Math.floor(measurement.actualBoundingBoxAscent), result.descent = result.height - result.ascent), 
    result;
}

function getFontString(character, ctx) {
    let fontSize = character && character.fontSize || defaultFormatting.fontSize;
    if (character) switch (character.script) {
      case "super":
      case "sub":
        fontSize *= .8;
    }
    return (character && character.fontStyle || "") + " " + (character && character.fontWeight || "") + " " + (fontSize || 12) + "px " + (character && character.fontFamily || defaultFormatting.fontFamily);
}

exports.regFirstSpace = /\S/, exports.applyFillStyle = applyFillStyle, exports.applyStrokeStyle = applyStrokeStyle, 
exports.prepareContext = prepareContext, exports.getStrByWithDom = getStrByWithDom, 
exports.getStrByWithCanvas = getStrByWithCanvas, exports.testLetter = testLetter, 
exports.measureTextDom = measureTextDom, exports.measureTextCanvas = measureTextCanvas, 
exports.getFontString = getFontString;
//# sourceMappingURL=utils.js.map

}, function(modId) { var map = {"../../application":1689069767703}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767790, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.seperateParagraph = void 0;

const utils_1 = require("./utils");

class Paragraph {
    constructor(text, newLine, character) {
        this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || "alphabetic", 
        "number" == typeof character.lineHeight ? this.lineHeight = character.lineHeight > this.fontSize ? character.lineHeight : this.fontSize : this.lineHeight = Math.floor(1.2 * this.fontSize), 
        this.height = this.lineHeight;
        const {ascent: ascent, height: height, descent: descent, width: width} = (0, utils_1.measureTextCanvas)(text, character);
        let halfDetaHeight = 0, deltaAscent = 0, deltaDescent = 0;
        this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), 
        deltaDescent = Math.floor(halfDetaHeight)), "top" === this.textBaseline ? (this.ascent = halfDetaHeight, 
        this.descent = height - halfDetaHeight) : "bottom" === this.textBaseline ? (this.ascent = height - halfDetaHeight, 
        this.descent = halfDetaHeight) : "middle" === this.textBaseline ? (this.ascent = this.height / 2, 
        this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), 
        this.length = text.length, this.width = width || 0, this.text = text || "", this.newLine = newLine || !1, 
        this.character = character, this.left = 0, this.top = 0, this.ellipsis = "normal", 
        this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, "vertical" === character.direction && (this.direction = character.direction, 
        this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, 
        this.height = this.widthOrigin, this.lineHeight = this.height);
    }
    updateWidth() {
        const {width: width} = (0, utils_1.measureTextCanvas)(this.text, this.character);
        this.width = width, "vertical" === this.direction && (this.widthOrigin = this.width, 
        this.width = this.heightOrigin, this.height = this.widthOrigin);
    }
    draw(ctx, baseline, deltaLeft, isLineFirst, textAlign) {
        let text = this.text, left = this.left + deltaLeft;
        baseline += this.top;
        let direction = this.direction;
        if (this.verticalEllipsis) text = "...", direction = "vertical", baseline -= this.ellipsisWidth / 2; else {
            if ("hide" === this.ellipsis) return;
            if ("add" === this.ellipsis) text += "...", "right" === textAlign && (left -= this.ellipsisWidth); else if ("replace" === this.ellipsis) {
                const index = (0, utils_1.getStrByWithCanvas)(text, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
                if (text = text.slice(0, index), text += "...", "right" === textAlign) {
                    const {width: width} = (0, utils_1.measureTextCanvas)(this.text.slice(index), this.character);
                    "vertical" === direction || (left -= this.ellipsisWidth - width);
                }
            }
        }
        switch (this.character.script) {
          case "super":
            baseline -= this.ascent * (1 / 3);
            break;

          case "sub":
            baseline += this.descent / 2;
        }
        "vertical" === direction && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left, baseline), 
        ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left, baseline), 
        left = 0, baseline = 0), this.character.stroke && ((0, utils_1.applyStrokeStyle)(ctx, this.character), 
        ctx.strokeText(text, left, baseline)), (0, utils_1.applyFillStyle)(ctx, this.character), 
        this.character.fill && ctx.fillText(text, left, baseline), this.character.fill && ("boolean" == typeof this.character.lineThrough || "boolean" == typeof this.character.underline ? (this.character.underline && ctx.fillRect(left, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1), 
        this.character.lineThrough && ctx.fillRect(left, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)) : "underline" === this.character.textDecoration ? ctx.fillRect(left, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1) : "line-through" === this.character.textDecoration && ctx.fillRect(left, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)), 
        "vertical" === direction && ctx.restore();
    }
    getWidthWithEllips(direction) {
        let text = this.text;
        const width = "vertical" === direction ? this.height : this.width;
        if ("hide" === this.ellipsis) return width;
        if ("add" === this.ellipsis) return width + this.ellipsisWidth;
        if ("replace" === this.ellipsis) {
            const index = (0, utils_1.getStrByWithCanvas)(text, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
            text = text.slice(0, index), text += "...";
            const {width: measureWidth} = (0, utils_1.measureTextCanvas)(this.text.slice(index), this.character);
            return width + this.ellipsisWidth - measureWidth;
        }
        return width;
    }
}

function seperateParagraph(paragraph, index) {
    const text1 = paragraph.text.slice(0, index), text2 = paragraph.text.slice(index);
    return [ new Paragraph(text1, paragraph.newLine, paragraph.character), new Paragraph(text2, !0, paragraph.character) ];
}

exports.default = Paragraph, exports.seperateParagraph = seperateParagraph;
//# sourceMappingURL=paragraph.js.map

}, function(modId) { var map = {"./utils":1689069767789}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767791, function(require, module, exports) {


var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

const line_1 = __importDefault(require("./line")), paragraph_1 = require("./paragraph"), utils_1 = require("./utils"), icon_1 = require("./icon");

class Wrapper {
    constructor(frame) {
        this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, 
        this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, 
        this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, 
        this.directionKey = utils_1.DIRECTION_KEY[this.direction];
    }
    store(paragraph) {
        if (paragraph instanceof icon_1.RichTextIcon) {
            this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), 
            this.lineWidth += paragraph[this.directionKey.width];
            let iconAscent = 0, iconDescent = 0;
            "top" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : "bottom" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, 
            iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), 
            this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);
        } else this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], 
        this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), 
        this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));
    }
    send() {
        if (0 === this.lineBuffer.length) return;
        const maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent, maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent, line = new line_1.default(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, "horizontal" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);
        this.frame.lines.push(line), this.frame.actualHeight += line.height, this.y += line.height, 
        this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
    }
    deal(paragraph) {
        paragraph instanceof icon_1.RichTextIcon ? "horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), 
        this.send()) : (this.send(), this.deal(paragraph)) : "number" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), 
        0 !== paragraph.text.length && ("horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), 
        this.deal(paragraph)) : this.cut(paragraph)));
    }
    cut(paragraph) {
        const availableWidth = this[this.directionKey.width] - this.lineWidth || 0, guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0, index = (0, 
        utils_1.getStrByWithCanvas)(paragraph.text, availableWidth, paragraph.character, guessIndex, "break-word" === this.frame.wordBreak);
        if (0 !== index) {
            const [p1, p2] = (0, paragraph_1.seperateParagraph)(paragraph, index);
            this.store(p1), this.deal(p2);
        } else 0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));
    }
}

exports.default = Wrapper;
//# sourceMappingURL=wrapper.js.map

}, function(modId) { var map = {"./line":1689069767792,"./paragraph":1689069767790,"./utils":1689069767789,"./icon":1689069767793}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767792, function(require, module, exports) {


var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

const icon_1 = require("./icon"), paragraph_1 = __importDefault(require("./paragraph")), utils_1 = require("./utils");

class Line {
    constructor(left, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {
        this.left = left, this.width = width, this.baseline = baseline, this.ascent = ascent, 
        this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map((p => p)), 
        this.textAlign = (this.paragraphs[0] instanceof icon_1.RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || "left", 
        this.direction = direction, this.directionKey = utils_1.DIRECTION_KEY[this.direction];
        const directionKey = this.directionKey;
        this.actualWidth = 0;
        let maxHeight = 0;
        this.paragraphs.forEach(((word, index) => {
            if (0 === index && word instanceof paragraph_1.default) {
                const result = utils_1.regFirstSpace.exec(word.text);
                0 !== (null == result ? void 0 : result.index) && (word.text = word.text.slice(null == result ? void 0 : result.index), 
                word.updateWidth());
            }
            this.actualWidth += word[this.directionKey.width], maxHeight = Math.max(word[this.directionKey.height], maxHeight);
        })), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth;
        let x = this.left, spacing = 0;
        if (this.actualWidth < width && !isWidthMax) switch (this.textAlign) {
          case "right":
            x = width - this.actualWidth;
            break;

          case "center":
            x = (width - this.actualWidth) / 2;
            break;

          case "justify":
            this.paragraphs.length < 2 ? x = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1);
        }
        this.paragraphs.map((function(paragraph) {
            paragraph instanceof icon_1.RichTextIcon ? (paragraph["_" + directionKey.x] = x, 
            x += paragraph[directionKey.width] + spacing, paragraph["_" + directionKey.y] = "top" === paragraph.attribute.textBaseline ? 0 : "bottom" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x, 
            x += paragraph[directionKey.width] + spacing);
        }));
    }
    draw(ctx, lastLine, x, y, drawIcon) {
        if (lastLine) {
            let otherParagraphWidth = 0;
            for (let i = this.paragraphs.length - 1; i >= 0; i--) {
                const paragraph = this.paragraphs[i];
                if (paragraph instanceof icon_1.RichTextIcon) break;
                if ("vertical" === this.direction && "vertical" !== paragraph.direction) {
                    paragraph.verticalEllipsis = !0;
                    break;
                }
                const {width: width} = (0, utils_1.measureTextCanvas)("...", paragraph.character), ellipsisWidth = width || 0;
                if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
                    paragraph.ellipsis = "add";
                    break;
                }
                if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
                    paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
                    break;
                }
                paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
            }
        }
        this.paragraphs.map(((paragraph, index) => {
            if (paragraph instanceof icon_1.RichTextIcon) return paragraph.setAttributes({
                x: x + paragraph._x,
                y: y + paragraph._y
            }), void drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);
            paragraph.draw(ctx, y + this.ascent, x, 0 === index, this.textAlign);
        }));
    }
    getWidthWithEllips() {
        let otherParagraphWidth = 0;
        for (let i = this.paragraphs.length - 1; i >= 0; i--) {
            const paragraph = this.paragraphs[i];
            if (paragraph instanceof icon_1.RichTextIcon) break;
            const {width: width} = (0, utils_1.measureTextCanvas)("...", paragraph.character), ellipsisWidth = width || 0;
            if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
                paragraph.ellipsis = "add", paragraph.ellipsisWidth = ellipsisWidth;
                break;
            }
            if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
                paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
                break;
            }
            paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
        }
        let width = 0;
        return this.paragraphs.map(((paragraph, index) => {
            paragraph instanceof icon_1.RichTextIcon ? width += paragraph.width : width += paragraph.getWidthWithEllips(this.direction);
        })), width;
    }
}

exports.default = Line;
//# sourceMappingURL=line.js.map

}, function(modId) { var map = {"./icon":1689069767793,"./paragraph":1689069767790,"./utils":1689069767789}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767793, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.RichTextIcon = void 0;

const vutils_1 = require("@visactor/vutils"), image_1 = require("../image"), config_1 = require("../config"), utils_1 = require("../../common/utils");

class RichTextIcon extends image_1.Image {
    constructor(params) {
        if (super(params), this._x = 0, this._y = 0, this._hovered = !1, this._marginArray = [ 0, 0, 0, 0 ], 
        "always" === params.backgroundShowMode && (this._hovered = !0), params.margin) {
            const marginArray = (0, utils_1.parsePadding)(params.margin);
            this._marginArray = "number" == typeof marginArray ? [ marginArray, marginArray, marginArray, marginArray ] : marginArray;
        }
        this.onBeforeAttributeUpdate = (val, attributes, key) => {
            if ((0, vutils_1.isArray)(key) && -1 !== key.indexOf("margin") || "margin" === key) if (attributes.margin) {
                const marginArray = (0, utils_1.parsePadding)(attributes.margin);
                this._marginArray = "number" == typeof marginArray ? [ marginArray, marginArray, marginArray, marginArray ] : marginArray;
            } else this._marginArray = [ 0, 0, 0, 0 ];
        };
    }
    get width() {
        var _a;
        return (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + this._marginArray[1] + this._marginArray[3];
    }
    get height() {
        var _a;
        return (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + this._marginArray[0] + this._marginArray[2];
    }
    tryUpdateAABBBounds() {
        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
        this.doUpdateAABBBounds();
        const {width: width = config_1.DefaultImageAttribute.width, height: height = config_1.DefaultImageAttribute.height} = this.attribute, {backgroundWidth: backgroundWidth = width, backgroundHeight: backgroundHeight = height} = this.attribute, expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;
        return this._AABBBounds.expand([ 0, 2 * expandX, 2 * expandY, 0 ]), this._AABBBounds;
    }
    setHoverState(hovered) {
        "hover" === this.attribute.backgroundShowMode && this._hovered !== hovered && (this._hovered = hovered);
    }
}

exports.RichTextIcon = RichTextIcon;
//# sourceMappingURL=icon.js.map

}, function(modId) { var map = {"../image":1689069767794,"../config":1689069767680,"../../common/utils":1689069767736}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767794, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Image = void 0;

const graphic_1 = require("./graphic"), config_1 = require("./config"), theme_1 = require("./theme"), application_1 = require("../application"), utils_1 = require("../common/utils"), constants_1 = require("./constants"), IMAGE_UPDATE_TAG_KEY = [ "width", "height", "image", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Image extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "image", this.numberType = constants_1.IMAGE_NUMBER_TYPE, 
        this.loadImage(this.attribute.image);
    }
    get width() {
        var _a;
        return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0;
    }
    set width(width) {
        this.attribute.width === width && (this.attribute.width = width, this.addUpdateShapeAndBoundsTag());
    }
    get height() {
        var _a;
        return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0;
    }
    set height(height) {
        this.attribute.height === height && (this.attribute.height = height, this.addUpdateShapeAndBoundsTag());
    }
    get repeatX() {
        var _a;
        return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
    }
    set repeatX(repeatX) {
        this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
    }
    get repeatY() {
        var _a;
        return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
    }
    set repeatY(repeatY) {
        this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
    }
    get image() {
        return this.attribute.image;
    }
    set image(image) {
        image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
    }
    imageLoadSuccess(url, image, cb) {
        super.imageLoadSuccess(url, image, (() => {
            this.successCallback && this.successCallback();
        }));
    }
    imageLoadFail(url, cb) {
        super.imageLoadFail(url, (() => {
            this.failCallback && this.failCallback();
        }));
    }
    doUpdateAABBBounds() {
        const imageTheme = (0, theme_1.getTheme)(this).image;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateImageAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).image, this._AABBBounds, this), {boundsPadding: boundsPadding = imageTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return config_1.DefaultImageAttribute[name];
    }
    needUpdateTags(keys) {
        for (let i = 0; i < IMAGE_UPDATE_TAG_KEY.length; i++) {
            const attrKey = IMAGE_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < IMAGE_UPDATE_TAG_KEY.length; i++) {
            if (key === IMAGE_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    clone() {
        return new Image(Object.assign({}, this.attribute));
    }
}

exports.Image = Image;
//# sourceMappingURL=image.js.map

}, function(modId) { var map = {"./graphic":1689069767709,"./config":1689069767680,"./theme":1689069767707,"../application":1689069767703,"../common/utils":1689069767736,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767795, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Path = void 0;

const vutils_1 = require("@visactor/vutils"), graphic_1 = require("./graphic"), utils_1 = require("../common/utils"), custom_path2d_1 = require("../common/custom-path2d"), theme_1 = require("./theme"), application_1 = require("../application"), constants_1 = require("./constants"), PATH_UPDATE_TAG_KEY = [ "path", "customPath", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Path extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "path", this.numberType = constants_1.PATH_NUMBER_TYPE;
    }
    get pathShape() {
        return this.tryUpdateAABBBounds(), this.getParsedPathShape();
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {path: path} = this.attribute;
        return null != path && "" !== path;
    }
    getParsedPathShape() {
        const pathTheme = (0, theme_1.getTheme)(this).path;
        if (!this.valid) return pathTheme.path;
        const attribute = this.attribute;
        return attribute.path instanceof custom_path2d_1.CustomPath2D ? attribute.path : ((0, 
        vutils_1.isNil)(this.cache) && this.doUpdatePathShape(), this.cache instanceof custom_path2d_1.CustomPath2D ? this.cache : pathTheme.path);
    }
    doUpdateAABBBounds() {
        const pathTheme = (0, theme_1.getTheme)(this).path;
        this.doUpdatePathShape(), this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updatePathAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).path, this._AABBBounds, this), {boundsPadding: boundsPadding = pathTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    doUpdatePathShape() {
        const attribute = this.attribute;
        (0, vutils_1.isString)(attribute.path, !0) ? this.cache = (new custom_path2d_1.CustomPath2D).fromString(attribute.path) : attribute.customPath && (this.cache = new custom_path2d_1.CustomPath2D, 
        attribute.customPath(this.cache, this));
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    getDefaultAttribute(name) {
        return (0, theme_1.getTheme)(this).path[name];
    }
    needUpdateTags(keys) {
        for (let i = 0; i < PATH_UPDATE_TAG_KEY.length; i++) {
            const attrKey = PATH_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < PATH_UPDATE_TAG_KEY.length; i++) {
            if (key === PATH_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    toCustomPath() {
        return (new custom_path2d_1.CustomPath2D).fromCustomPath2D(this.getParsedPathShape(), 0, 0);
    }
    clone() {
        return new Path(Object.assign({}, this.attribute));
    }
}

exports.Path = Path;
//# sourceMappingURL=path.js.map

}, function(modId) { var map = {"./graphic":1689069767709,"../common/utils":1689069767736,"../common/custom-path2d":1689069767681,"./theme":1689069767707,"../application":1689069767703,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767796, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Area = void 0;

const graphic_1 = require("./graphic"), custom_path2d_1 = require("../common/custom-path2d"), utils_1 = require("../common/utils"), theme_1 = require("./theme"), application_1 = require("../application"), constants_1 = require("./constants"), AREA_UPDATE_TAG_KEY = [ "segments", "points", "curveType", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Area extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "area", this.numberType = constants_1.AREA_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {points: points, segments: segments} = this.attribute;
        return segments ? 0 !== segments.length : !!points && 0 !== points.length;
    }
    doUpdateAABBBounds() {
        const areaTheme = (0, theme_1.getTheme)(this).area;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateAreaAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).area, this._AABBBounds, this), {boundsPadding: boundsPadding = areaTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = (0, utils_1.pointsInterpolation)(lastStepVal, nextStepVal, ratio));
    }
    getDefaultAttribute(name) {
        return (0, theme_1.getTheme)(this).area[name];
    }
    needUpdateTags(keys) {
        for (let i = 0; i < AREA_UPDATE_TAG_KEY.length; i++) {
            const attrKey = AREA_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < AREA_UPDATE_TAG_KEY.length; i++) {
            if (key === AREA_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    toCustomPath() {
        const path = new custom_path2d_1.CustomPath2D, attribute = this.attribute, segments = attribute.segments, parsePoints = points => {
            if (points && points.length) {
                let isFirst = !0;
                const basePoints = [];
                if (points.forEach((point => {
                    var _a, _b;
                    !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), 
                    basePoints.push({
                        x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,
                        y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y
                    }), isFirst = !1);
                })), basePoints.length) {
                    for (let i = basePoints.length - 1; i >= 0; i--) path.lineTo(basePoints[i].x, basePoints[i].y);
                    path.closePath();
                }
            }
        };
        return attribute.points ? parsePoints(attribute.points) : segments && segments.length && segments.forEach((seg => {
            parsePoints(seg.points);
        })), path;
    }
    clone() {
        return new Area(Object.assign({}, this.attribute));
    }
}

exports.Area = Area;
//# sourceMappingURL=area.js.map

}, function(modId) { var map = {"./graphic":1689069767709,"../common/custom-path2d":1689069767681,"../common/utils":1689069767736,"./theme":1689069767707,"../application":1689069767703,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767797, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Arc = void 0;

const vutils_1 = require("@visactor/vutils"), graphic_1 = require("./graphic"), custom_path2d_1 = require("../common/custom-path2d"), utils_1 = require("../common/utils"), theme_1 = require("./theme"), application_1 = require("../application"), constants_1 = require("./constants"), ARC_UPDATE_TAG_KEY = [ "innerRadius", "outerRadius", "startAngle", "endAngle", "cornerRadius", "padAngle", "padRadius", "cap", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Arc extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "arc", this.numberType = constants_1.ARC_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {startAngle: startAngle, endAngle: endAngle, outerRadius: outerRadius, innerRadius: innerRadius} = this.attribute;
        return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);
    }
    getParsedCornerRadius() {
        const arcTheme = (0, theme_1.getTheme)(this).arc, {cornerRadius: cornerRadius = arcTheme.cornerRadius, outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius} = this.attribute;
        if (0 === cornerRadius || "0%" === cornerRadius) return 0;
        const deltaRadius = Math.abs(outerRadius - innerRadius);
        return Math.min((0, vutils_1.isNumber)(cornerRadius, !0) ? cornerRadius : deltaRadius * parseFloat(cornerRadius) / 100, deltaRadius / 2);
    }
    getParsedAngle() {
        const arcTheme = (0, theme_1.getTheme)(this).arc;
        let {startAngle: startAngle = arcTheme.startAngle, endAngle: endAngle = arcTheme.endAngle} = this.attribute;
        const {cap: cap = arcTheme.cap} = this.attribute, sign = endAngle - startAngle >= 0 ? 1 : -1, deltaAngle = endAngle - startAngle;
        if (startAngle = (0, vutils_1.clampAngleByRadian)(startAngle), endAngle = startAngle + deltaAngle, 
        cap && (0, vutils_1.abs)(deltaAngle) < vutils_1.pi2 - vutils_1.epsilon) {
            let startCap = 1, endCap = 1;
            cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));
            const {outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius} = this.attribute, capWidth = Math.abs(outerRadius - innerRadius) / 2, capAngle = capWidth / outerRadius;
            if (capWidth > vutils_1.epsilon && outerRadius > vutils_1.epsilon) return {
                startAngle: startAngle - sign * capAngle * startCap,
                endAngle: endAngle + sign * capAngle * endCap
            };
        }
        return {
            startAngle: startAngle,
            endAngle: endAngle
        };
    }
    getParsePadAngle(startAngle, endAngle) {
        const arcTheme = (0, theme_1.getTheme)(this).arc, {outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius, padAngle: padAngle = arcTheme.padAngle} = this.attribute, {padRadius: padRadius = (0, 
        vutils_1.sqrt)(outerRadius * outerRadius + innerRadius * innerRadius)} = this.attribute, deltaAngle = (0, 
        vutils_1.abs)(endAngle - startAngle);
        let outerStartAngle = startAngle, outerEndAngle = endAngle, innerStartAngle = startAngle, innerEndAngle = endAngle;
        const halfPadAngle = padAngle / 2;
        let innerDeltaAngle = deltaAngle, outerDeltaAngle = deltaAngle;
        if (halfPadAngle > vutils_1.epsilon && padRadius > vutils_1.epsilon) {
            const sign = endAngle > startAngle ? 1 : -1;
            let p0 = (0, vutils_1.asin)(Number(padRadius) / innerRadius * (0, vutils_1.sin)(halfPadAngle)), p1 = (0, 
            vutils_1.asin)(Number(padRadius) / outerRadius * (0, vutils_1.sin)(halfPadAngle));
            return (innerDeltaAngle -= 2 * p0) > vutils_1.epsilon ? (p0 *= sign, innerStartAngle += p0, 
            innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), 
            (outerDeltaAngle -= 2 * p1) > vutils_1.epsilon ? (p1 *= sign, outerStartAngle += p1, 
            outerEndAngle -= p1) : (outerDeltaAngle = 0, outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), 
            {
                outerStartAngle: outerStartAngle,
                outerEndAngle: outerEndAngle,
                innerStartAngle: innerStartAngle,
                innerEndAngle: innerEndAngle,
                innerDeltaAngle: innerDeltaAngle,
                outerDeltaAngle: outerDeltaAngle
            };
        }
        return {
            outerStartAngle: outerStartAngle,
            outerEndAngle: outerEndAngle,
            innerStartAngle: innerStartAngle,
            innerEndAngle: innerEndAngle,
            innerDeltaAngle: innerDeltaAngle,
            outerDeltaAngle: outerDeltaAngle
        };
    }
    doUpdateAABBBounds(full) {
        const arcTheme = (0, theme_1.getTheme)(this).arc;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateArcAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).arc, this._AABBBounds, full, this), {boundsPadding: boundsPadding = arcTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    needUpdateTags(keys) {
        for (let i = 0; i < ARC_UPDATE_TAG_KEY.length; i++) {
            const attrKey = ARC_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < ARC_UPDATE_TAG_KEY.length; i++) {
            if (key === ARC_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    getDefaultAttribute(name) {
        return (0, theme_1.getTheme)(this).arc[name];
    }
    toCustomPath() {
        const attribute = this.attribute, {startAngle: startAngle, endAngle: endAngle} = this.getParsedAngle();
        let innerRadius = attribute.innerRadius, outerRadius = attribute.outerRadius;
        const deltaAngle = (0, vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;
        if (outerRadius < innerRadius) {
            const temp = outerRadius;
            outerRadius = innerRadius, innerRadius = temp;
        }
        const path = new custom_path2d_1.CustomPath2D;
        if (outerRadius <= vutils_1.epsilon) path.moveTo(0, 0); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) path.moveTo(0 + outerRadius * (0, 
        vutils_1.cos)(startAngle), 0 + outerRadius * (0, vutils_1.sin)(startAngle)), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), 
        innerRadius > vutils_1.epsilon && (path.moveTo(0 + innerRadius * (0, vutils_1.cos)(endAngle), 0 + innerRadius * (0, 
        vutils_1.sin)(endAngle)), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise)); else {
            const xors = outerRadius * (0, vutils_1.cos)(startAngle), yors = outerRadius * (0, 
            vutils_1.sin)(startAngle), xire = innerRadius * (0, vutils_1.cos)(endAngle), yire = innerRadius * (0, 
            vutils_1.sin)(endAngle);
            path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), 
            path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), 
            path.closePath();
        }
        return path;
    }
    clone() {
        return new Arc(Object.assign({}, this.attribute));
    }
}

exports.Arc = Arc;
//# sourceMappingURL=arc.js.map

}, function(modId) { var map = {"./graphic":1689069767709,"../common/custom-path2d":1689069767681,"../common/utils":1689069767736,"./theme":1689069767707,"../application":1689069767703,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767798, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Arc3d = void 0;

const arc_1 = require("./arc"), theme_1 = require("./theme"), application_1 = require("../application"), utils_1 = require("../common/utils"), constants_1 = require("./constants");

class Arc3d extends arc_1.Arc {
    constructor(params) {
        super(params), this.type = "arc3d", this.numberType = constants_1.ARC3D_NUMBER_TYPE;
    }
    doUpdateAABBBounds() {
        const polygonTheme = (0, theme_1.getTheme)(this).arc;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updateArc3dAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).polygon, this._AABBBounds, this), {boundsPadding: boundsPadding = polygonTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        this._AABBBounds;
    }
}

exports.Arc3d = Arc3d;
//# sourceMappingURL=arc3d.js.map

}, function(modId) { var map = {"./arc":1689069767797,"./theme":1689069767707,"../application":1689069767703,"../common/utils":1689069767736,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767799, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Polygon = void 0;

const graphic_1 = require("./graphic"), theme_1 = require("./theme"), utils_1 = require("../common/utils"), custom_path2d_1 = require("../common/custom-path2d"), application_1 = require("../application"), constants_1 = require("./constants"), POLYGON_UPDATE_TAG_KEY = [ "points", "cornerRadius", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Polygon extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "polygon", this.numberType = constants_1.POLYGON_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {points: points} = this.attribute;
        return points && points.length >= 2;
    }
    doUpdateAABBBounds() {
        const polygonTheme = (0, theme_1.getTheme)(this).polygon;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updatePolygonAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).polygon, this._AABBBounds, this), {boundsPadding: boundsPadding = polygonTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        this._AABBBounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = (0, utils_1.pointsInterpolation)(lastStepVal, nextStepVal, ratio));
    }
    getDefaultAttribute(name) {
        return (0, theme_1.getTheme)(this).polygon[name];
    }
    needUpdateTags(keys) {
        for (let i = 0; i < POLYGON_UPDATE_TAG_KEY.length; i++) {
            const attrKey = POLYGON_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
    }
    needUpdateTag(key) {
        for (let i = 0; i < POLYGON_UPDATE_TAG_KEY.length; i++) {
            if (key === POLYGON_UPDATE_TAG_KEY[i]) return !0;
        }
        return !1;
    }
    toCustomPath() {
        const points = this.attribute.points, path = new custom_path2d_1.CustomPath2D;
        return points.forEach(((point, index) => {
            0 === index ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y);
        })), path.closePath(), path;
    }
    clone() {
        return new Polygon(Object.assign({}, this.attribute));
    }
}

exports.Polygon = Polygon;
//# sourceMappingURL=polygon.js.map

}, function(modId) { var map = {"./graphic":1689069767709,"./theme":1689069767707,"../common/utils":1689069767736,"../common/custom-path2d":1689069767681,"../application":1689069767703,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767800, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Pyramid3d = void 0;

const vutils_1 = require("@visactor/vutils"), utils_1 = require("../common/utils"), application_1 = require("../application"), polygon_1 = require("./polygon"), theme_1 = require("./theme"), constants_1 = require("./constants");

class Pyramid3d extends polygon_1.Polygon {
    constructor(params) {
        super(params), this.type = "pyramid3d", this.numberType = constants_1.PYRAMID3D_NUMBER_TYPE;
    }
    doUpdateAABBBounds() {
        const polygonTheme = (0, theme_1.getTheme)(this).polygon;
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const attribute = this.attribute, bounds = application_1.application.graphicService.updatePyramid3dAABBBounds(attribute, (0, 
        theme_1.getTheme)(this).polygon, this._AABBBounds, this), {boundsPadding: boundsPadding = polygonTheme.boundsPadding} = attribute, paddingArray = (0, 
        utils_1.parsePadding)(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), 
        this._AABBBounds;
    }
    findFace() {
        const {points: points} = this.attribute, kList = points.map(((p, i) => {
            const p1 = 3 === i ? points[0] : points[i + 1], dx = p.x - p1.x;
            return 0 === dx ? 0 : (p.y - p1.y) / dx;
        })), pointsMap = points.map((p => ({
            p: p,
            d: 0
        })));
        let find = !1, maxD = 0;
        for (let i = 0; i < kList.length - 1; i++) {
            for (let j = i + 1; j < kList.length; j++) {
                if (kList[i] === kList[j]) {
                    find = !0;
                    const d1 = vutils_1.PointService.distancePP(pointsMap[i].p, pointsMap[i + 1].p);
                    pointsMap[i].d = d1, pointsMap[i + 1].d = d1, maxD = (0, vutils_1.max)(maxD, d1);
                    const d2 = vutils_1.PointService.distancePP(pointsMap[j].p, pointsMap[j + 1].p);
                    pointsMap[j].d = d2, pointsMap[j + 1].d = d2, maxD = (0, vutils_1.max)(maxD, d2);
                }
                if (find) break;
            }
            if (find) break;
        }
        for (let i = points.length - 1; i >= 0; i--) {
            const p = points[i];
            pointsMap.unshift({
                p: p,
                d: 0
            });
        }
        for (let i = 0; i < points.length; i++) {
            const delta = (maxD - pointsMap[i + points.length].d) / 2;
            pointsMap[i].d += delta, pointsMap[i + points.length].d += delta;
        }
        const faces = {
            polygons: [],
            vertices: [],
            edges: []
        };
        return pointsMap.forEach((p => {
            faces.vertices.push([ p.p.x, p.p.y, p.d ]);
        })), faces.polygons.push({
            polygon: [ 0, 4, 5, 1 ],
            normal: [ 0, -1, 0 ]
        }), faces.polygons.push({
            polygon: [ 7, 6, 2, 3 ],
            normal: [ 0, 1, 0 ]
        }), faces.polygons.push({
            polygon: [ 0, 4, 7, 3 ],
            normal: [ -1, 0, 0 ]
        }), faces.polygons.push({
            polygon: [ 1, 5, 6, 2 ],
            normal: [ 1, 0, 0 ]
        }), faces.polygons.push({
            polygon: [ 0, 1, 2, 3 ],
            normal: [ 0, 0, -1 ]
        }), faces.polygons.push({
            polygon: [ 4, 5, 6, 7 ],
            normal: [ 0, 0, 1 ]
        }), faces.edges = [ [ 0, 1 ], [ 1, 2 ], [ 2, 3 ], [ 3, 0 ], [ 4, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 4 ], [ 0, 4 ], [ 3, 7 ], [ 1, 5 ], [ 2, 6 ] ], 
        faces;
    }
    _isValid() {
        return super._isValid() && 4 === this.attribute.points.length;
    }
}

exports.Pyramid3d = Pyramid3d;
//# sourceMappingURL=pyramid3d.js.map

}, function(modId) { var map = {"../common/utils":1689069767736,"../application":1689069767703,"./polygon":1689069767799,"./theme":1689069767707,"./constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767801, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultGraphicService = exports.shouldUseMat4 = exports.getModelMatrix = exports.getExtraModelMatrix = exports.multiplyMat4Mat4 = exports.multiplyMat4Mat3 = exports.mat3Tomat4 = exports.translate = exports.rotateY = exports.rotateX = void 0;

const inversify_1 = require("inversify"), vutils_1 = require("@visactor/vutils"), tapable_1 = require("../../tapable"), rect_contribution_1 = require("./rect-contribution"), text_1 = require("../../common/text"), symbol_contribution_1 = require("./symbol-contribution"), tools_1 = require("../tools"), circle_contribution_1 = require("./circle-contribution"), arc_contribution_1 = require("./arc-contribution"), path_contribution_1 = require("./path-contribution"), matrix_allocate_1 = require("../../allocator/matrix-allocate"), contribution_provider_1 = require("../../common/contribution-provider"), bounds_context_1 = require("../../common/bounds-context"), render_command_list_1 = require("../../common/render-command-list"), utils_1 = require("../../common/utils"), constants_1 = require("../constants");

function identity(out) {
    return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, 
    out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, 
    out[14] = 0, out[15] = 1, out;
}

function rotateX(out, a, rad) {
    const s = Math.sin(rad), c = Math.cos(rad), a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    return a !== out && (out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], 
    out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[4] = a10 * c + a20 * s, 
    out[5] = a11 * c + a21 * s, out[6] = a12 * c + a22 * s, out[7] = a13 * c + a23 * s, 
    out[8] = a20 * c - a10 * s, out[9] = a21 * c - a11 * s, out[10] = a22 * c - a12 * s, 
    out[11] = a23 * c - a13 * s, out;
}

function rotateY(out, a, rad) {
    const s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    return a !== out && (out[4] = a[4], out[5] = a[5], out[6] = a[6], out[7] = a[7], 
    out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c - a20 * s, 
    out[1] = a01 * c - a21 * s, out[2] = a02 * c - a22 * s, out[3] = a03 * c - a23 * s, 
    out[8] = a00 * s + a20 * c, out[9] = a01 * s + a21 * c, out[10] = a02 * s + a22 * c, 
    out[11] = a03 * s + a23 * c, out;
}

function rotateZ(out, a, rad) {
    const s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    return a !== out && (out[8] = a[8], out[9] = a[9], out[10] = a[10], out[11] = a[11], 
    out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c + a10 * s, 
    out[1] = a01 * c + a11 * s, out[2] = a02 * c + a12 * s, out[3] = a03 * c + a13 * s, 
    out[4] = a10 * c - a00 * s, out[5] = a11 * c - a01 * s, out[6] = a12 * c - a02 * s, 
    out[7] = a13 * c - a03 * s, out;
}

function translate(out, a, v) {
    const x = v[0], y = v[1], z = v[2];
    let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
    return a === out ? (out[12] = a[0] * x + a[4] * y + a[8] * z + a[12], out[13] = a[1] * x + a[5] * y + a[9] * z + a[13], 
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14], out[15] = a[3] * x + a[7] * y + a[11] * z + a[15]) : (a00 = a[0], 
    a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], 
    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], out[0] = a00, out[1] = a01, out[2] = a02, 
    out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, 
    out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a[12], 
    out[13] = a01 * x + a11 * y + a21 * z + a[13], out[14] = a02 * x + a12 * y + a22 * z + a[14], 
    out[15] = a03 * x + a13 * y + a23 * z + a[15]), out;
}

function mat3Tomat4(out, b) {
    out[0] = b.a, out[1] = b.b, out[2] = 0, out[3] = 0, out[4] = b.c, out[5] = b.d, 
    out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = b.e, 
    out[13] = b.f, out[14] = 0, out[15] = 1;
}

function multiplyMat4Mat3(out, a, b) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b0 = b.a, b1 = b.b, b2 = 0, b3 = 0;
    return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
    b0 = b.c, b1 = b.d, b2 = 0, b3 = 0, out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = 0, b1 = 0, b2 = 1, b3 = 0, 
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
    b0 = b.e, b1 = b.f, b2 = 0, b3 = 1, out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}

function scale(out, a, v) {
    const x = v[0], y = v[1], z = v[2];
    return out[0] = a[0] * x, out[1] = a[1] * x, out[2] = a[2] * x, out[3] = a[3] * x, 
    out[4] = a[4] * y, out[5] = a[5] * y, out[6] = a[6] * y, out[7] = a[7] * y, out[8] = a[8] * z, 
    out[9] = a[9] * z, out[10] = a[10] * z, out[11] = a[11] * z, out[12] = a[12], out[13] = a[13], 
    out[14] = a[14], out[15] = a[15], out;
}

function multiplyMat4Mat4(out, a, b) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
    b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], 
    b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
    b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}

function getExtraModelMatrix(dx, dy, graphic) {
    const {alpha: alpha, beta: beta} = graphic.attribute;
    if (!alpha && !beta) return null;
    const {anchor3d: anchor3d = graphic.attribute.anchor} = graphic.attribute, _anchor = [ 0, 0 ];
    if (anchor3d) {
        if ("string" == typeof anchor3d[0]) {
            const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
            _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[0] = anchor3d[0];
        if ("string" == typeof anchor3d[1]) {
            const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
            _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[1] = anchor3d[1];
    }
    if ("text" === graphic.type) {
        const {textAlign: textAlign} = graphic.attribute;
        _anchor[0] += (0, text_1.textDrawOffsetX)(textAlign, graphic.clipedWidth);
    }
    _anchor[0] += dx, _anchor[1] += dy;
    const modelMatrix = matrix_allocate_1.mat4Allocate.allocate();
    return translate(modelMatrix, modelMatrix, [ _anchor[0], _anchor[1], 0 ]), beta && rotateX(modelMatrix, modelMatrix, beta), 
    alpha && rotateY(modelMatrix, modelMatrix, alpha), translate(modelMatrix, modelMatrix, [ -_anchor[0], -_anchor[1], 0 ]), 
    modelMatrix;
}

function getModelMatrix(out, graphic, theme) {
    var _a;
    const {x: x = theme.x, y: y = theme.y, z: z = theme.z, dx: dx = theme.dx, dy: dy = theme.dy, dz: dz = theme.dz, scaleX: scaleX = theme.scaleX, scaleY: scaleY = theme.scaleY, scaleZ: scaleZ = theme.scaleZ, alpha: alpha = theme.alpha, beta: beta = theme.beta, angle: angle = theme.angle, anchor3d: anchor3d = graphic.attribute.anchor, anchor: anchor} = graphic.attribute, _anchor = [ 0, 0, 0 ];
    if (anchor3d) {
        if ("string" == typeof anchor3d[0]) {
            const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
            _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[0] = anchor3d[0];
        if ("string" == typeof anchor3d[1]) {
            const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
            _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[1] = anchor3d[1];
        _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;
    }
    if (identity(out), translate(out, out, [ x + dx, y + dy, z + dz ]), translate(out, out, [ _anchor[0], _anchor[1], _anchor[2] ]), 
    rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [ -_anchor[0], -_anchor[1], _anchor[2] ]), 
    scale(out, out, [ scaleX, scaleY, scaleZ ]), angle) {
        const m = matrix_allocate_1.mat4Allocate.allocate(), _anchor = [ 0, 0 ];
        if (anchor) {
            if ("string" == typeof anchor3d[0]) {
                const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
                _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
            } else _anchor[0] = anchor3d[0];
            if ("string" == typeof anchor3d[1]) {
                const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
                _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
            } else _anchor[1] = anchor3d[1];
        }
        translate(m, m, [ _anchor[0], _anchor[1], 0 ]), rotateZ(m, m, angle), translate(m, m, [ -_anchor[0], -_anchor[1], 0 ]), 
        multiplyMat4Mat4(out, out, m);
    }
}

function shouldUseMat4(graphic) {
    const {alpha: alpha, beta: beta} = graphic.attribute;
    return alpha || beta;
}

exports.rotateX = rotateX, exports.rotateY = rotateY, exports.translate = translate, 
exports.mat3Tomat4 = mat3Tomat4, exports.multiplyMat4Mat3 = multiplyMat4Mat3, exports.multiplyMat4Mat4 = multiplyMat4Mat4, 
exports.getExtraModelMatrix = getExtraModelMatrix, exports.getModelMatrix = getModelMatrix, 
exports.shouldUseMat4 = shouldUseMat4;

let DefaultGraphicService = class {
    constructor(creator, rectBoundsContribitions, symbolBoundsContribitions, circleBoundsContribitions, arcBoundsContribitions, pathBoundsContribitions) {
        this.creator = creator, this.rectBoundsContribitions = rectBoundsContribitions, 
        this.symbolBoundsContribitions = symbolBoundsContribitions, this.circleBoundsContribitions = circleBoundsContribitions, 
        this.arcBoundsContribitions = arcBoundsContribitions, this.pathBoundsContribitions = pathBoundsContribitions, 
        this.hooks = {
            onAttributeUpdate: new tapable_1.SyncHook([ "graphic" ]),
            onSetStage: new tapable_1.SyncHook([ "graphic", "stage" ]),
            onRemove: new tapable_1.SyncHook([ "graphic" ]),
            onAddIncremental: new tapable_1.SyncHook([ "graphic", "group", "stage" ]),
            onClearIncremental: new tapable_1.SyncHook([ "graphic", "group", "stage" ]),
            beforeUpdateAABBBounds: new tapable_1.SyncHook([ "graphic", "stage", "willUpdate", "aabbBounds" ]),
            afterUpdateAABBBounds: new tapable_1.SyncHook([ "graphic", "stage", "aabbBounds", "globalAABBBounds", "selfChange" ])
        }, this.tempAABBBounds1 = new vutils_1.AABBBounds, this.tempAABBBounds2 = new vutils_1.AABBBounds;
    }
    onAttributeUpdate(graphic) {
        this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);
    }
    onSetStage(graphic, stage) {
        this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);
    }
    onRemove(graphic) {
        this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);
    }
    onAddIncremental(graphic, group, stage) {
        this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);
    }
    onClearIncremental(group, stage) {
        this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);
    }
    beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
        this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
    }
    afterUpdateAABBBounds(graphic, stage, bounds, params, selfChange) {
        this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params, selfChange);
    }
    updatePathProxyAABBBounds(aabbBounds, graphic) {
        const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
        if (!path) return !1;
        const boundsContext = new bounds_context_1.BoundsContext(aabbBounds);
        return (0, render_command_list_1.renderCommandList)(path.commandList, boundsContext, 0, 0), 
        !0;
    }
    updateRectAABBBounds(attribute, rectTheme, aabbBounds, graphic) {
        if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
            const {width: width = rectTheme.width, height: height = rectTheme.height} = attribute;
            aabbBounds.set(0, 0, width, height);
        }
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._rectBoundsContribitions || (this._rectBoundsContribitions = this.rectBoundsContribitions.getContributions() || []), 
        this._rectBoundsContribitions.length && this._rectBoundsContribitions.forEach((c => {
            c.updateBounds(attribute, rectTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        })), this.transformAABBBounds(attribute, aabbBounds, rectTheme, !1, graphic), aabbBounds;
    }
    updateGroupAABBBounds(attribute, groupTheme, aabbBounds, graphic) {
        const {width: width, height: height, path: path, clip: clip = groupTheme.clip} = attribute;
        path && path.length ? path.forEach((g => {
            aabbBounds.union(g.AABBBounds);
        })) : null != width && null != height && aabbBounds.set(0, 0, width, height), clip || graphic.forEachChildren((node => {
            aabbBounds.union(node.AABBBounds);
        }));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, groupTheme, !1, graphic), 
        aabbBounds;
    }
    updateGlyphAABBBounds(attribute, theme, aabbBounds, graphic) {
        return graphic.getSubGraphic().forEach((node => {
            aabbBounds.union(node.AABBBounds);
        })), aabbBounds;
    }
    updateRichTextAABBBounds(attribute, richtextTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        const {width: width = richtextTheme.width, height: height = richtextTheme.height, maxWidth: maxWidth = richtextTheme.maxWidth, maxHeight: maxHeight = richtextTheme.maxHeight, textAlign: textAlign = richtextTheme.textAlign, textBaseline: textBaseline = richtextTheme.textBaseline} = attribute;
        if (width > 0 && height > 0) aabbBounds.set(0, 0, width, height); else {
            const frameCache = graphic.getFrameCache(), {width: actualWidth, height: actualHeight} = frameCache.getActualSize();
            let contentWidth = width || actualWidth || 0, contentHeight = height || actualHeight || 0;
            contentHeight = "number" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, 
            contentWidth = "number" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, 
            aabbBounds.set(0, 0, contentWidth, contentHeight);
        }
        let deltaY = 0;
        switch (textBaseline) {
          case "top":
            deltaY = 0;
            break;

          case "middle":
            deltaY = -aabbBounds.height() / 2;
            break;

          case "bottom":
            deltaY = -aabbBounds.height();
        }
        let deltaX = 0;
        switch (textAlign) {
          case "left":
            deltaX = 0;
            break;

          case "center":
            deltaX = -aabbBounds.width() / 2;
            break;

          case "right":
            deltaX = -aabbBounds.width();
        }
        aabbBounds.translate(deltaX, deltaY);
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, richtextTheme, !1, graphic), 
        aabbBounds;
    }
    updateTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        const {text: text = textTheme.text} = graphic.attribute;
        Array.isArray(text) ? graphic.updateMultilineAABBBounds(text) : graphic.updateSingallineAABBBounds(text);
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), (0, vutils_1.transformBoundsWithMatrix)(aabbBounds, aabbBounds, graphic.transMatrix), 
        aabbBounds;
    }
    updatePathAABBBounds(attribute, pathTheme, aabbBounds, graphic) {
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic);
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        this._pathBoundsContribitions || (this._pathBoundsContribitions = this.pathBoundsContribitions.getContributions() || []), 
        this._pathBoundsContribitions.length && this._pathBoundsContribitions.forEach((c => {
            c.updateBounds(attribute, pathTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        }));
        const {lineJoin: lineJoin = pathTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, pathTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        const pathShape = graphic.getParsedPathShape();
        return aabbBounds.union(pathShape.getBounds()), aabbBounds;
    }
    updatePyramid3dAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        const stage = graphic.stage;
        if (!stage || !stage.camera) return aabbBounds;
        graphic.findFace().vertices.forEach((v => {
            const x = v[0], y = v[1];
            aabbBounds.add(x, y);
        }));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, polygonTheme, !1, graphic), 
        aabbBounds;
    }
    updateArc3dAABBBounds(attribute, arcTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        const stage = graphic.stage;
        if (!stage || !stage.camera) return aabbBounds;
        const {outerRadius: outerRadius = arcTheme.outerRadius, height: height = 0} = attribute, r = outerRadius + height;
        aabbBounds.setValue(-r, -r, r, r);
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, arcTheme, !1, graphic), 
        aabbBounds;
    }
    updatePolygonAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic);
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        const {lineJoin: lineJoin = polygonTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic) {
        const {points: points = polygonTheme.points} = attribute;
        return points.forEach((p => {
            aabbBounds.add(p.x, p.y);
        })), aabbBounds;
    }
    updateLineAABBBounds(attribute, lineTheme, aabbBounds, graphic) {
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        const {lineJoin: lineJoin = lineTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
        const {points: points = lineTheme.points} = attribute, b = aabbBounds;
        return points.forEach((p => {
            b.add(p.x, p.y);
        })), b;
    }
    updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
        const {segments: segments = lineTheme.segments} = attribute, b = aabbBounds;
        return segments.forEach((s => {
            s.points.forEach((p => {
                b.add(p.x, p.y);
            }));
        })), b;
    }
    updateAreaAABBBounds(attribute, areaTheme, aabbBounds, graphic) {
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        const {lineJoin: lineJoin = areaTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, areaTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
        const {points: points = areaTheme.points} = attribute, b = aabbBounds;
        return points.forEach((p => {
            var _a, _b;
            b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
        })), b;
    }
    updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
        const {segments: segments = areaTheme.segments} = attribute, b = aabbBounds;
        return segments.forEach((s => {
            s.points.forEach((p => {
                var _a, _b;
                b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
            }));
        })), b;
    }
    updateCircleAABBBounds(attribute, circleTheme, aabbBounds, full, graphic) {
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._circleBoundsContribitions || (this._circleBoundsContribitions = this.circleBoundsContribitions.getContributions() || []), 
        this._circleBoundsContribitions.length && this._circleBoundsContribitions.forEach((c => {
            c.updateBounds(attribute, circleTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        })), this.transformAABBBounds(attribute, aabbBounds, circleTheme, !1, graphic), 
        aabbBounds;
    }
    updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) {
        const {radius: radius = circleTheme.radius} = attribute;
        return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;
    }
    updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic) {
        const {startAngle: startAngle = circleTheme.startAngle, endAngle: endAngle = circleTheme.endAngle, radius: radius = circleTheme.radius} = attribute;
        return endAngle - startAngle > vutils_1.pi2 - vutils_1.epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : (0, 
        utils_1.circleBounds)(startAngle, endAngle, radius, aabbBounds), aabbBounds;
    }
    updateArcAABBBounds(attribute, arcTheme, aabbBounds, full, graphic) {
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        this._arcBoundsContribitions || (this._arcBoundsContribitions = this.arcBoundsContribitions.getContributions() || []), 
        this._arcBoundsContribitions.length && this._arcBoundsContribitions.forEach((c => {
            c.updateBounds(attribute, arcTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        }));
        const {lineJoin: lineJoin = arcTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, arcTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) {
        const {outerRadius: outerRadius = arcTheme.outerRadius} = attribute;
        return aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), aabbBounds;
    }
    updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic) {
        const {outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius} = attribute;
        let {endAngle: endAngle = arcTheme.endAngle, startAngle: startAngle = arcTheme.startAngle} = attribute;
        if (startAngle > endAngle) {
            const temp = startAngle;
            startAngle = endAngle, endAngle = temp;
        }
        return outerRadius <= vutils_1.epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > vutils_1.pi2 - vutils_1.epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : ((0, 
        utils_1.circleBounds)(startAngle, endAngle, outerRadius, aabbBounds), (0, utils_1.circleBounds)(startAngle, endAngle, innerRadius, aabbBounds)), 
        aabbBounds;
    }
    updateSymbolAABBBounds(attribute, symbolTheme, aabbBounds, full, graphic) {
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic));
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        this._symbolBoundsContribitions || (this._symbolBoundsContribitions = this.symbolBoundsContribitions.getContributions() || []), 
        this._symbolBoundsContribitions.length && this._symbolBoundsContribitions.forEach((c => {
            c.updateBounds(attribute, symbolTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        }));
        const {lineJoin: lineJoin = symbolTheme.lineJoin} = attribute;
        return this.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, graphic), 
        aabbBounds;
    }
    updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) {
        const {size: size = symbolTheme.size} = attribute;
        if ((0, vutils_1.isArray)(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2); else {
            const halfWH = size / 2;
            aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
        }
        return aabbBounds;
    }
    updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        const {size: size = symbolTheme.size} = attribute;
        return graphic.getParsedPath().bounds(size, aabbBounds), aabbBounds;
    }
    updateImageAABBBounds(attribute, imageTheme, aabbBounds, graphic) {
        if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
            const {width: width = imageTheme.width, height: height = imageTheme.height} = attribute;
            aabbBounds.set(0, 0, width, height);
        }
        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), 
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, imageTheme, !1, graphic), 
        aabbBounds;
    }
    combindShadowAABBBounds(bounds, graphic) {
        if (graphic && graphic.shadowRoot) {
            const b = graphic.shadowRoot.AABBBounds;
            bounds.union(b);
        }
    }
    transformAABBBounds(attribute, aabbBounds, theme, miter, graphic) {
        const {scaleX: scaleX = theme.scaleX, scaleY: scaleY = theme.scaleY, stroke: stroke = theme.stroke, shadowBlur: shadowBlur = theme.shadowBlur, lineWidth: lineWidth = theme.lineWidth, strokeBoundsBuffer: strokeBoundsBuffer = theme.strokeBoundsBuffer} = attribute, tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
        if (stroke) {
            const scaledHalfLineWidth = lineWidth / Math.abs(scaleX + scaleY);
            (0, tools_1.boundStroke)(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), 
            tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        }
        if (shadowBlur) {
            const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
            (0, tools_1.boundStroke)(tb1, shadowBlurHalfWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1);
        }
        this.combindShadowAABBBounds(aabbBounds, graphic), (0, vutils_1.transformBoundsWithMatrix)(aabbBounds, aabbBounds, graphic.transMatrix);
    }
};

DefaultGraphicService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(constants_1.GraphicCreator)), __param(1, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(1, (0, 
inversify_1.named)(rect_contribution_1.RectBoundsContribution)), __param(2, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(2, (0, 
inversify_1.named)(symbol_contribution_1.SymbolBoundsContribution)), __param(3, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(3, (0, 
inversify_1.named)(circle_contribution_1.CircleBoundsContribution)), __param(4, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(4, (0, 
inversify_1.named)(arc_contribution_1.ArcBoundsContribution)), __param(5, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(5, (0, 
inversify_1.named)(path_contribution_1.PathBoundsContribution)), __metadata("design:paramtypes", [ Object, Object, Object, Object, Object, Object ]) ], DefaultGraphicService), 
exports.DefaultGraphicService = DefaultGraphicService;
//# sourceMappingURL=graphic-service.js.map

}, function(modId) { var map = {"../../tapable":1689069767673,"./rect-contribution":1689069767802,"../../common/text":1689069767760,"./symbol-contribution":1689069767804,"../tools":1689069767745,"./circle-contribution":1689069767805,"./arc-contribution":1689069767806,"./path-contribution":1689069767807,"../../allocator/matrix-allocate":1689069767808,"../../common/contribution-provider":1689069767672,"../../common/bounds-context":1689069767682,"../../common/render-command-list":1689069767687,"../../common/utils":1689069767736,"../constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767802, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultRectOuterBorderBoundsContribution = exports.RectBoundsContribution = void 0;

const inversify_1 = require("inversify"), common_contribution_1 = require("./common-contribution");

exports.RectBoundsContribution = Symbol.for("RectBoundsContribution");

let DefaultRectOuterBorderBoundsContribution = class extends common_contribution_1.DefaultOuterBorderBoundsContribution {};

DefaultRectOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultRectOuterBorderBoundsContribution), 
exports.DefaultRectOuterBorderBoundsContribution = DefaultRectOuterBorderBoundsContribution;
//# sourceMappingURL=rect-contribution.js.map

}, function(modId) { var map = {"./common-contribution":1689069767803}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767803, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultOuterBorderBoundsContribution = void 0;

const inversify_1 = require("inversify");

let DefaultOuterBorderBoundsContribution = class {
    updateBounds(attribute, theme, aabbBounds, graphic) {
        const {outerBorder: outerBorder, shadowBlur: shadowBlur = theme.shadowBlur} = attribute;
        if (outerBorder) {
            const defaultOuterBorder = theme.outerBorder, {distance: distance = defaultOuterBorder.distance, lineWidth: lineWidth = defaultOuterBorder.lineWidth} = outerBorder;
            aabbBounds.expand(distance + shadowBlur + lineWidth / 2);
        }
        return aabbBounds;
    }
};

DefaultOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultOuterBorderBoundsContribution), 
exports.DefaultOuterBorderBoundsContribution = DefaultOuterBorderBoundsContribution;
//# sourceMappingURL=common-contribution.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767804, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultSymbolOuterBorderBoundsContribution = exports.SymbolBoundsContribution = void 0;

const inversify_1 = require("inversify"), tools_1 = require("../tools"), common_contribution_1 = require("./common-contribution");

exports.SymbolBoundsContribution = Symbol.for("SymbolBoundsContribution");

let DefaultSymbolOuterBorderBoundsContribution = class extends common_contribution_1.DefaultOuterBorderBoundsContribution {
    updateBounds(attribute, symbolTheme, aabbBounds, graphic) {
        const {outerBorder: outerBorder, shadowBlur: shadowBlur = symbolTheme.shadowBlur, strokeBoundsBuffer: strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer} = attribute;
        if (outerBorder) {
            const defaultOuterBorder = symbolTheme.outerBorder, {distance: distance = defaultOuterBorder.distance, lineWidth: lineWidth = defaultOuterBorder.lineWidth} = outerBorder;
            (0, tools_1.boundStroke)(aabbBounds, distance + shadowBlur + lineWidth / 2, !0, strokeBoundsBuffer);
        }
        return aabbBounds;
    }
};

DefaultSymbolOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultSymbolOuterBorderBoundsContribution), 
exports.DefaultSymbolOuterBorderBoundsContribution = DefaultSymbolOuterBorderBoundsContribution;
//# sourceMappingURL=symbol-contribution.js.map

}, function(modId) { var map = {"../tools":1689069767745,"./common-contribution":1689069767803}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767805, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCircleOuterBorderBoundsContribution = exports.CircleBoundsContribution = void 0;

const inversify_1 = require("inversify"), common_contribution_1 = require("./common-contribution");

exports.CircleBoundsContribution = Symbol.for("CircleBoundsContribution");

let DefaultCircleOuterBorderBoundsContribution = class extends common_contribution_1.DefaultOuterBorderBoundsContribution {};

DefaultCircleOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultCircleOuterBorderBoundsContribution), 
exports.DefaultCircleOuterBorderBoundsContribution = DefaultCircleOuterBorderBoundsContribution;
//# sourceMappingURL=circle-contribution.js.map

}, function(modId) { var map = {"./common-contribution":1689069767803}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767806, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultArcOuterBorderBoundsContribution = exports.ArcBoundsContribution = void 0;

const inversify_1 = require("inversify"), common_contribution_1 = require("./common-contribution");

exports.ArcBoundsContribution = Symbol.for("ArcBoundsContribution");

let DefaultArcOuterBorderBoundsContribution = class extends common_contribution_1.DefaultOuterBorderBoundsContribution {};

DefaultArcOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultArcOuterBorderBoundsContribution), 
exports.DefaultArcOuterBorderBoundsContribution = DefaultArcOuterBorderBoundsContribution;
//# sourceMappingURL=arc-contribution.js.map

}, function(modId) { var map = {"./common-contribution":1689069767803}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767807, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultPathOuterBorderBoundsContribution = exports.PathBoundsContribution = void 0;

const inversify_1 = require("inversify"), common_contribution_1 = require("./common-contribution");

exports.PathBoundsContribution = Symbol.for("PathBoundsContribution");

let DefaultPathOuterBorderBoundsContribution = class extends common_contribution_1.DefaultOuterBorderBoundsContribution {};

DefaultPathOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultPathOuterBorderBoundsContribution), 
exports.DefaultPathOuterBorderBoundsContribution = DefaultPathOuterBorderBoundsContribution;
//# sourceMappingURL=path-contribution.js.map

}, function(modId) { var map = {"./common-contribution":1689069767803}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767808, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.mat4Allocate = exports.matrixAllocate = exports.DefaultMat4Allocate = exports.DefaultMatrixAllocate = exports.createMat4 = exports.Mat4Allocate = exports.MatrixAllocate = void 0;

const vutils_1 = require("@visactor/vutils");

function createMat4() {
    return [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ];
}

exports.MatrixAllocate = Symbol.for("MatrixAllocate"), exports.Mat4Allocate = Symbol.for("Mat4Allocate"), 
exports.createMat4 = createMat4;

class DefaultMatrixAllocate {
    constructor() {
        this.pools = [];
    }
    allocate(a, b, c, d, e, f) {
        if (!this.pools.length) return new vutils_1.Matrix(a, b, c, d, e, f);
        const m = this.pools.pop();
        return m.a = a, m.b = b, m.c = c, m.d = d, m.e = e, m.f = f, m;
    }
    allocateByObj(matrix) {
        if (!this.pools.length) return new vutils_1.Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
        const m = this.pools.pop();
        return m.a = matrix.a, m.b = matrix.b, m.c = matrix.c, m.d = matrix.d, m.e = matrix.e, 
        m.f = matrix.f, m;
    }
    free(d) {
        this.pools.push(d);
    }
    get length() {
        return this.pools.length;
    }
    release(...params) {
        this.pools = [];
    }
}

exports.DefaultMatrixAllocate = DefaultMatrixAllocate;

class DefaultMat4Allocate {
    constructor() {
        this.pools = [];
    }
    static identity(out) {
        return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, 
        out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, 
        out[14] = 0, out[15] = 1, out;
    }
    allocate() {
        if (!this.pools.length) return createMat4();
        const m = this.pools.pop();
        return DefaultMat4Allocate.identity(m), m;
    }
    allocateByObj(d) {
        let m;
        m = this.pools.length ? this.pools.pop() : createMat4();
        for (let i = 0; i < m.length; i++) m[i] = d[i];
        return m;
    }
    free(m) {
        m && this.pools.push(m);
    }
    get length() {
        return this.pools.length;
    }
    release(...params) {
        this.pools = [];
    }
}

exports.DefaultMat4Allocate = DefaultMat4Allocate, exports.matrixAllocate = new DefaultMatrixAllocate, 
exports.mat4Allocate = new DefaultMat4Allocate;
//# sourceMappingURL=matrix-allocate.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767809, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.graphicCreator = exports.createRichText = exports.createShadowRoot = exports.createPolygon = exports.createImage = exports.createSymbol = exports.createWrapText = exports.createText = exports.createGlyph = exports.createRect3d = exports.createRect = exports.createPath = exports.createLine = exports.createGroup = exports.createCircle = exports.createArea = exports.createPyramid3d = exports.createArc3d = exports.createArc = void 0;

const arc_1 = require("./arc"), area_1 = require("./area"), circle_1 = require("./circle"), group_1 = require("./group"), image_1 = require("./image"), line_1 = require("./line"), path_1 = require("./path"), polygon_1 = require("./polygon"), rect_1 = require("./rect"), symbol_1 = require("./symbol"), shadow_root_1 = require("./shadow-root"), text_1 = require("./text"), richtext_1 = require("./richtext"), glyph_1 = require("./glyph"), rect3d_1 = require("./rect3d"), arc3d_1 = require("./arc3d"), pyramid3d_1 = require("./pyramid3d"), wrap_text_1 = require("./wrap-text");

function createArc(attributes) {
    return new arc_1.Arc(attributes);
}

function createArc3d(attributes) {
    return new arc3d_1.Arc3d(attributes);
}

function createPyramid3d(attributes) {
    return new pyramid3d_1.Pyramid3d(attributes);
}

function createArea(attributes) {
    return new area_1.Area(attributes);
}

function createCircle(attributes) {
    return new circle_1.Circle(attributes);
}

function createGroup(attributes) {
    return new group_1.Group(attributes);
}

function createLine(attributes) {
    return new line_1.Line(attributes);
}

function createPath(attributes) {
    return new path_1.Path(attributes);
}

function createRect(attributes) {
    return new rect_1.Rect(attributes);
}

function createRect3d(attributes) {
    return new rect3d_1.Rect3d(attributes);
}

function createGlyph(attributes) {
    return new glyph_1.Glyph(attributes);
}

function createText(attributes) {
    return new text_1.Text(attributes);
}

function createWrapText(attributes) {
    return new wrap_text_1.WrapText(attributes);
}

function createSymbol(attributes) {
    return new symbol_1.Symbol(attributes);
}

function createImage(attributes) {
    return new image_1.Image(attributes);
}

function createPolygon(attributes) {
    return new polygon_1.Polygon(attributes);
}

function createShadowRoot(graphic) {
    return new shadow_root_1.ShadowRoot(graphic);
}

function createRichText(attributes) {
    return new richtext_1.RichText(attributes);
}

exports.createArc = createArc, exports.createArc3d = createArc3d, exports.createPyramid3d = createPyramid3d, 
exports.createArea = createArea, exports.createCircle = createCircle, exports.createGroup = createGroup, 
exports.createLine = createLine, exports.createPath = createPath, exports.createRect = createRect, 
exports.createRect3d = createRect3d, exports.createGlyph = createGlyph, exports.createText = createText, 
exports.createWrapText = createWrapText, exports.createSymbol = createSymbol, exports.createImage = createImage, 
exports.createPolygon = createPolygon, exports.createShadowRoot = createShadowRoot, 
exports.createRichText = createRichText, exports.graphicCreator = {
    arc: createArc,
    area: createArea,
    circle: createCircle,
    group: createGroup,
    image: createImage,
    line: createLine,
    path: createPath,
    rect: createRect,
    rect3d: createRect3d,
    symbol: createSymbol,
    text: createText,
    richtext: createRichText,
    polygon: createPolygon,
    shadowRoot: createShadowRoot,
    wrapText: createWrapText
};
//# sourceMappingURL=graphic-creator.js.map

}, function(modId) { var map = {"./arc":1689069767797,"./area":1689069767796,"./circle":1689069767758,"./group":1689069767708,"./image":1689069767794,"./line":1689069767783,"./path":1689069767795,"./polygon":1689069767799,"./rect":1689069767784,"./symbol":1689069767762,"./shadow-root":1689069767810,"./text":1689069767759,"./richtext":1689069767787,"./glyph":1689069767786,"./rect3d":1689069767785,"./arc3d":1689069767798,"./pyramid3d":1689069767800,"./wrap-text":1689069767811}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767810, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ShadowRoot = void 0;

const group_1 = require("./group");

class ShadowRoot extends group_1.Group {
    constructor(graphic) {
        super({
            x: 0,
            y: 0
        }), this.type = "shadowroot", this.shadowHost = graphic;
    }
    addUpdateBoundTag() {
        super.addUpdateBoundTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
    }
    addUpdateShapeAndBoundsTag() {
        super.addUpdateShapeAndBoundsTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
    }
    tryUpdateGlobalTransMatrix(clearTag = !0) {
        if (this.shouldUpdateGlobalMatrix()) {
            const m = this.transMatrix;
            this._globalTransMatrix ? this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f) : this._globalTransMatrix = m.clone(), 
            this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
        }
        return this._globalTransMatrix;
    }
    doUpdateGlobalMatrix() {
        if (this.shadowHost) {
            const parentMatrix = this.shadowHost.globalTransMatrix;
            this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);
        }
    }
    tryUpdateGlobalAABBBounds() {
        return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this._AABBBounds.clone(), 
        this.shadowHost && this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix), 
        this._globalAABBBounds;
    }
}

exports.ShadowRoot = ShadowRoot;
//# sourceMappingURL=shadow-root.js.map

}, function(modId) { var map = {"./group":1689069767708}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767811, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.WrapText = void 0;

const vutils_1 = require("@visactor/vutils"), layout_1 = require("../core/contributions/textMeasure/layout"), application_1 = require("../application"), text_1 = require("./text"), theme_1 = require("./theme"), WRAP_TEXT_UPDATE_TAG_KEY = [ "heightLimit", "lineClamp" ];

class WrapText extends text_1.Text {
    _isValid() {
        const {text: text} = this.attribute;
        return (0, vutils_1.isArray)(text) ? !text.every((t => null == t || "" === t)) : null != text && "" !== text;
    }
    updateMultilineAABBBounds(text) {
        var _a;
        const textTheme = (0, theme_1.getTheme)(this).text, {fontFamily: fontFamily = textTheme.fontFamily, textAlign: textAlign = textTheme.textAlign, textBaseline: textBaseline = textTheme.textBaseline, fontSize: fontSize = textTheme.fontSize, lineHeight: lineHeight = this.attribute.lineHeight || this.attribute.fontSize || textTheme.fontSize, ellipsis: ellipsis = textTheme.ellipsis, maxLineWidth: maxLineWidth, stroke: stroke = textTheme.stroke, lineWidth: lineWidth = textTheme.lineWidth, heightLimit: heightLimit = 0, lineClamp: lineClamp} = this.attribute;
        if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
            const bbox = this.cache.layoutData.bbox;
            return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), 
            stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        const textMeasure = application_1.application.graphicUtil.textMeasure, layoutObj = new layout_1.CanvasTextLayout(fontFamily, {
            fontSize: fontSize
        }, textMeasure), lines = text.map((l => l.toString())), linesLayout = [], bboxWH = [ 0, 0 ];
        let lineCountLimit = 1 / 0;
        if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), 
        lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
            if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
                const str = lines[i];
                if (i === lineCountLimit - 1) {
                    const clip = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis);
                    linesLayout.push({
                        str: clip.str,
                        width: clip.width
                    });
                    break;
                }
                const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth);
                if (linesLayout.push({
                    str: clip.str,
                    width: clip.width
                }), clip.str.length === str.length) ; else {
                    const newStr = str.substring(clip.str.length);
                    lines.splice(i + 1, 0, newStr);
                }
            }
            let maxWidth = 0;
            linesLayout.forEach((layout => {
                maxWidth = Math.max(maxWidth, layout.width);
            })), bboxWH[0] = maxWidth;
        } else {
            let width, text, lineWidth = 0;
            for (let i = 0, len = lines.length; i < len; i++) {
                if (i === lineCountLimit - 1) {
                    const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i], layoutObj.textOptions, maxLineWidth, ellipsis);
                    linesLayout.push({
                        str: clip.str,
                        width: clip.width
                    }), lineWidth = Math.max(lineWidth, clip.width);
                    break;
                }
                text = lines[i], width = layoutObj.textMeasure.measureTextWidth(text, layoutObj.textOptions), 
                lineWidth = Math.max(lineWidth, width), linesLayout.push({
                    str: text,
                    width: width
                });
            }
            bboxWH[0] = lineWidth;
        }
        bboxWH[1] = linesLayout.length * (lineHeight + 2);
        const bbox = {
            xOffset: 0,
            yOffset: 0,
            width: bboxWH[0],
            height: bboxWH[1]
        };
        layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
        const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), 
        stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    needUpdateTags(keys) {
        for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
            const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];
            if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return super.needUpdateTags(keys);
    }
    needUpdateTag(key) {
        for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
            if (key === WRAP_TEXT_UPDATE_TAG_KEY[i]) return !0;
        }
        return super.needUpdateTag(key);
    }
}

exports.WrapText = WrapText;
//# sourceMappingURL=wrap-text.js.map

}, function(modId) { var map = {"../core/contributions/textMeasure/layout":1689069767761,"../application":1689069767703,"./text":1689069767759,"./theme":1689069767707}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767812, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getTextBounds = void 0;

const graphic_creator_1 = require("./graphic-creator"), text = (0, graphic_creator_1.createText)({
    text: ""
});

function getTextBounds(params) {
    return text.setAttributes(params), text.AABBBounds;
}

exports.getTextBounds = getTextBounds;
//# sourceMappingURL=bounds.js.map

}, function(modId) { var map = {"./graphic-creator":1689069767809}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767813, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.canvasAllocate = exports.DefaultCanvasAllocate = void 0;

const application_1 = require("../application"), util_1 = require("../canvas/util");

class DefaultCanvasAllocate {
    constructor() {
        this.pools = [];
    }
    allocate(data) {
        if (!this.pools.length) return (0, util_1.wrapCanvas)(Object.assign({
            nativeCanvas: application_1.application.global.createCanvas(data)
        }, data));
        const m = this.pools.pop();
        return m.resize(data.width, data.height), m.dpr = data.dpr, m;
    }
    allocateByObj(canvas) {
        if (!this.pools.length) {
            const data = {
                width: canvas.width / canvas.dpr,
                height: canvas.height / canvas.dpr,
                dpr: canvas.dpr
            };
            return (0, util_1.wrapCanvas)(Object.assign({
                nativeCanvas: application_1.application.global.createCanvas(data)
            }, data));
        }
        const m = this.pools.pop();
        return m.width = canvas.width, m.height = canvas.height, m;
    }
    free(d) {
        this.pools.push(d);
    }
    get length() {
        return this.pools.length;
    }
    release(...params) {
        this.pools = [];
    }
}

exports.DefaultCanvasAllocate = DefaultCanvasAllocate, exports.canvasAllocate = new DefaultCanvasAllocate;
//# sourceMappingURL=canvas-allocate.js.map
}, function(modId) { var map = {"../application":1689069767703,"../canvas/util":1689069767701}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767814, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasCircleRender = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants"), circle_contribution_render_1 = require("./contributions/circle-contribution-render"), contribution_provider_1 = require("../../../common/contribution-provider"), utils_1 = require("./utils"), enums_1 = require("../../../common/enums");

let DefaultCanvasCircleRender = class {
    constructor(circleRenderContribitions) {
        this.circleRenderContribitions = circleRenderContribitions, this.numberType = constants_1.CIRCLE_NUMBER_TYPE;
    }
    drawShape(circle, context, x, y, drawContext, params, fillCb, strokeCb) {
        const circleAttribute = (0, theme_1.getTheme)(circle, null == params ? void 0 : params.theme).circle, {fill: fill = circleAttribute.fill, background: background, stroke: stroke = circleAttribute.stroke, radius: radius = circleAttribute.radius, startAngle: startAngle = circleAttribute.startAngle, endAngle: endAngle = circleAttribute.endAngle, fillOpacity: fillOpacity = circleAttribute.fillOpacity, strokeOpacity: strokeOpacity = circleAttribute.strokeOpacity, opacity: opacity = circleAttribute.opacity, lineWidth: lineWidth = circleAttribute.lineWidth, visible: visible = circleAttribute.visible, x: originX = circleAttribute.x, y: originY = circleAttribute.y} = circle.attribute, fVisible = (0, 
        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, 
        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);
        circle.valid && visible && (doFill || doStroke || background) && (fVisible || sVisible || fillCb || strokeCb || background) && (context.beginPath(), 
        context.arc(x, y, radius, startAngle, endAngle), context.closePath(), this._circleRenderContribitions || (this._circleRenderContribitions = this.circleRenderContribitions.getContributions() || [], 
        this._circleRenderContribitions.sort(((a, b) => b.order - a.order))), this._circleRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, fillCb, strokeCb);
        })), context.setShadowStyle && context.setShadowStyle(circle, circle.attribute, circleAttribute), 
        doFill && (fillCb ? fillCb(context, circle.attribute, circleAttribute) : fVisible && (context.setCommonStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), 
        context.fill())), doStroke && (strokeCb ? strokeCb(context, circle.attribute, circleAttribute) : sVisible && (context.setStrokeStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), 
        context.stroke())), this._circleRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, fillCb, strokeCb);
        })));
    }
    draw(circle, renderService, drawContext, params) {
        const {context: context} = drawContext;
        if (!context) return;
        context.highPerformanceSave();
        const circleAttribute = (0, theme_1.getTheme)(circle, null == params ? void 0 : params.theme).circle;
        let {x: x = circleAttribute.x, y: y = circleAttribute.y} = circle.attribute;
        if (circle.transMatrix.onlyTranslate()) {
            const point = circle.getOffsetXY(circleAttribute);
            x += point.x, y += point.y, context.setTransformForCurrent();
        } else x = 0, y = 0, context.transformFromMatrix(circle.transMatrix, !0);
        (0, utils_1.drawPathProxy)(circle, context, x, y, drawContext, params) || this.drawShape(circle, context, x, y, drawContext, params), 
        context.highPerformanceRestore();
    }
};

DefaultCanvasCircleRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(circle_contribution_render_1.CircleRenderContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasCircleRender), 
exports.DefaultCanvasCircleRender = DefaultCanvasCircleRender;
//# sourceMappingURL=circle-render.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744,"./contributions/circle-contribution-render":1689069767815,"../../../common/contribution-provider":1689069767672,"./utils":1689069767752,"../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767815, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCircleTextureRenderContribution = exports.DefaultCircleBackgroundRenderContribution = exports.DefaultCircleRenderContribution = exports.CircleRenderContribution = void 0;

const inversify_1 = require("inversify"), canvas_utils_1 = require("../../../../common/canvas-utils"), base_contribution_render_1 = require("./base-contribution-render"), enums_1 = require("../../../../common/enums");

exports.CircleRenderContribution = Symbol.for("CircleRenderContribution");

let DefaultCircleRenderContribution = class {
    constructor() {
        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, fillCb, strokeCb) {
        const {radius: radius = circleAttribute.radius, startAngle: startAngle = circleAttribute.startAngle, endAngle: endAngle = circleAttribute.endAngle, opacity: opacity = circleAttribute.opacity, outerBorder: outerBorder, innerBorder: innerBorder} = circle.attribute;
        if (outerBorder) {
            const {distance: distance = circleAttribute.outerBorder.distance} = outerBorder, dw = (0, 
            canvas_utils_1.getScaledStroke)(context, distance, context.dpr);
            if (context.beginPath(), context.arc(x, y, radius + dw, startAngle, endAngle), context.closePath(), 
            context.setShadowStyle && context.setShadowStyle(circle, circle.attribute, circleAttribute), 
            strokeCb) strokeCb(context, outerBorder, circleAttribute.outerBorder); else if (sVisible) {
                const lastOpacity = circleAttribute.outerBorder.opacity;
                circleAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(circle, outerBorder, x, y, circleAttribute.outerBorder), 
                circleAttribute.outerBorder.opacity = lastOpacity, context.stroke();
            }
        }
        if (innerBorder) {
            const {distance: distance = circleAttribute.innerBorder.distance} = innerBorder, dw = (0, 
            canvas_utils_1.getScaledStroke)(context, distance, context.dpr);
            if (context.beginPath(), context.arc(x, y, radius - dw, startAngle, endAngle), context.closePath(), 
            context.setShadowStyle && context.setShadowStyle(circle, circle.attribute, circleAttribute), 
            strokeCb) strokeCb(context, innerBorder, circleAttribute.innerBorder); else if (sVisible) {
                const lastOpacity = circleAttribute.innerBorder.opacity;
                circleAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(circle, innerBorder, x, y, circleAttribute.innerBorder), 
                circleAttribute.innerBorder.opacity = lastOpacity, context.stroke();
            }
        }
    }
};

DefaultCircleRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultCircleRenderContribution), 
exports.DefaultCircleRenderContribution = DefaultCircleRenderContribution;

let DefaultCircleBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;
    }
};

DefaultCircleBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultCircleBackgroundRenderContribution), 
exports.DefaultCircleBackgroundRenderContribution = DefaultCircleBackgroundRenderContribution;

let DefaultCircleTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;
    }
};

DefaultCircleTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultCircleTextureRenderContribution), 
exports.DefaultCircleTextureRenderContribution = DefaultCircleTextureRenderContribution;
//# sourceMappingURL=circle-contribution-render.js.map

}, function(modId) { var map = {"../../../../common/canvas-utils":1689069767755,"./base-contribution-render":1689069767756,"../../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767816, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasLineRender = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants"), utils_1 = require("./utils"), base_render_1 = require("./base-render"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), render_curve_1 = require("../../../common/render-curve"), segment_1 = require("../../../common/segment");

let DefaultCanvasLineRender = class extends base_render_1.BaseRender {
    constructor() {
        super(...arguments), this.numberType = constants_1.LINE_NUMBER_TYPE;
    }
    draw(line, renderService, drawContext, params) {
        const {context: context} = drawContext;
        context.highPerformanceSave();
        const lineAttribute = (0, theme_1.getTheme)(line, null == params ? void 0 : params.theme).line, data = this.transform(line, lineAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        this.z = z, (0, utils_1.drawPathProxy)(line, context, x, y, drawContext) || (this.drawShape(line, context, x, y, drawContext, params), 
        this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), 
        context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
    }
    drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
        var _a;
        context.beginPath();
        const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
        (0, render_curve_1.drawSegments)(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
            offsetX: offsetX,
            offsetY: offsetY,
            offsetZ: z
        }), line.cache && !(0, vutils_1.isArray)(line.cache) && line.attribute.curveType && line.attribute.curveType.includes("Closed") && context.closePath(), 
        context.setShadowStyle && context.setShadowStyle(line, attribute, defaultAttribute);
        const {x: originX = 0, x: originY = 0} = attribute;
        return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), 
        context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), 
        context.stroke())), !1;
    }
    drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
        const lineAttribute = (0, theme_1.getTheme)(line, null == params ? void 0 : params.theme).line, {fill: fill = lineAttribute.fill, stroke: stroke = lineAttribute.stroke, opacity: opacity = lineAttribute.opacity, fillOpacity: fillOpacity = lineAttribute.fillOpacity, strokeOpacity: strokeOpacity = lineAttribute.strokeOpacity, lineWidth: lineWidth = lineAttribute.lineWidth, visible: visible = lineAttribute.visible} = line.attribute, fVisible = (0, 
        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, 
        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);
        if (!line.valid || !visible) return;
        if (!doFill && !doStroke) return;
        if (!(fVisible || sVisible || fillCb || strokeCb)) return;
        if (line.shouldUpdateShape()) {
            const {points: points, segments: segments, curveType: curveType = lineAttribute.curveType} = line.attribute, _points = points;
            if (segments && segments.length) {
                let startPoint, lastSeg;
                line.cache = segments.map(((seg, index) => (1 === index ? startPoint = {
                    x: lastSeg.endX,
                    y: lastSeg.endY,
                    defined: lastSeg.curves[lastSeg.curves.length - 1].defined
                } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined), 
                lastSeg = (0, segment_1.calcLineCache)(seg.points, curveType, {
                    startPoint: startPoint
                }), lastSeg)));
            } else {
                if (!points || !points.length) return line.cache = null, void line.clearUpdateShapeTag();
                line.cache = (0, segment_1.calcLineCache)(_points, curveType);
            }
            line.clearUpdateShapeTag();
        }
        const {clipRange: clipRange = lineAttribute.clipRange, clipRangeByDimension: clipRangeByDimension = lineAttribute.clipRangeByDimension} = line.attribute;
        if (Array.isArray(line.cache)) if (1 === clipRange) {
            let skip = !1;
            line.cache.forEach(((cache, index) => {
                skip || (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute.segments[index], [ lineAttribute, line.attribute ], clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb));
            }));
        } else {
            const totalLength = line.cache.reduce(((l, c) => l + c.getLength()), 0), totalDrawLength = clipRange * totalLength;
            let drawedLengthUntilLast = 0, skip = !1;
            line.cache.forEach(((cache, index) => {
                if (skip) return;
                const curSegLength = cache.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
                drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute.segments[index], [ lineAttribute, line.attribute ], (0, 
                vutils_1.min)(_cr, 1), clipRangeByDimension, x, y, line, fillCb, strokeCb));
            }));
        } else this.drawSegmentItem(context, line.cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
    }
};

DefaultCanvasLineRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasLineRender), 
exports.DefaultCanvasLineRender = DefaultCanvasLineRender;
//# sourceMappingURL=line-render.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744,"./utils":1689069767752,"./base-render":1689069767817,"../../../allocator/matrix-allocate":1689069767808,"../../../common/render-curve":1689069767818,"../../../common/segment":1689069767688}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767817, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseRender = void 0;

const inversify_1 = require("inversify"), graphic_1 = require("../../../graphic"), matrix_allocate_1 = require("../../../allocator/matrix-allocate");

let BaseRender = class {
    transform(graphic, graphicAttribute, context, use3dMatrixIn3dMode = !1) {
        const transMatrix = graphic.transMatrix, {x: x = graphicAttribute.x, y: y = graphicAttribute.y, z: z = graphicAttribute.z, scaleX: scaleX = graphicAttribute.scaleX, scaleY: scaleY = graphicAttribute.scaleY, angle: angle = graphicAttribute.angle, postMatrix: postMatrix} = graphic.attribute, onlyTranslate = transMatrix.onlyTranslate() && !postMatrix, lastModelMatrix = context.modelMatrix, camera = context.camera, result = {
            x: x,
            y: y,
            z: z,
            lastModelMatrix: lastModelMatrix
        }, shouldTransform3d = camera && (use3dMatrixIn3dMode || (0, graphic_1.shouldUseMat4)(graphic));
        if (shouldTransform3d) {
            const nextModelMatrix = matrix_allocate_1.mat4Allocate.allocate(), modelMatrix = matrix_allocate_1.mat4Allocate.allocate();
            (0, graphic_1.getModelMatrix)(modelMatrix, graphic, graphicAttribute), lastModelMatrix ? (0, 
            graphic_1.multiplyMat4Mat4)(nextModelMatrix, lastModelMatrix, modelMatrix) : (0, 
            graphic_1.multiplyMat4Mat4)(nextModelMatrix, nextModelMatrix, modelMatrix), result.x = 0, 
            result.y = 0, result.z = 0, context.modelMatrix = nextModelMatrix, context.setTransform(1, 0, 0, 1, 0, 0, !0), 
            matrix_allocate_1.mat4Allocate.free(modelMatrix);
        }
        if (onlyTranslate && !lastModelMatrix) {
            const point = graphic.getOffsetXY(graphicAttribute);
            result.x += point.x, result.y += point.y, result.z = z, context.setTransformForCurrent();
        } else if (shouldTransform3d) result.x = 0, result.y = 0, result.z = 0, context.setTransform(1, 0, 0, 1, 0, 0, !0); else if (camera && context.project) {
            const point = graphic.getOffsetXY(graphicAttribute);
            result.x += point.x, result.y += point.y, this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle);
        } else context.transformFromMatrix(graphic.transMatrix, !0), result.x = 0, result.y = 0, 
        result.z = 0;
        return result;
    }
    transformUseContext2d(graphic, graphicAttribute, z, context) {
        const camera = context.camera;
        if (this.camera = camera, camera) {
            const bounds = graphic.AABBBounds, width = bounds.x2 - bounds.x1, height = bounds.y2 - bounds.y1, p1 = context.project(0, 0, z), p2 = context.project(width, 0, z), p3 = context.project(width, height, z), _p1 = {
                x: 0,
                y: 0
            }, _p2 = {
                x: width,
                y: 0
            }, _p3 = {
                x: width,
                y: height
            };
            context.camera = null;
            const denom = 1 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y), m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom, m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom, m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom, m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom, dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) + _p1.y * (_p2.x * p3.x - _p3.x * p2.x) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) * denom, dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) + _p1.y * (_p2.x * p3.y - _p3.x * p2.y) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) * denom;
            context.setTransform(m11, m12, m21, m22, dx, dy, !0);
        }
    }
    restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {
        this.camera && (context.camera = this.camera);
    }
    transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle) {
        const p = context.project(x, y, z);
        context.translate(p.x, p.y, !1), context.scale(scaleX, scaleY, !1), context.rotate(angle, !1), 
        context.translate(-p.x, -p.y, !1), context.setTransformForCurrent();
    }
};

BaseRender = __decorate([ (0, inversify_1.injectable)() ], BaseRender), exports.BaseRender = BaseRender;
//# sourceMappingURL=base-render.js.map

}, function(modId) { var map = {"../../../graphic":1689069767757,"../../../allocator/matrix-allocate":1689069767808}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767818, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.drawIncrementalAreaSegments = exports.drawIncrementalSegments = exports.drawSegments = void 0;

const vutils_1 = require("@visactor/vutils"), enums_1 = require("./enums"), cubic_bezier_1 = require("./segment/curve/cubic-bezier");

function drawSegments(path, segPath, percent, clipRangeByDimension, params) {
    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0} = params || {};
    let needMoveTo = !0;
    const {curves: curves} = segPath;
    if (percent >= 1) return void curves.forEach((curve => {
        curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), 
        drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
    }));
    if (percent <= 0) return;
    let direction;
    "x" === clipRangeByDimension ? direction = enums_1.Direction.ROW : "y" === clipRangeByDimension ? direction = enums_1.Direction.COLUMN : "auto" === clipRangeByDimension && (direction = segPath.direction);
    const totalDrawLength = percent * segPath.tryUpdateLength(direction);
    let drawedLengthUntilLast = 0;
    for (let i = 0, n = curves.length; i < n; i++) {
        const curve = curves[i], curCurveLength = curve.getLength(direction), _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
        if (drawedLengthUntilLast += curCurveLength, _p < 0) break;
        curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), 
        drawSegItem(path, curve, (0, vutils_1.min)(_p, 1), params), needMoveTo = !1) : needMoveTo = !0;
    }
}

function drawIncrementalSegments(path, lastSeg, segments, params) {
    const {offsetX: offsetX = 0, offsetY: offsetY = 0} = params || {}, startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];
    path.moveTo(startP.x + offsetX, startP.y + offsetY), segments.points.forEach((p => {
        !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
    }));
}

function drawIncrementalAreaSegments(path, lastSeg, segments, params) {
    const {offsetX: offsetX = 0, offsetY: offsetY = 0} = params || {}, {points: points} = segments, definedPointsList = [];
    let lastIdx = 0;
    for (let i = 0; i < points.length; i++) !1 === points[i].defined && (lastIdx + 1 !== i && definedPointsList.slice(lastIdx, i), 
    lastIdx = i);
    definedPointsList.length, definedPointsList.push(points), definedPointsList.forEach(((points, i) => {
        var _a, _b, _c, _d;
        const startP = lastSeg && 0 === i ? lastSeg.points[lastSeg.points.length - 1] : points[0];
        path.moveTo(startP.x + offsetX, startP.y + offsetY), points.forEach((p => {
            !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
        }));
        for (let i = points.length - 1; i >= 0; i--) {
            const p = points[i];
            path.lineTo(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
        }
        path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), 
        path.closePath();
    }));
}

function drawSegItem(ctx, curve, endPercent, params) {
    if (!curve.p1) return;
    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0} = params || {};
    if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ); else if (curve.p2 && curve.p3) {
        const [curve1] = (0, cubic_bezier_1.divideCubic)(curve, endPercent);
        ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
    } else {
        const p = curve.getPointAt(endPercent);
        ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
    }
}

//# sourceMappingURL=render-curve.js.map
exports.drawSegments = drawSegments, exports.drawIncrementalSegments = drawIncrementalSegments, 
exports.drawIncrementalAreaSegments = drawIncrementalAreaSegments;
}, function(modId) { var map = {"./enums":1689069767685,"./segment/curve/cubic-bezier":1689069767691}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767819, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasAreaRender = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), contribution_provider_1 = require("../../../common/contribution-provider"), segment_1 = require("../../../common/segment"), theme_1 = require("../../../graphic/theme"), utils_1 = require("./utils"), area_contribution_render_1 = require("./contributions/area-contribution-render"), enums_1 = require("../../../common/enums"), render_area_1 = require("../../../common/render-area"), constants_1 = require("../../../graphic/constants");

function calcLineCache(points, curveType, params) {
    switch (curveType) {
      case "linear":
      default:
        return (0, segment_1.genLinearSegments)(points, params);

      case "basis":
        return (0, segment_1.genBasisSegments)(points, params);

      case "monotoneX":
        return (0, segment_1.genMonotoneXSegments)(points, params);

      case "monotoneY":
        return (0, segment_1.genMonotoneYSegments)(points, params);

      case "step":
        return (0, segment_1.genStepSegments)(points, .5, params);

      case "stepBefore":
        return (0, segment_1.genStepSegments)(points, 0, params);

      case "stepAfter":
        return (0, segment_1.genStepSegments)(points, 1, params);

      case "linearClosed":
        return (0, segment_1.genLinearClosedSegments)(points, params);
    }
}

let DefaultCanvasAreaRender = class {
    constructor(areaRenderContribitions) {
        this.areaRenderContribitions = areaRenderContribitions, this.numberType = constants_1.AREA_NUMBER_TYPE;
    }
    drawShape(area, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c, _d, _e, _f;
        const areaAttribute = (0, theme_1.getTheme)(area, null == params ? void 0 : params.theme).area, {fill: fill = areaAttribute.fill, fillOpacity: fillOpacity = areaAttribute.fillOpacity, opacity: opacity = areaAttribute.opacity, visible: visible = areaAttribute.visible, z: z = areaAttribute.z, stroke: stroke = area.attribute.stroke, lineWidth: lineWidth = areaAttribute.lineWidth, strokeOpacity: strokeOpacity = areaAttribute.strokeOpacity} = area.attribute, fVisible = (0, 
        utils_1.fillVisible)(opacity, fillOpacity), doFill = (0, utils_1.runFill)(fill), doStroke = (0, 
        utils_1.runStroke)(stroke, lineWidth), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity);
        if (!area.valid || !visible) return;
        if (!doFill && !doStroke) return;
        if (!(fVisible || fillCb || sVisible || strokeCb)) return;
        const {clipRange: clipRange = areaAttribute.clipRange} = area.attribute;
        if (area.shouldUpdateShape()) {
            const {points: points, segments: segments, curveType: curveType = areaAttribute.curveType} = area.attribute;
            if (segments && segments.length) {
                let startPoint, lastTopSeg;
                const topCaches = segments.map(((seg, index) => (1 === index ? startPoint = {
                    x: lastTopSeg.endX,
                    y: lastTopSeg.endY
                } : index > 1 && (startPoint.x = lastTopSeg.endX, startPoint.y = lastTopSeg.endY), 
                lastTopSeg = calcLineCache(seg.points, curveType, {
                    startPoint: startPoint
                }), lastTopSeg)));
                let lastBottomSeg;
                const bottomCaches = [];
                for (let i = segments.length - 1; i >= 0; i--) {
                    const points = segments[i].points, bottomPoints = [];
                    for (let i = points.length - 1; i >= 0; i--) bottomPoints.push({
                        x: null !== (_a = points[i].x1) && void 0 !== _a ? _a : points[i].x,
                        y: null !== (_b = points[i].y1) && void 0 !== _b ? _b : points[i].y
                    });
                    if (0 !== i) {
                        const lastSegmentPoints = segments[i - 1].points, endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];
                        endPoint && bottomPoints.push({
                            x: null !== (_c = endPoint.x1) && void 0 !== _c ? _c : endPoint.x,
                            y: null !== (_d = endPoint.y1) && void 0 !== _d ? _d : endPoint.y
                        });
                    }
                    lastBottomSeg = calcLineCache(bottomPoints, curveType), bottomCaches.unshift(lastBottomSeg);
                }
                area.cacheArea = bottomCaches.map(((item, index) => ({
                    top: topCaches[index],
                    bottom: item
                })));
            } else {
                if (!points || !points.length) return area.cache = null, void area.clearUpdateShapeTag();
                {
                    const topPoints = points, bottomPoints = [];
                    for (let i = points.length - 1; i >= 0; i--) bottomPoints.push({
                        x: null !== (_e = points[i].x1) && void 0 !== _e ? _e : points[i].x,
                        y: null !== (_f = points[i].y1) && void 0 !== _f ? _f : points[i].y
                    });
                    const topCache = calcLineCache(topPoints, curveType), bottomCache = calcLineCache(bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType);
                    area.cacheArea = {
                        top: topCache,
                        bottom: bottomCache
                    };
                }
            }
            area.clearUpdateShapeTag();
        }
        if (Array.isArray(area.cacheArea)) if (1 === clipRange) {
            let skip = !1;
            area.cacheArea.forEach(((cache, index) => {
                skip || (skip = this.drawSegmentItem(context, cache, !!fill, fillOpacity, area.attribute.segments[index], [ areaAttribute, area.attribute ], clipRange, x, y, z, area, fillCb));
            }));
        } else {
            const totalLength = area.cacheArea.reduce(((l, c) => l + c.top.getLength()), 0), totalDrawLength = clipRange * totalLength;
            let drawedLengthUntilLast = 0, skip = !1;
            area.cacheArea.forEach(((cache, index) => {
                if (skip) return;
                const curSegLength = cache.top.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
                drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, fillOpacity, area.attribute.segments[index], [ areaAttribute, area.attribute ], (0, 
                vutils_1.min)(_cr, 1), x, y, z, area, fillCb));
            }));
        } else this.drawSegmentItem(context, area.cacheArea, !!fill, fillOpacity, area.attribute, areaAttribute, clipRange, x, y, z, area, fillCb);
    }
    draw(area, renderService, drawContext, params) {
        const {context: context} = drawContext, areaAttribute = (0, theme_1.getTheme)(area, null == params ? void 0 : params.theme).area;
        let {x: x = areaAttribute.x, y: y = areaAttribute.y} = area.attribute;
        if (context.highPerformanceSave(), area.transMatrix.onlyTranslate()) {
            const point = area.getOffsetXY(areaAttribute);
            x += point.x, y += point.y, context.setTransformForCurrent();
        } else x = 0, y = 0, context.transformFromMatrix(area.transMatrix, !0);
        (0, utils_1.drawPathProxy)(area, context, x, y, drawContext, params) || this.drawShape(area, context, x, y, drawContext, params), 
        context.highPerformanceRestore();
    }
    drawSegmentItem(context, cache, fill, fillOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, fillCb) {
        context.beginPath();
        (0, render_area_1.drawAreaSegments)(context.camera ? context : context.nativeContext, cache, clipRange, {
            offsetX: offsetX,
            offsetY: offsetY,
            offsetZ: offsetZ
        }), this._areaRenderContribitions || (this._areaRenderContribitions = this.areaRenderContribitions.getContributions() || [], 
        this._areaRenderContribitions.sort(((a, b) => b.order - a.order))), this._areaRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, fillCb, null, {
                attribute: attribute
            });
        })), context.setShadowStyle && context.setShadowStyle(area, attribute, defaultAttribute);
        const {x: originX = 0, x: originY = 0} = attribute;
        return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute), 
        context.fill())), this._areaRenderContribitions || (this._areaRenderContribitions = this.areaRenderContribitions.getContributions() || []), 
        this._areaRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, fillCb, null, {
                attribute: attribute
            });
        })), !1;
    }
};

DefaultCanvasAreaRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(area_contribution_render_1.AreaRenderContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasAreaRender), 
exports.DefaultCanvasAreaRender = DefaultCanvasAreaRender;
//# sourceMappingURL=area-render.js.map

}, function(modId) { var map = {"../../../common/contribution-provider":1689069767672,"../../../common/segment":1689069767688,"../../../graphic/theme":1689069767707,"./utils":1689069767752,"./contributions/area-contribution-render":1689069767820,"../../../common/enums":1689069767685,"../../../common/render-area":1689069767821,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767820, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultAreaTextureRenderContribution = exports.DefaultAreaBackgroundRenderContribution = exports.AreaRenderContribution = void 0;

const inversify_1 = require("inversify"), base_contribution_render_1 = require("./base-contribution-render"), utils_1 = require("../../../../common/utils"), enums_1 = require("../../../../common/enums");

exports.AreaRenderContribution = Symbol.for("AreaRenderContribution");

let DefaultAreaBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;
    }
};

DefaultAreaBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultAreaBackgroundRenderContribution), 
exports.DefaultAreaBackgroundRenderContribution = DefaultAreaBackgroundRenderContribution;

let DefaultAreaTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb, options) {
        var _a, _b, _c, _d;
        this.textureMap || this.initTextureMap(context, graphic.stage);
        const {attribute: attribute = graphic.attribute} = options || {}, {texture: texture = (null !== (_a = graphic.attribute.texture) && void 0 !== _a ? _a : (0, 
        utils_1.getAttributeFromDefaultAttrList)(graphicAttribute, "texture")), textureColor: textureColor = (null !== (_b = graphic.attribute.textureColor) && void 0 !== _b ? _b : (0, 
        utils_1.getAttributeFromDefaultAttrList)(graphicAttribute, "textureColor")), textureSize: textureSize = (null !== (_c = graphic.attribute.textureSize) && void 0 !== _c ? _c : (0, 
        utils_1.getAttributeFromDefaultAttrList)(graphicAttribute, "textureSize")), texturePadding: texturePadding = (null !== (_d = graphic.attribute.texturePadding) && void 0 !== _d ? _d : (0, 
        utils_1.getAttributeFromDefaultAttrList)(graphicAttribute, "texturePadding"))} = attribute;
        if (!texture) return;
        let pattern = this.textureMap.get(texture);
        if (!pattern) switch (texture) {
          case "circle":
            pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "diamond":
            pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
            break;

          case "rect":
            pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
            break;

          case "vertical-line":
            pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "horizontal-line":
            pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "bias-lr":
            pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "bias-rl":
            pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
            break;

          case "grid":
            pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
        }
        pattern && (context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), 
        context.fillStyle = pattern, context.fill(), context.highPerformanceRestore());
    }
};

DefaultAreaTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultAreaTextureRenderContribution), 
exports.DefaultAreaTextureRenderContribution = DefaultAreaTextureRenderContribution;
//# sourceMappingURL=area-contribution-render.js.map

}, function(modId) { var map = {"./base-contribution-render":1689069767756,"../../../../common/utils":1689069767736,"../../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767821, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.drawAreaSegments = void 0;

const vutils_1 = require("@visactor/vutils"), enums_1 = require("./enums"), cubic_bezier_1 = require("./segment/curve/cubic-bezier"), line_1 = require("./segment/curve/line");

function drawAreaSegments(path, segPath, percent, params) {
    var _a;
    const {top: top, bottom: bottom} = segPath;
    if (percent >= 1) {
        const topList = [], bottomList = [];
        let lastDefined = !0;
        for (let i = 0, n = top.curves.length; i < n; i++) {
            const topCurve = top.curves[i];
            lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), 
            topList.length = 0, bottomList.length = 0) : (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1])), 
            lastDefined = !lastDefined) : lastDefined && (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1]));
        }
        return void drawAreaBlock(path, topList, bottomList, params);
    }
    if (percent <= 0) return;
    let {direction: direction} = params || {};
    const {curves: topCurves} = top, endP = null !== (_a = topCurves[topCurves.length - 1].p3) && void 0 !== _a ? _a : topCurves[topCurves.length - 1].p1, xTotalLength = (0, 
    vutils_1.abs)(endP.x - topCurves[0].p0.x), yTotalLength = (0, vutils_1.abs)(endP.y - topCurves[0].p0.y);
    direction = null != direction ? direction : xTotalLength > yTotalLength ? enums_1.Direction.ROW : enums_1.Direction.COLUMN, 
    Number.isFinite(xTotalLength) || (direction = enums_1.Direction.COLUMN), Number.isFinite(yTotalLength) || (direction = enums_1.Direction.ROW);
    const totalDrawLength = percent * (direction === enums_1.Direction.ROW ? xTotalLength : yTotalLength);
    let drawedLengthUntilLast = 0, lastDefined = !0;
    const topList = [], bottomList = [];
    for (let i = 0, n = top.curves.length; i < n; i++) {
        const topCurve = top.curves[i], curCurveLength = topCurve.getLength(direction), percent = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
        if (percent < 0) break;
        drawedLengthUntilLast += curCurveLength;
        let tc = null, bc = null;
        lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), 
        topList.length = 0, bottomList.length = 0) : (tc = topCurve, bc = bottom.curves[n - i - 1]), 
        lastDefined = !lastDefined) : lastDefined && (tc = topCurve, bc = bottom.curves[n - i - 1]), 
        tc && bc && (percent < 1 && (tc = tc.p2 && tc.p3 ? (0, cubic_bezier_1.divideCubic)(tc, percent)[0] : (0, 
        line_1.divideLinear)(tc, percent)[0], bc = bc.p2 && bc.p3 ? (0, cubic_bezier_1.divideCubic)(bc, 1 - percent)[1] : (0, 
        line_1.divideLinear)(bc, 1 - percent)[1]), tc.defined = lastDefined, bc.defined = lastDefined, 
        topList.push(tc), bottomList.push(bc)), tc = null, bc = null;
    }
    drawAreaBlock(path, topList, bottomList, params);
}

function drawAreaBlock(path, topList, bottomList, params) {
    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0} = params || {};
    let needMoveTo = !0;
    topList.forEach((curve => {
        curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), 
        drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
    })), needMoveTo = !0;
    for (let i = bottomList.length - 1; i >= 0; i--) {
        const curve = bottomList[i];
        curve.defined ? (needMoveTo && path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), 
        drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
    }
}

function drawSegItem(ctx, curve, endPercent, params) {
    if (!curve.p1) return;
    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0} = params || {};
    if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ); else if (curve.p2 && curve.p3) {
        const [curve1] = (0, cubic_bezier_1.divideCubic)(curve, endPercent);
        ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
    } else {
        const p = curve.getPointAt(endPercent);
        ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
    }
}

//# sourceMappingURL=render-area.js.map
exports.drawAreaSegments = drawAreaSegments;
}, function(modId) { var map = {"./enums":1689069767685,"./segment/curve/cubic-bezier":1689069767691,"./segment/curve/line":1689069767694}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767822, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasPathRender = void 0;

const inversify_1 = require("inversify"), contribution_provider_1 = require("../../../common/contribution-provider"), render_command_list_1 = require("../../../common/render-command-list"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants"), utils_1 = require("./utils"), path_contribution_render_1 = require("./contributions/path-contribution-render"), enums_1 = require("../../../common/enums"), base_render_1 = require("./base-render"), matrix_allocate_1 = require("../../../allocator/matrix-allocate");

let DefaultCanvasPathRender = class extends base_render_1.BaseRender {
    constructor(pathRenderContribitions) {
        super(), this.pathRenderContribitions = pathRenderContribitions, this.numberType = constants_1.PATH_NUMBER_TYPE;
    }
    drawShape(path, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a, _b;
        const pathAttribute = (0, theme_1.getTheme)(path, null == params ? void 0 : params.theme).path, {fill: fill = pathAttribute.fill, stroke: stroke = pathAttribute.stroke, fillOpacity: fillOpacity = pathAttribute.fillOpacity, strokeOpacity: strokeOpacity = pathAttribute.strokeOpacity, opacity: opacity = pathAttribute.opacity, background: background, lineWidth: lineWidth = pathAttribute.lineWidth, visible: visible = pathAttribute.visible, x: originX = pathAttribute.x, y: originY = pathAttribute.y} = path.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, fVisible = (0, 
        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, 
        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);
        if (path.valid && visible && (doFill || doStroke || background) && (fVisible || sVisible || fillCb || strokeCb || background)) {
            if (context.beginPath(), path.pathShape) (0, render_command_list_1.renderCommandList)(path.pathShape.commandList, context, x, y, 1, 1, z); else {
                const path2D = null !== (_b = path.attribute.path) && void 0 !== _b ? _b : pathAttribute.path;
                (0, render_command_list_1.renderCommandList)(path2D.commandList, context, x, y, 1, 1, z);
            }
            this._pathRenderContribitions || (this._pathRenderContribitions = this.pathRenderContribitions.getContributions() || [], 
            this._pathRenderContribitions.sort(((a, b) => b.order - a.order))), this._pathRenderContribitions.forEach((c => {
                c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, fillCb, strokeCb);
            })), context.setShadowStyle && context.setShadowStyle(path, path.attribute, pathAttribute), 
            doStroke && (strokeCb ? strokeCb(context, path.attribute, pathAttribute) : sVisible && (context.setStrokeStyle(path, path.attribute, originX - x, originY - y, pathAttribute), 
            context.stroke())), doFill && (fillCb ? fillCb(context, path.attribute, pathAttribute) : fVisible && (context.setCommonStyle(path, path.attribute, originX - x, originY - y, pathAttribute), 
            context.fill())), this._pathRenderContribitions.forEach((c => {
                c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, fillCb, strokeCb);
            }));
        }
    }
    draw(path, renderService, drawContext, params) {
        const {context: context} = drawContext;
        if (!context) return;
        context.highPerformanceSave();
        const pathAttribute = (0, theme_1.getTheme)(path, null == params ? void 0 : params.theme).path, data = this.transform(path, pathAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        this.z = z, (0, utils_1.drawPathProxy)(path, context, x, y, drawContext, params) || (this.drawShape(path, context, x, y, drawContext, params), 
        this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), 
        context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
    }
};

DefaultCanvasPathRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(path_contribution_render_1.PathRenderContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasPathRender), 
exports.DefaultCanvasPathRender = DefaultCanvasPathRender;
//# sourceMappingURL=path-render.js.map

}, function(modId) { var map = {"../../../common/contribution-provider":1689069767672,"../../../common/render-command-list":1689069767687,"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744,"./utils":1689069767752,"./contributions/path-contribution-render":1689069767823,"../../../common/enums":1689069767685,"./base-render":1689069767817,"../../../allocator/matrix-allocate":1689069767808}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767823, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultPathTextureRenderContribution = exports.DefaultPathBackgroundRenderContribution = exports.PathRenderContribution = void 0;

const inversify_1 = require("inversify"), base_contribution_render_1 = require("./base-contribution-render"), enums_1 = require("../../../../common/enums");

exports.PathRenderContribution = Symbol.for("PathRenderContribution");

let DefaultPathBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;
    }
};

DefaultPathBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultPathBackgroundRenderContribution), 
exports.DefaultPathBackgroundRenderContribution = DefaultPathBackgroundRenderContribution;

let DefaultPathTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;
    }
};

DefaultPathTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultPathTextureRenderContribution), 
exports.DefaultPathTextureRenderContribution = DefaultPathTextureRenderContribution;
//# sourceMappingURL=path-contribution-render.js.map

}, function(modId) { var map = {"./base-contribution-render":1689069767756,"../../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767824, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasRectRender = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants"), rect_1 = require("../../../common/shape/rect"), contribution_provider_1 = require("../../../common/contribution-provider"), rect_contribution_render_1 = require("./contributions/rect-contribution-render"), utils_1 = require("./utils"), enums_1 = require("../../../common/enums");

let DefaultCanvasRectRender = class {
    constructor(rectRenderContribitions) {
        this.rectRenderContribitions = rectRenderContribitions, this.type = "rect", this.numberType = constants_1.RECT_NUMBER_TYPE;
    }
    drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {
        const rectAttribute = (0, theme_1.getTheme)(rect, null == params ? void 0 : params.theme).rect, {fill: fill = rectAttribute.fill, background: background, stroke: stroke = rectAttribute.stroke, width: width = rectAttribute.width, height: height = rectAttribute.height, cornerRadius: cornerRadius = rectAttribute.cornerRadius, opacity: opacity = rectAttribute.opacity, fillOpacity: fillOpacity = rectAttribute.fillOpacity, lineWidth: lineWidth = rectAttribute.lineWidth, strokeOpacity: strokeOpacity = rectAttribute.strokeOpacity, visible: visible = rectAttribute.visible, x: originX = rectAttribute.x, y: originY = rectAttribute.y} = rect.attribute, fVisible = (0, 
        utils_1.rectFillVisible)(opacity, fillOpacity, width, height), sVisible = (0, utils_1.rectStrokeVisible)(opacity, strokeOpacity, width, height), doFill = (0, 
        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);
        if (!rect.valid || !visible) return;
        if (!(doFill || doStroke || background)) return;
        if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
        0 === cornerRadius || (0, vutils_1.isArray)(cornerRadius) && cornerRadius.every((num => 0 === num)) ? (context.beginPath(), 
        context.rect(x, y, width, height)) : (context.beginPath(), (0, rect_1.createRectPath)(context, x, y, width, height, cornerRadius)), 
        this._rectRenderContribitions || (this._rectRenderContribitions = this.rectRenderContribitions.getContributions() || [], 
        this._rectRenderContribitions.sort(((a, b) => b.order - a.order)));
        const doFillOrStroke = {
            doFill: doFill,
            doStroke: doStroke
        };
        this._rectRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, fillCb, strokeCb, doFillOrStroke);
        })), context.setShadowStyle && context.setShadowStyle(rect, rect.attribute, rectAttribute), 
        doFillOrStroke.doFill && (fillCb ? fillCb(context, rect.attribute, rectAttribute) : fVisible && (context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), 
        context.fill())), doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, rect.attribute, rectAttribute) : sVisible && (context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), 
        context.stroke())), this._rectRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, fillCb, strokeCb);
        }));
    }
    draw(rect, renderService, drawContext, params) {
        const {context: context} = drawContext;
        if (!context) return;
        context.highPerformanceSave();
        const rectAttribute = (0, theme_1.getTheme)(rect, null == params ? void 0 : params.theme).rect;
        let {x: x = rectAttribute.x, y: y = rectAttribute.y} = rect.attribute;
        if (rect.transMatrix.onlyTranslate()) {
            const point = rect.getOffsetXY(rectAttribute);
            x += point.x, y += point.y, context.setTransformForCurrent();
        } else x = 0, y = 0, context.transformFromMatrix(rect.transMatrix, !0);
        (0, utils_1.drawPathProxy)(rect, context, x, y, drawContext, params) || this.drawShape(rect, context, x, y, drawContext, params), 
        context.highPerformanceRestore();
    }
};

DefaultCanvasRectRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(rect_contribution_render_1.RectRenderContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasRectRender), 
exports.DefaultCanvasRectRender = DefaultCanvasRectRender;
//# sourceMappingURL=rect-render.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744,"../../../common/shape/rect":1689069767825,"../../../common/contribution-provider":1689069767672,"./contributions/rect-contribution-render":1689069767826,"./utils":1689069767752,"../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767825, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createRectPath = void 0;

const vutils_1 = require("@visactor/vutils"), halfPi = vutils_1.pi / 2;

function createRectPath(path, x, y, width, height, rectCornerRadius) {
    let cornerRadius;
    if ((0, vutils_1.isNumber)(rectCornerRadius, !0)) cornerRadius = [ rectCornerRadius, rectCornerRadius, rectCornerRadius, rectCornerRadius ]; else if (Array.isArray(rectCornerRadius)) {
        const cornerRadiusArr = rectCornerRadius;
        switch (cornerRadiusArr.length) {
          case 0:
            cornerRadius = [ 0, 0, 0, 0 ];
            break;

          case 1:
            cornerRadius = [ cornerRadiusArr[0], cornerRadiusArr[0], cornerRadiusArr[0], cornerRadiusArr[0] ];
            break;

          case 2:
          case 3:
            cornerRadius = [ cornerRadiusArr[0], cornerRadiusArr[1], cornerRadiusArr[0], cornerRadiusArr[1] ];
            break;

          default:
            cornerRadius = cornerRadiusArr.slice(0, 5);
        }
    } else cornerRadius = [ 0, 0, 0, 0 ];
    if (width < 0 || Math.abs(cornerRadius[0]) + Math.abs(cornerRadius[1]) + Math.abs(cornerRadius[2]) + Math.abs(cornerRadius[3]) < 1e-12) return path.rect(x, y, width, height);
    const [leftTop, rightTop, rightBottom, leftBottom] = [ [ x, y ], [ x + width, y ], [ x + width, y + height ], [ x, y + height ] ], maxCornerRadius = Math.min(width / 2, height / 2), _cornerRadius = [ Math.min(maxCornerRadius, cornerRadius[0]), Math.min(maxCornerRadius, cornerRadius[1]), Math.min(maxCornerRadius, cornerRadius[2]), Math.min(maxCornerRadius, cornerRadius[3]) ], leftTopPoint1 = [ leftTop[0] + _cornerRadius[0], leftTop[1] ], leftTopPoint2 = [ leftTop[0], leftTop[1] + _cornerRadius[0] ], rightTopPoint1 = [ rightTop[0] - _cornerRadius[1], rightTop[1] ], rightTopPoint2 = [ rightTop[0], rightTop[1] + _cornerRadius[1] ], rightBottomPoint1 = [ rightBottom[0] - _cornerRadius[2], rightBottom[1] ], rightBottomPoint2 = [ rightBottom[0], rightBottom[1] - _cornerRadius[2] ], leftBottomPoint1 = [ leftBottom[0] + _cornerRadius[3], leftBottom[1] ], leftBottomPoint2 = [ leftBottom[0], leftBottom[1] - _cornerRadius[3] ];
    if (path.moveTo(leftTopPoint1[0], leftTopPoint1[1]), path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), 
    !(0, vutils_1.arrayEqual)(rightTopPoint1, rightTopPoint2)) {
        const centerX = rightTopPoint1[0], centerY = rightTopPoint1[1] + _cornerRadius[1];
        path.arc(centerX, centerY, _cornerRadius[1], -halfPi, 0, !1);
    }
    if (path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]), !(0, vutils_1.arrayEqual)(rightBottomPoint1, rightBottomPoint2)) {
        const centerX = rightBottomPoint2[0] - _cornerRadius[2], centerY = rightBottomPoint2[1];
        path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi, !1);
    }
    if (path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), !(0, vutils_1.arrayEqual)(leftBottomPoint1, leftBottomPoint2)) {
        const centerX = leftBottomPoint1[0], centerY = leftBottomPoint1[1] - _cornerRadius[3];
        path.arc(centerX, centerY, _cornerRadius[3], halfPi, vutils_1.pi, !1);
    }
    if (path.lineTo(leftTopPoint2[0], leftTopPoint2[1]), !(0, vutils_1.arrayEqual)(leftTopPoint1, leftTopPoint2)) {
        const centerX = leftTopPoint1[0], centerY = leftTopPoint1[1] + _cornerRadius[0];
        path.arc(centerX, centerY, _cornerRadius[0], vutils_1.pi, vutils_1.pi + halfPi, !1);
    }
    return path.closePath(), path;
}

exports.createRectPath = createRectPath;
//# sourceMappingURL=rect.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767826, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.SplitRectAfterRenderContribution = exports.SplitRectBeforeRenderContribution = exports.DefaultRectTextureRenderContribution = exports.DefaultRectBackgroundRenderContribution = exports.DefaultRectRenderContribution = exports.RectRenderContribution = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), canvas_utils_1 = require("../../../../common/canvas-utils"), base_contribution_render_1 = require("./base-contribution-render"), rect_1 = require("../../../../common/shape/rect"), enums_1 = require("../../../../common/enums");

exports.RectRenderContribution = Symbol.for("RectRenderContribution");

let DefaultRectRenderContribution = class {
    constructor() {
        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, fillCb, strokeCb) {
        const {width: width = rectAttribute.width, height: height = rectAttribute.height, cornerRadius: cornerRadius = rectAttribute.cornerRadius, opacity: opacity = rectAttribute.opacity, outerBorder: outerBorder, innerBorder: innerBorder} = rect.attribute;
        if (outerBorder) {
            const {distance: distance = rectAttribute.outerBorder.distance} = outerBorder, d = (0, 
            canvas_utils_1.getScaledStroke)(context, distance, context.dpr), nextX = x - d, nextY = y - d, dw = 2 * d;
            if (0 === cornerRadius || (0, vutils_1.isArray)(cornerRadius) && cornerRadius.every((num => 0 === num)) ? (context.beginPath(), 
            context.rect(nextX, nextY, width + dw, height + dw)) : (context.beginPath(), (0, 
            rect_1.createRectPath)(context, nextX, nextY, width + dw, height + dw, cornerRadius)), 
            context.setShadowStyle && context.setShadowStyle(rect, rect.attribute, rectAttribute), 
            strokeCb) strokeCb(context, outerBorder, rectAttribute.outerBorder); else if (sVisible) {
                const lastOpacity = rectAttribute.outerBorder.opacity;
                rectAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(rect, outerBorder, x, y, rectAttribute.outerBorder), 
                rectAttribute.outerBorder.opacity = lastOpacity, context.stroke();
            }
        }
        if (innerBorder) {
            const {distance: distance = rectAttribute.innerBorder.distance} = innerBorder, d = (0, 
            canvas_utils_1.getScaledStroke)(context, distance, context.dpr), nextX = x + d, nextY = y + d, dw = 2 * d;
            if (0 === cornerRadius || (0, vutils_1.isArray)(cornerRadius) && cornerRadius.every((num => 0 === num)) ? (context.beginPath(), 
            context.rect(nextX, nextY, width - dw, height - dw)) : (context.beginPath(), (0, 
            rect_1.createRectPath)(context, nextX, nextY, width - dw, height - dw, cornerRadius)), 
            context.setShadowStyle && context.setShadowStyle(rect, rect.attribute, rectAttribute), 
            strokeCb) strokeCb(context, innerBorder, rectAttribute.innerBorder); else if (sVisible) {
                const lastOpacity = rectAttribute.innerBorder.opacity;
                rectAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(rect, innerBorder, x, y, rectAttribute.innerBorder), 
                rectAttribute.innerBorder.opacity = lastOpacity, context.stroke();
            }
        }
    }
};

DefaultRectRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultRectRenderContribution), 
exports.DefaultRectRenderContribution = DefaultRectRenderContribution;

let DefaultRectBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;
    }
};

DefaultRectBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultRectBackgroundRenderContribution), 
exports.DefaultRectBackgroundRenderContribution = DefaultRectBackgroundRenderContribution;

let DefaultRectTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;
    }
};

DefaultRectTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultRectTextureRenderContribution), 
exports.DefaultRectTextureRenderContribution = DefaultRectTextureRenderContribution;

let SplitRectBeforeRenderContribution = class {
    constructor() {
        this.time = enums_1.BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb, doFillOrStroke) {
        const {stroke: stroke = groupAttribute.stroke} = group.attribute;
        Array.isArray(stroke) && stroke.some((s => !1 === s)) && (doFillOrStroke.doStroke = !1);
    }
};

SplitRectBeforeRenderContribution = __decorate([ (0, inversify_1.injectable)() ], SplitRectBeforeRenderContribution), 
exports.SplitRectBeforeRenderContribution = SplitRectBeforeRenderContribution;

let SplitRectAfterRenderContribution = class {
    constructor() {
        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb) {
        const {width: width = groupAttribute.width, height: height = groupAttribute.height, stroke: stroke = groupAttribute.stroke} = rect.attribute;
        if (Array.isArray(stroke) && stroke.some((s => !1 === s))) {
            if (context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute), context.beginPath(), 
            context.moveTo(x, y), stroke[0] ? context.lineTo(x + width, y) : context.moveTo(x + width, y), 
            stroke[1] ? context.lineTo(x + width, y + height) : context.moveTo(x + width, y + height), 
            stroke[2] ? context.lineTo(x, y + height) : context.moveTo(x, y + height), stroke[3]) {
                const adjustY = stroke[0] ? y - context.lineWidth / 2 : y;
                context.lineTo(x, adjustY);
            } else context.moveTo(x, y);
            context.stroke();
        }
    }
};

SplitRectAfterRenderContribution = __decorate([ (0, inversify_1.injectable)() ], SplitRectAfterRenderContribution), 
exports.SplitRectAfterRenderContribution = SplitRectAfterRenderContribution;
//# sourceMappingURL=rect-contribution-render.js.map

}, function(modId) { var map = {"../../../../common/canvas-utils":1689069767755,"./base-contribution-render":1689069767756,"../../../../common/shape/rect":1689069767825,"../../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767827, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasSymbolRender = void 0;

const matrix_allocate_1 = require("../../../allocator/matrix-allocate"), inversify_1 = require("inversify"), contribution_provider_1 = require("../../../common/contribution-provider"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants"), base_render_1 = require("./base-render"), enums_1 = require("../../../common/enums"), symbol_contribution_render_1 = require("./contributions/symbol-contribution-render"), utils_1 = require("./utils");

let DefaultCanvasSymbolRender = class extends base_render_1.BaseRender {
    constructor(symbolRenderContribitions) {
        super(), this.symbolRenderContribitions = symbolRenderContribitions, this.numberType = constants_1.SYMBOL_NUMBER_TYPE;
    }
    drawShape(symbol, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        const symbolAttribute = (0, theme_1.getTheme)(symbol, null == params ? void 0 : params.theme).symbol, {size: size = symbolAttribute.size, fill: fill = symbolAttribute.fill, background: background, fillOpacity: fillOpacity = symbolAttribute.fillOpacity, strokeOpacity: strokeOpacity = symbolAttribute.strokeOpacity, opacity: opacity = symbolAttribute.opacity, lineWidth: lineWidth = symbolAttribute.lineWidth, stroke: stroke = symbolAttribute.stroke, visible: visible = symbolAttribute.visible, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX: scaleX = symbolAttribute.scaleX, scaleY: scaleY = symbolAttribute.scaleY} = symbol.attribute, fVisible = (0, 
        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, 
        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);
        if (!symbol.valid || !visible) return;
        if (!(doFill || doStroke || background)) return;
        if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
        const parsedPath = symbol.getParsedPath();
        if (!parsedPath) return;
        const {keepDirIn3d: keepDirIn3d = symbolAttribute.keepDirIn3d} = symbol.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
        if (context.beginPath(), keepDirIn3d && context.camera && context.project) {
            const p = context.project(x, y, z), camera = context.camera;
            context.camera = null, !1 === parsedPath.draw(context, size, p.x, p.y) && context.closePath(), 
            context.camera = camera;
        } else !1 === parsedPath.draw(context, size, x, y, z) && context.closePath();
        this._symbolRenderContribitions || (this._symbolRenderContribitions = this.symbolRenderContribitions.getContributions() || [], 
        this._symbolRenderContribitions.sort(((a, b) => b.order - a.order))), this._symbolRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, fillCb, strokeCb);
        })), context.setShadowStyle && context.setShadowStyle(symbol, symbol.attribute, symbolAttribute), 
        doFill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : fVisible && (context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute), 
        context.fill())), doStroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && (context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), 
        context.stroke())), this._symbolRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, fillCb, strokeCb);
        }));
    }
    draw(symbol, renderService, drawContext, params) {
        const {context: context} = drawContext;
        if (!context) return;
        context.highPerformanceSave();
        const symbolAttribute = (0, theme_1.getTheme)(symbol, null == params ? void 0 : params.theme).symbol, data = this.transform(symbol, symbolAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        this.z = z, (0, utils_1.drawPathProxy)(symbol, context, x, y, drawContext, params) || (this.drawShape(symbol, context, x, y, drawContext, params), 
        this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), 
        context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
    }
};

DefaultCanvasSymbolRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(symbol_contribution_render_1.SymbolRenderContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasSymbolRender), 
exports.DefaultCanvasSymbolRender = DefaultCanvasSymbolRender;
//# sourceMappingURL=symbol-render.js.map

}, function(modId) { var map = {"../../../allocator/matrix-allocate":1689069767808,"../../../common/contribution-provider":1689069767672,"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744,"./base-render":1689069767817,"../../../common/enums":1689069767685,"./contributions/symbol-contribution-render":1689069767828,"./utils":1689069767752}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767828, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultSymbolTextureRenderContribution = exports.DefaultSymbolBackgroundRenderContribution = exports.DefaultSymbolRenderContribution = exports.SymbolRenderContribution = void 0;

const inversify_1 = require("inversify"), canvas_utils_1 = require("../../../../common/canvas-utils"), base_contribution_render_1 = require("./base-contribution-render"), enums_1 = require("../../../../common/enums");

exports.SymbolRenderContribution = Symbol.for("SymbolRenderContribution");

let DefaultSymbolRenderContribution = class {
    constructor() {
        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, 
        this.order = 0;
    }
    drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, fillCb, strokeCb) {
        const {size: size = symbolAttribute.size, opacity: opacity = symbolAttribute.opacity, outerBorder: outerBorder, innerBorder: innerBorder} = symbol.attribute, parsedPath = symbol.getParsedPath();
        if (parsedPath) {
            if (outerBorder) {
                const {distance: distance = symbolAttribute.outerBorder.distance} = outerBorder, d = (0, 
                canvas_utils_1.getScaledStroke)(context, distance, context.dpr);
                if (context.beginPath(), !1 === parsedPath.drawOffset(context, size, x, y, d) && context.closePath(), 
                context.setShadowStyle && context.setShadowStyle(symbol, symbol.attribute, symbolAttribute), 
                strokeCb) strokeCb(context, outerBorder, symbolAttribute.outerBorder); else if (sVisible) {
                    const lastOpacity = symbolAttribute.outerBorder.opacity;
                    symbolAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(symbol, outerBorder, x, y, symbolAttribute.outerBorder), 
                    symbolAttribute.outerBorder.opacity = lastOpacity, context.stroke();
                }
            }
            if (innerBorder) {
                const {distance: distance = symbolAttribute.innerBorder.distance} = innerBorder, d = (0, 
                canvas_utils_1.getScaledStroke)(context, distance, context.dpr);
                if (context.beginPath(), !1 === parsedPath.drawOffset(context, size, x, y, -d) && context.closePath(), 
                context.setShadowStyle && context.setShadowStyle(symbol, symbol.attribute, symbolAttribute), 
                strokeCb) strokeCb(context, innerBorder, symbolAttribute.innerBorder); else if (sVisible) {
                    const lastOpacity = symbolAttribute.innerBorder.opacity;
                    symbolAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(symbol, innerBorder, x, y, symbolAttribute.innerBorder), 
                    symbolAttribute.innerBorder.opacity = lastOpacity, context.stroke();
                }
            }
        }
    }
};

DefaultSymbolRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultSymbolRenderContribution), 
exports.DefaultSymbolRenderContribution = DefaultSymbolRenderContribution;

class DefaultSymbolBackgroundRenderContribution extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;
    }
}

exports.DefaultSymbolBackgroundRenderContribution = DefaultSymbolBackgroundRenderContribution;

class DefaultSymbolTextureRenderContribution extends base_contribution_render_1.DefaultBaseTextureRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;
    }
}

exports.DefaultSymbolTextureRenderContribution = DefaultSymbolTextureRenderContribution;
//# sourceMappingURL=symbol-contribution-render.js.map

}, function(modId) { var map = {"../../../../common/canvas-utils":1689069767755,"./base-contribution-render":1689069767756,"../../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767829, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasTextRender = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants"), text_1 = require("../../../common/text"), utils_1 = require("./utils"), base_render_1 = require("./base-render");

let DefaultCanvasTextRender = class extends base_render_1.BaseRender {
    constructor() {
        super(...arguments), this.numberType = constants_1.TEXT_NUMBER_TYPE;
    }
    drawShape(text, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        const textAttribute = (0, theme_1.getTheme)(text, null == params ? void 0 : params.theme).text, {text: str, fill: fill = textAttribute.fill, stroke: stroke = textAttribute.stroke, fillOpacity: fillOpacity = textAttribute.fillOpacity, strokeOpacity: strokeOpacity = textAttribute.strokeOpacity, opacity: opacity = textAttribute.opacity, lineWidth: lineWidth = textAttribute.lineWidth, visible: visible = textAttribute.visible, underline: underline = textAttribute.underline, lineThrough: lineThrough = textAttribute.lineThrough, keepDirIn3d: keepDirIn3d = textAttribute.keepDirIn3d, fontSize: fontSize = textAttribute.fontSize, textBaseline: textBaseline = textAttribute.textBaseline, x: originX = textAttribute.x, y: originY = textAttribute.y} = text.attribute, lineHeight = null !== (_a = text.attribute.lineHeight) && void 0 !== _a ? _a : fontSize, fVisible = (0, 
        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, 
        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);
        if (!text.valid || !visible) return;
        if (!(doFill || doStroke || fVisible || sVisible)) return;
        const transform3dMatrixToContextMatrix = !keepDirIn3d, z = this.z || 0;
        if (context.beginPath(), context.setShadowStyle && context.setShadowStyle(text, text.attribute, textAttribute), 
        transform3dMatrixToContextMatrix && this.transformUseContext2d(text, textAttribute, z, context), 
        Array.isArray(str)) {
            context.setTextStyleWithoutAlignBaseline(text.attribute, textAttribute, z);
            const {multilineLayout: multilineLayout} = text;
            if (!multilineLayout) return void context.highPerformanceRestore();
            const {xOffset: xOffset, yOffset: yOffset} = multilineLayout.bbox;
            doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), 
            multilineLayout.lines.forEach((line => {
                context.strokeText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);
            })))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), 
            multilineLayout.lines.forEach((line => {
                context.fillText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z), 
                this.drawMultiUnderLine(underline, lineThrough, text, (line.leftOffset || 0) + x, (line.topOffset || 0) + yOffset + y, z, line.width, textAttribute, context);
            }))));
        } else {
            context.setTextStyle(text.attribute, textAttribute, z);
            const t = text.clipedText;
            let dy = 0;
            lineHeight !== fontSize && ("top" === textBaseline ? dy = (lineHeight - fontSize) / 2 : "middle" === textBaseline || "bottom" === textBaseline && (dy = -(lineHeight - fontSize) / 2)), 
            doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), 
            context.strokeText(t, x, y + dy, z))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), 
            context.fillText(t, x, y + dy, z), this.drawUnderLine(underline, lineThrough, text, x, y + dy, z, textAttribute, context)));
        }
        transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text, textAttribute, z, context);
    }
    draw(text, renderService, drawContext, params) {
        const {context: context} = drawContext;
        if (!context) return;
        context.highPerformanceSave();
        const textAttribute = (0, theme_1.getTheme)(text, null == params ? void 0 : params.theme).text, {keepDirIn3d: keepDirIn3d = textAttribute.keepDirIn3d} = text.attribute, computed3dMatrix = !keepDirIn3d, data = this.transform(text, textAttribute, context, computed3dMatrix), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        this.z = z, this.drawShape(text, context, x, y, drawContext, params), this.z = 0, 
        context.modelMatrix = lastModelMatrix, context.highPerformanceRestore();
    }
    drawUnderLine(underline, lineThrough, text, x, y, z, textAttribute, context) {
        if (lineThrough + underline <= 0) return;
        const {textAlign: textAlign = textAttribute.textAlign, textBaseline: textBaseline = textAttribute.textBaseline, fontSize: fontSize = textAttribute.fontSize, fill: fill = textAttribute.fill, opacity: opacity = textAttribute.opacity, fillOpacity: fillOpacity = textAttribute.fillOpacity} = text.attribute, w = text.clipedWidth, offsetX = (0, 
        text_1.textDrawOffsetX)(textAlign, w), offsetY = (0, text_1.textLayoutOffsetY)(textBaseline, fontSize, fontSize), attribute = {
            lineWidth: 0,
            stroke: fill,
            opacity: opacity,
            strokeOpacity: fillOpacity
        };
        if (underline) {
            attribute.lineWidth = underline, context.setStrokeStyle(text, attribute, x, y, textAttribute), 
            context.beginPath();
            const dy = y + offsetY + fontSize;
            context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();
        }
        if (lineThrough) {
            attribute.lineWidth = lineThrough, context.setStrokeStyle(text, attribute, x, y, textAttribute), 
            context.beginPath();
            const dy = y + offsetY + fontSize / 2;
            context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();
        }
    }
    drawMultiUnderLine(underline, lineThrough, text, x, y, z, w, textAttribute, context) {
        if (lineThrough + underline <= 0) return;
        const {textAlign: textAlign = textAttribute.textAlign, fontSize: fontSize = textAttribute.fontSize, fill: fill = textAttribute.fill, opacity: opacity = textAttribute.opacity, fillOpacity: fillOpacity = textAttribute.fillOpacity} = text.attribute, offsetX = (0, 
        text_1.textDrawOffsetX)(textAlign, w), offsetY = (0, text_1.textLayoutOffsetY)("alphabetic", fontSize, fontSize), attribute = {
            lineWidth: 0,
            stroke: fill,
            opacity: opacity,
            strokeOpacity: fillOpacity
        };
        let deltaY = -3;
        if (underline) {
            attribute.lineWidth = underline, context.setStrokeStyle(text, attribute, x, y, textAttribute), 
            context.beginPath();
            const dy = y + offsetY + fontSize + deltaY;
            context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();
        }
        if (deltaY = -1, lineThrough) {
            attribute.lineWidth = lineThrough, context.setStrokeStyle(text, attribute, x, y, textAttribute), 
            context.beginPath();
            const dy = y + offsetY + fontSize / 2 + deltaY;
            context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();
        }
    }
};

DefaultCanvasTextRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasTextRender), 
exports.DefaultCanvasTextRender = DefaultCanvasTextRender;
//# sourceMappingURL=text-render.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744,"../../../common/text":1689069767760,"./utils":1689069767752,"./base-render":1689069767817}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767830, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.AbstractGraphicRender = void 0;

const inversify_1 = require("inversify");

let AbstractGraphicRender = class {};

AbstractGraphicRender = __decorate([ (0, inversify_1.injectable)() ], AbstractGraphicRender), 
exports.AbstractGraphicRender = AbstractGraphicRender;
//# sourceMappingURL=graphic-render.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767831, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasPolygonRender = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants"), polygon_1 = require("../../../common/polygon"), utils_1 = require("./utils"), polygon_contribution_render_1 = require("./contributions/polygon-contribution-render"), contribution_provider_1 = require("../../../common/contribution-provider"), enums_1 = require("../../../common/enums");

let DefaultCanvasPolygonRender = class {
    constructor(polygonRenderContribitions) {
        this.polygonRenderContribitions = polygonRenderContribitions, this.numberType = constants_1.POLYGON_NUMBER_TYPE;
    }
    drawShape(polygon, context, x, y, drawContext, params, fillCb, strokeCb) {
        const polygonAttribute = (0, theme_1.getTheme)(polygon, null == params ? void 0 : params.theme).polygon, {points: points = polygonAttribute.points, fill: fill = polygonAttribute.fill, stroke: stroke = polygonAttribute.stroke, cornerRadius: cornerRadius = polygonAttribute.cornerRadius, fillOpacity: fillOpacity = polygonAttribute.fillOpacity, background: background, strokeOpacity: strokeOpacity = polygonAttribute.strokeOpacity, lineWidth: lineWidth = polygonAttribute.lineWidth, opacity: opacity = polygonAttribute.opacity, visible: visible = polygonAttribute.visible, x: originX = polygonAttribute.x, y: originY = polygonAttribute.y} = polygon.attribute, fVisible = (0, 
        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, 
        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);
        polygon.valid && visible && (doFill || doStroke || background) && (fVisible || sVisible || fillCb || strokeCb || background) && (context.beginPath(), 
        cornerRadius <= 0 || (0, vutils_1.isArray)(cornerRadius) && cornerRadius.every((num => 0 === num)) ? (0, 
        polygon_1.drawPolygon)(context.camera ? context : context.nativeContext, points, x, y) : (0, 
        polygon_1.drawRoundedPolygon)(context.camera ? context : context.nativeContext, points, x, y, cornerRadius), 
        context.closePath(), this._polygonRenderContribitions || (this._polygonRenderContribitions = this.polygonRenderContribitions.getContributions() || [], 
        this._polygonRenderContribitions.sort(((a, b) => b.order - a.order))), this._polygonRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, fillCb, strokeCb);
        })), context.setShadowStyle && context.setShadowStyle(polygon, polygon.attribute, polygonAttribute), 
        doFill && (fillCb ? fillCb(context, polygon.attribute, polygonAttribute) : fillOpacity && (context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), 
        context.fill())), doStroke && (strokeCb ? strokeCb(context, polygon.attribute, polygonAttribute) : strokeOpacity && (context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), 
        context.stroke())), this._polygonRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, fillCb, strokeCb);
        })));
    }
    draw(polygon, renderService, drawContext, params) {
        const {context: context} = drawContext;
        if (!context) return;
        context.highPerformanceSave();
        const polygonAttribute = (0, theme_1.getTheme)(polygon, null == params ? void 0 : params.theme).polygon;
        let {x: x = polygonAttribute.x, y: y = polygonAttribute.y} = polygon.attribute;
        if (polygon.transMatrix.onlyTranslate()) {
            const point = polygon.getOffsetXY(polygonAttribute);
            x += point.x, y += point.y, context.setTransformForCurrent();
        } else x = 0, y = 0, context.transformFromMatrix(polygon.transMatrix, !0);
        (0, utils_1.drawPathProxy)(polygon, context, x, y, drawContext, params) || this.drawShape(polygon, context, x, y, drawContext, params), 
        context.highPerformanceRestore();
    }
};

DefaultCanvasPolygonRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(polygon_contribution_render_1.PolygonRenderContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasPolygonRender), 
exports.DefaultCanvasPolygonRender = DefaultCanvasPolygonRender;
//# sourceMappingURL=polygon-render.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744,"../../../common/polygon":1689069767832,"./utils":1689069767752,"./contributions/polygon-contribution-render":1689069767833,"../../../common/contribution-provider":1689069767672,"../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767832, function(require, module, exports) {


function drawPolygon(path, points, x, y) {
    path.moveTo(points[0].x + x, points[0].y + y);
    for (let i = 1; i < points.length; i++) path.lineTo(points[i].x + x, points[i].y + y);
}

function drawRoundedPolygon(path, points, x, y, cornerRadius) {
    var _a;
    if (points.length < 3) drawPolygon(path, points, x, y); else for (let i = 0; i < points.length; i++) {
        const p1 = points[i], angularPoint = points[(i + 1) % points.length], p2 = points[(i + 2) % points.length], dx1 = angularPoint.x - p1.x, dy1 = angularPoint.y - p1.y, dx2 = angularPoint.x - p2.x, dy2 = angularPoint.y - p2.y, angle = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2, tan = Math.abs(Math.tan(angle));
        let radius = Array.isArray(cornerRadius) ? null !== (_a = cornerRadius[(i + 1) % points.length]) && void 0 !== _a ? _a : 0 : cornerRadius, segment = radius / tan;
        const length1 = getLength(dx1, dy1), length2 = getLength(dx2, dy2), length = Math.min(length1, length2);
        segment > length && (segment = length, radius = length * tan);
        const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1), p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2), dx = 2 * angularPoint.x - p1Cross.x - p2Cross.x, dy = 2 * angularPoint.y - p1Cross.y - p2Cross.y, L = getLength(dx, dy), circlePoint = getProportionPoint(angularPoint, getLength(segment, radius), L, dx, dy);
        let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);
        const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);
        let sweepAngle = endAngle - startAngle;
        sweepAngle < 0 && (startAngle = endAngle, sweepAngle = -sweepAngle), sweepAngle > Math.PI && (sweepAngle -= Math.PI), 
        0 === i ? path.moveTo(p1Cross.x + x, p1Cross.y + y) : path.lineTo(p1Cross.x + x, p1Cross.y + y), 
        sweepAngle && path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius), 
        path.lineTo(p2Cross.x + x, p2Cross.y + y);
    }
}

function getLength(dx, dy) {
    return Math.sqrt(dx * dx + dy * dy);
}

function getProportionPoint(point, segment, length, dx, dy) {
    const factor = segment / length;
    return {
        x: point.x - dx * factor,
        y: point.y - dy * factor
    };
}

//# sourceMappingURL=polygon.js.map
Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.drawRoundedPolygon = exports.drawPolygon = void 0, exports.drawPolygon = drawPolygon, 
exports.drawRoundedPolygon = drawRoundedPolygon;
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767833, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultPolygonTextureRenderContribution = exports.DefaultPolygonBackgroundRenderContribution = exports.PolygonRenderContribution = void 0;

const inversify_1 = require("inversify"), base_contribution_render_1 = require("./base-contribution-render"), enums_1 = require("../../../../common/enums");

exports.PolygonRenderContribution = Symbol.for("PolygonRenderContribution");

let DefaultPolygonBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;
    }
};

DefaultPolygonBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultPolygonBackgroundRenderContribution), 
exports.DefaultPolygonBackgroundRenderContribution = DefaultPolygonBackgroundRenderContribution;

let DefaultPolygonTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;
    }
};

DefaultPolygonTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultPolygonTextureRenderContribution), 
exports.DefaultPolygonTextureRenderContribution = DefaultPolygonTextureRenderContribution;
//# sourceMappingURL=polygon-contribution-render.js.map

}, function(modId) { var map = {"./base-contribution-render":1689069767756,"../../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767834, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasImageRender = void 0;

const inversify_1 = require("inversify"), contribution_provider_1 = require("../../../common/contribution-provider"), theme_1 = require("../../../graphic/theme"), image_contribution_render_1 = require("./contributions/image-contribution-render"), utils_1 = require("./utils"), constants_1 = require("../../../graphic/constants"), enums_1 = require("../../../common/enums"), repeatStr = [ "", "repeat-x", "repeat-y", "repeat" ];

let DefaultCanvasImageRender = class {
    constructor(imageRenderContribitions) {
        this.imageRenderContribitions = imageRenderContribitions, this.numberType = constants_1.IMAGE_NUMBER_TYPE;
    }
    drawShape(image, context, x, y, drawContext, params, fillCb) {
        const imageAttribute = (0, theme_1.getTheme)(image).image, {fill: fill = imageAttribute.fill, width: width = imageAttribute.width, height: height = imageAttribute.height, opacity: opacity = imageAttribute.opacity, fillOpacity: fillOpacity = imageAttribute.fillOpacity, visible: visible = imageAttribute.visible, repeatX: repeatX = imageAttribute.repeatX, repeatY: repeatY = imageAttribute.repeatY, image: url} = image.attribute, fVisible = (0, 
        utils_1.fillVisible)(opacity, fillOpacity), doFill = (0, utils_1.runFill)(fill);
        if (image.valid && visible && doFill && (fVisible || fillCb)) {
            if (this._imageRenderContribitions || (this._imageRenderContribitions = this.imageRenderContribitions.getContributions() || []), 
            this._imageRenderContribitions.forEach((c => {
                c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, fillCb);
            })), context.setShadowStyle && context.setShadowStyle(image, imageAttribute), doFill) if (fillCb) fillCb(context, image.attribute, imageAttribute); else if (fVisible) {
                if (!url || !image.resources) return;
                const res = image.resources.get(url);
                if ("success" !== res.state) return;
                context.setCommonStyle(image, image.attribute, x, y, imageAttribute);
                let repeat = 0;
                if ("repeat" === repeatX && (repeat |= 1), "repeat" === repeatY && (repeat |= 2), 
                repeat) {
                    const pattern = context.createPattern(res.data, repeatStr[repeat]);
                    context.fillStyle = pattern, context.fillRect(x, y, width, height);
                } else context.drawImage(res.data, x, y, width, height);
            }
            this._imageRenderContribitions.forEach((c => {
                c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, fillCb);
            }));
        }
    }
    draw(image, renderService, drawContext) {
        const {context: context} = renderService.drawParams;
        if (!context) return;
        const imageAttribute = (0, theme_1.getTheme)(image).image;
        let {x: x = imageAttribute.x, y: y = imageAttribute.y} = image.attribute;
        const {image: url} = image.attribute;
        if (!url || !image.resources) return;
        if ("success" === image.resources.get(url).state) {
            if (context.highPerformanceSave(), image.transMatrix.onlyTranslate()) {
                const point = image.getOffsetXY(imageAttribute);
                x += point.x, y += point.y, context.setTransformForCurrent();
            } else x = 0, y = 0, context.transformFromMatrix(image.transMatrix, !0);
            this.drawShape(image, context, x, y, drawContext), context.highPerformanceRestore();
        }
    }
};

DefaultCanvasImageRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(image_contribution_render_1.ImageRenderContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasImageRender), 
exports.DefaultCanvasImageRender = DefaultCanvasImageRender;
//# sourceMappingURL=image-render.js.map

}, function(modId) { var map = {"../../../common/contribution-provider":1689069767672,"../../../graphic/theme":1689069767707,"./contributions/image-contribution-render":1689069767835,"./utils":1689069767752,"../../../graphic/constants":1689069767744,"../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767835, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultImageBackgroundRenderContribution = exports.ImageRenderContribution = void 0;

const inversify_1 = require("inversify"), graphic_1 = require("../../../../graphic"), base_contribution_render_1 = require("./base-contribution-render"), enums_1 = require("../../../../common/enums");

exports.ImageRenderContribution = Symbol.for("ImageRenderContribution");

let DefaultImageBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb) {
        const {background: background, width: width, height: height} = graphic.attribute;
        if (background) if (graphic.backgroundImg) {
            const res = graphic.resources.get(background);
            if ("success" !== res.state || !res.data) return;
            if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
                const groupAttribute = (0, graphic_1.getTheme)(graphic.parent).group, {scrollX: scrollX = groupAttribute.scrollX, scrollY: scrollY = groupAttribute.scrollY} = graphic.parent.attribute;
                context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);
            }
            const b = graphic.AABBBounds;
            context.drawImage(res.data, b.x1, b.y1, b.width(), b.height()), context.restore(), 
            graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
        } else {
            context.beginPath();
            const b = graphic.AABBBounds;
            context.rect(x, y, b.width(), b.height()), context.fillStyle = background, context.globalAlpha = 1, 
            context.fill();
        }
    }
};

DefaultImageBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultImageBackgroundRenderContribution), 
exports.DefaultImageBackgroundRenderContribution = DefaultImageBackgroundRenderContribution;
//# sourceMappingURL=image-contribution-render.js.map

}, function(modId) { var map = {"../../../../graphic":1689069767757,"./base-contribution-render":1689069767756,"../../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767836, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DrawContribution = exports.RenderSelector = exports.ImageRender = exports.GlyphRender = exports.Pyramid3dRender = exports.RichTextRender = exports.TextRender = exports.SymbolRender = exports.Rect3DRender = exports.RectRender = exports.PolygonRender = exports.PathRender = exports.LineRender = exports.GroupRender = exports.GraphicRender = exports.CircleRender = exports.AreaRender = exports.Arc3dRender = exports.ArcRender = exports.IncrementalDrawContribution = void 0, 
exports.IncrementalDrawContribution = Symbol.for("IncrementalDrawContribution"), 
exports.ArcRender = Symbol.for("ArcRender"), exports.Arc3dRender = Symbol.for("Arc3dRender"), 
exports.AreaRender = Symbol.for("AreaRender"), exports.CircleRender = Symbol.for("CircleRender"), 
exports.GraphicRender = Symbol.for("GraphicRender"), exports.GroupRender = Symbol.for("GroupRender"), 
exports.LineRender = Symbol.for("LineRender"), exports.PathRender = Symbol.for("PathRender"), 
exports.PolygonRender = Symbol.for("PolygonRender"), exports.RectRender = Symbol.for("RectRender"), 
exports.Rect3DRender = Symbol.for("Rect3DRender"), exports.SymbolRender = Symbol.for("SymbolRender"), 
exports.TextRender = Symbol.for("TextRender"), exports.RichTextRender = Symbol.for("RichTextRender"), 
exports.Pyramid3dRender = Symbol.for("Pyramid3dRender"), exports.GlyphRender = Symbol.for("GlyphRender"), 
exports.ImageRender = Symbol.for("ImageRender"), exports.RenderSelector = Symbol.for("RenderSelector"), 
exports.DrawContribution = Symbol.for("DrawContribution");
//# sourceMappingURL=symbol.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767837, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./arc-contribution-render"), exports), __exportStar(require("./base-contribution-render"), exports), 
__exportStar(require("./circle-contribution-render"), exports), __exportStar(require("./group-contribution-render"), exports), 
__exportStar(require("./image-contribution-render"), exports), __exportStar(require("./rect-contribution-render"), exports), 
__exportStar(require("./symbol-contribution-render"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./arc-contribution-render":1689069767754,"./base-contribution-render":1689069767756,"./circle-contribution-render":1689069767815,"./group-contribution-render":1689069767838,"./image-contribution-render":1689069767835,"./rect-contribution-render":1689069767826,"./symbol-contribution-render":1689069767828}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767838, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultGroupBackgroundRenderContribution = exports.GroupRenderContribution = void 0;

const inversify_1 = require("inversify"), base_contribution_render_1 = require("./base-contribution-render"), enums_1 = require("../../../../common/enums");

exports.GroupRenderContribution = Symbol.for("GroupRenderContribution");

let DefaultGroupBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb) {
        const {background: background} = graphic.attribute;
        if (background) if (graphic.backgroundImg && graphic.resources) {
            const res = graphic.resources.get(background);
            if ("success" !== res.state || !res.data) return;
            context.highPerformanceSave(), context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0);
            const b = graphic.AABBBounds;
            context.drawImage(res.data, b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore(), 
            context.setTransformForCurrent();
        } else context.highPerformanceSave(), context.fillStyle = background, context.fill(), 
        context.highPerformanceRestore();
    }
};

DefaultGroupBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultGroupBackgroundRenderContribution), 
exports.DefaultGroupBackgroundRenderContribution = DefaultGroupBackgroundRenderContribution;
//# sourceMappingURL=group-contribution-render.js.map

}, function(modId) { var map = {"./base-contribution-render":1689069767756,"../../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767839, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), picker_service_1 = require("./picker-service"), global_picker_service_1 = require("./global-picker-service"), canvas_picker_service_1 = require("./canvas-picker-service"), math_picker_service_1 = require("./math-picker-service"), pick_interceptor_1 = require("./pick-interceptor"), contribution_provider_1 = require("../common/contribution-provider");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(canvas_picker_service_1.DefaultCanvasPickerService).toSelf().inSingletonScope(), 
    bind(math_picker_service_1.DefaultMathPickerService).toSelf().inSingletonScope(), 
    bind(picker_service_1.PickerService).toService(canvas_picker_service_1.DefaultCanvasPickerService), 
    bind(global_picker_service_1.DefaultGlobalPickerService).toSelf().inSingletonScope(), 
    bind(global_picker_service_1.GlobalPickerService).toService(global_picker_service_1.DefaultGlobalPickerService), 
    bind(pick_interceptor_1.Canvas3DPickItemInterceptor).toSelf().inSingletonScope(), 
    bind(pick_interceptor_1.PickItemInterceptor).toService(pick_interceptor_1.Canvas3DPickItemInterceptor), 
    (0, contribution_provider_1.bindContributionProvider)(bind, pick_interceptor_1.PickItemInterceptor);
}));
//# sourceMappingURL=pick-modules.js.map

}, function(modId) { var map = {"./picker-service":1689069767840,"./global-picker-service":1689069767843,"./canvas-picker-service":1689069767844,"./math-picker-service":1689069767851,"./pick-interceptor":1689069767842,"../common/contribution-provider":1689069767672}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767840, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultPickService = exports.PickerService = exports.GraphicPicker = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), sort_1 = require("../common/sort"), contribution_provider_1 = require("../common/contribution-provider"), graphic_1 = require("../graphic"), matrix_allocate_1 = require("../allocator/matrix-allocate"), pick_interceptor_1 = require("./pick-interceptor"), constants_1 = require("../constants");

exports.GraphicPicker = Symbol.for("GraphicPicker"), exports.PickerService = Symbol.for("PickerService");

let DefaultPickService = class {
    constructor(global, pickItemInterceptorContributions) {
        this.global = global, this.pickItemInterceptorContributions = pickItemInterceptorContributions, 
        this.type = "default";
    }
    _init() {
        this.InterceptorContributions = this.pickItemInterceptorContributions.getContributions().sort(((a, b) => a.order - b.order));
    }
    pick(graphics, point, params) {
        let result = {
            graphic: null,
            group: null
        };
        params.pickerService = this;
        let offsetX = 0, offsetY = 0;
        if (params && params.bounds) {
            if (!params.bounds.contains(point.x, point.y)) return result;
            offsetX = params.bounds.x1, offsetY = params.bounds.y1;
        }
        this.pickContext && (this.pickContext.inuse = !0), params.pickContext = this.pickContext, 
        this.pickContext && this.pickContext.clearMatrix(!0, 1);
        const parentMatrix = new vutils_1.Matrix(1, 0, 0, 1, offsetX, offsetY);
        let group;
        for (let i = graphics.length - 1; i >= 0 && (graphics[i].isContainer ? result = this.pickGroup(graphics[i], point, parentMatrix, params) : result.graphic = this.pickItem(graphics[i], point, params), 
        !result.graphic); i--) group || (group = result.group);
        return result.graphic || (result.group = group), this.pickContext && (this.pickContext.inuse = !1), 
        result;
    }
    containsPoint(graphic, point, params) {
        return !!this.pickItem(graphic, point, params);
    }
    pickGroup(group, point, parentMatrix, params) {
        let result = {
            group: null,
            graphic: null
        };
        if (!1 === group.attribute.visibleAll) return result;
        const context = params.pickContext, lastMatrix = context.modelMatrix;
        if (context.camera) {
            const m = group.transMatrix, matrix = matrix_allocate_1.mat4Allocate.allocate();
            if ((0, graphic_1.mat3Tomat4)(matrix, m), lastMatrix) {
                if (matrix) {
                    const m = matrix_allocate_1.mat4Allocate.allocate();
                    context.modelMatrix = (0, graphic_1.multiplyMat4Mat4)(m, lastMatrix, matrix), matrix_allocate_1.mat4Allocate.free(matrix);
                }
            } else (0, graphic_1.mat3Tomat4)(matrix, group.globalTransMatrix), context.modelMatrix = matrix;
        }
        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
            const drawContribution = this.InterceptorContributions[i];
            if (drawContribution.beforePickItem) {
                const result = drawContribution.beforePickItem(group, this, point, params, {
                    parentMatrix: parentMatrix
                });
                if (result) return context.modelMatrix !== lastMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), 
                context.modelMatrix = lastMatrix, result;
            }
        }
        const transMatrix = group.transMatrix, currentGroupMatrix = matrix_allocate_1.matrixAllocate.allocateByObj(parentMatrix), newPoint = new vutils_1.Point(point.x, point.y);
        currentGroupMatrix.transformPoint(newPoint, newPoint);
        const insideGroup = group.AABBBounds.containsPoint(newPoint);
        if (!insideGroup && !group.stage.camera) return result;
        const groupPicked = !1 !== group.attribute.pickable && insideGroup;
        return currentGroupMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), 
        !1 !== group.attribute.childrenPickable && (0, sort_1.foreach)(group, graphic_1.DefaultAttribute.zIndex, (graphic => {
            if (graphic.isContainer) {
                const newPoint = new vutils_1.Point(point.x, point.y), theme = (0, graphic_1.getTheme)(group).group, {scrollX: scrollX = theme.scrollX, scrollY: scrollY = theme.scrollY} = group.attribute;
                newPoint.x -= scrollX, newPoint.y -= scrollY, result = this.pickGroup(graphic, newPoint, currentGroupMatrix, params);
            } else {
                const newPoint = new vutils_1.Point(point.x, point.y);
                currentGroupMatrix.transformPoint(newPoint, newPoint);
                const theme = (0, graphic_1.getTheme)(group).group, {scrollX: scrollX = theme.scrollX, scrollY: scrollY = theme.scrollY} = group.attribute;
                newPoint.x -= scrollX, newPoint.y -= scrollY;
                const pickedItem = this.pickItem(graphic, newPoint, params);
                result.graphic = pickedItem;
            }
            return !!result.graphic || !!result.group;
        }), !0, !!context.camera), context.modelMatrix !== lastMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), 
        context.modelMatrix = lastMatrix, result.graphic || result.group || !groupPicked || group.stage.camera || (result.group = group), 
        matrix_allocate_1.matrixAllocate.free(currentGroupMatrix), result;
    }
    selectPicker(graphic) {
        const picker = this.pickerMap.get(graphic.numberType);
        return picker || null;
    }
};

DefaultPickService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(constants_1.Global)), __param(1, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(1, (0, 
inversify_1.named)(pick_interceptor_1.PickItemInterceptor)), __metadata("design:paramtypes", [ Object, Object ]) ], DefaultPickService), 
exports.DefaultPickService = DefaultPickService;
//# sourceMappingURL=picker-service.js.map

}, function(modId) { var map = {"../common/sort":1689069767841,"../common/contribution-provider":1689069767672,"../graphic":1689069767757,"../allocator/matrix-allocate":1689069767808,"./pick-interceptor":1689069767842,"../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767841, function(require, module, exports) {


var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

function foreach(graphic, defaultZIndex, cb, reverse = !1, sort3d = !1) {
    const childMap = {}, zIdxArray = [];
    let needSort = !1;
    if (sort3d) needSort = !0; else {
        let lastZIndex;
        graphic.forEachChildren(((item, i) => {
            const {zIndex: zIndex = defaultZIndex} = item.attribute;
            if (0 === i) lastZIndex = zIndex; else if (lastZIndex !== zIndex) return needSort = !0, 
            !0;
            return !1;
        }), reverse);
    }
    if (needSort) {
        graphic.forEachChildren((item => {
            const {zIndex: zIndex = defaultZIndex} = item.attribute;
            childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [ item ], zIdxArray.push(zIndex));
        }), reverse), zIdxArray.sort(((a, b) => reverse ? b - a : a - b));
        let skip = !1;
        for (let i = 0; i < zIdxArray.length && !skip; i++) {
            const idx = zIdxArray[i], children = childMap[idx];
            sort3d && children.sort(((a, b) => {
                var _a, _b;
                return (reverse ? -1 : 1) * ((null !== (_a = b.attribute.z) && void 0 !== _a ? _a : 0) - (null !== (_b = a.attribute.z) && void 0 !== _b ? _b : 0));
            }));
            for (let i = 0; i < children.length; i++) if (cb(children[i], i)) {
                skip = !0;
                break;
            }
        }
    } else graphic.forEachChildren(cb, reverse);
}

function foreachAsync(graphic, defaultZIndex, cb, reverse = !1) {
    return __awaiter(this, void 0, void 0, (function*() {
        yield graphic.forEachChildrenAsync(cb, reverse);
    }));
}

function findNextGraphic(graphic, id, defaultZIndex, reverse = !1) {
    const childMap = {}, zIdxArray = [];
    let needSort = !1;
    graphic.forEachChildren(((item, i) => {
        const {zIndex: zIndex = defaultZIndex} = item.attribute;
        if (0 === i) ; else if (undefined !== zIndex) return needSort = !0, !0;
        return !1;
    }), reverse);
    let result = null, next = !1;
    if (needSort) {
        graphic.forEachChildren((item => {
            const {zIndex: zIndex = defaultZIndex} = item.attribute;
            childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [ item ], zIdxArray.push(zIndex));
        }), reverse), zIdxArray.sort(((a, b) => reverse ? b - a : a - b));
        let skip = !1;
        for (let i = 0; i < zIdxArray.length && !skip; i++) {
            const idx = zIdxArray[i], children = childMap[idx];
            for (let i = 0; i < children.length; i++) {
                if (next) {
                    skip = !0, result = children[i];
                    break;
                }
                children[i]._uid !== id || (next = !0);
            }
        }
    } else graphic.forEachChildren((item => next ? (result = item, !0) : (item._uid === id && (next = !0), 
    !1)), reverse);
    return result;
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.findNextGraphic = exports.foreachAsync = exports.foreach = void 0, exports.foreach = foreach, 
exports.foreachAsync = foreachAsync, exports.findNextGraphic = findNextGraphic;
//# sourceMappingURL=sort.js.map
}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767842, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Canvas3DPickItemInterceptor = exports.PickItemInterceptor = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), constants_1 = require("../graphic/constants");

exports.PickItemInterceptor = Symbol.for("PickItemInterceptor");

let Canvas3DPickItemInterceptor = class {
    constructor() {
        this.order = 1;
    }
    beforePickItem(graphic, pickerService, point, pickParams, params) {
        if (!graphic.in3dMode || pickParams.in3dInterceptor) return null;
        const context = pickerService.pickContext, stage = graphic.stage;
        if (!context || !stage) return null;
        if (pickParams.in3dInterceptor = !0, context.save(), this.initCanvasCtx(context), 
        context.camera = stage.camera, graphic.isContainer) {
            let result, isPie = !1, is3d = !1;
            if (graphic.forEachChildren((c => (isPie = c.numberType === constants_1.ARC3D_NUMBER_TYPE, 
            !isPie))), graphic.forEachChildren((c => (is3d = !!c.findFace, !is3d))), isPie) {
                const children = graphic.getChildren(), sortedChildren = [ ...children ];
                sortedChildren.sort(((a, b) => {
                    var _a, _b, _c, _d;
                    let angle1 = (null !== (_b = null !== (_a = a.attribute.startAngle) && void 0 !== _a ? _a : 0 + a.attribute.endAngle) && void 0 !== _b ? _b : 0) / 2, angle2 = (null !== (_d = null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0 + b.attribute.endAngle) && void 0 !== _d ? _d : 0) / 2;
                    for (;angle1 < 0; ) angle1 += vutils_1.pi2;
                    for (;angle2 < 0; ) angle2 += vutils_1.pi2;
                    return angle2 - angle1;
                })), sortedChildren.forEach((c => {
                    c._next = null, c._prev = null;
                })), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c => {
                    graphic.appendChild(c);
                })), pickParams.hack_pieFace = "outside", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams), 
                result.graphic || (pickParams.hack_pieFace = "inside", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams)), 
                result.graphic || (pickParams.hack_pieFace = "top", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams)), 
                graphic.removeAllChild(), children.forEach((c => {
                    c._next = null, c._prev = null;
                })), children.forEach((c => {
                    graphic.appendChild(c);
                }));
            } else if (is3d) {
                const children = graphic.getChildren(), zChildren = children.map((g => ({
                    ave_z: g.findFace().vertices.map((v => {
                        var _a;
                        return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
                    })).reduce(((a, b) => a + b), 0),
                    g: g
                })));
                zChildren.sort(((a, b) => b.ave_z - a.ave_z)), graphic.removeAllChild(), zChildren.forEach((i => {
                    i.g._next = null, i.g._prev = null;
                })), graphic.update(), zChildren.forEach((i => {
                    graphic.add(i.g);
                })), result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams), 
                graphic.removeAllChild(), children.forEach((g => {
                    g._next = null, g._prev = null;
                })), graphic.update(), children.forEach((g => {
                    graphic.add(g);
                }));
            } else result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams);
            return context.camera = null, context.restore(), pickParams.in3dInterceptor = !1, 
            result;
        }
        return null;
    }
    initCanvasCtx(context) {
        context.setTransformForCurrent();
    }
};

Canvas3DPickItemInterceptor = __decorate([ (0, inversify_1.injectable)() ], Canvas3DPickItemInterceptor), 
exports.Canvas3DPickItemInterceptor = Canvas3DPickItemInterceptor;
//# sourceMappingURL=pick-interceptor.js.map

}, function(modId) { var map = {"../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767843, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultGlobalPickerService = exports.GlobalPickerService = exports.BoundsPicker = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), constants_1 = require("../constants");

exports.BoundsPicker = Symbol.for("BoundsPicker"), exports.GlobalPickerService = Symbol.for("GlobalPickerService");

let DefaultGlobalPickerService = class {
    constructor(global) {
        this.global = global, this.global.hooks.onSetEnv.tap("global-picker-service", ((lastEnv, env, global) => {
            this.configure(global, env);
        })), this.configure(this.global, this.global.env);
    }
    configure(global, env) {}
    pick(graphics, point, params) {
        let result = {
            graphic: null,
            group: null
        };
        const parentMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0);
        let group;
        for (let i = 0; i < graphics.length && (graphics[i].isContainer ? result = this.pickGroup(graphics[i], point, parentMatrix, params) : result.graphic = this.pickItem(graphics[i], point, params), 
        !result.graphic); i++) group || (group = result.group);
        return result.graphic || (result.group = group), result;
    }
    containsPoint(graphic, point, params) {
        return !!this.pickItem(graphic, point, params);
    }
    pickGroup(group, point, parentMatrix, params) {
        let result = {
            group: null,
            graphic: null
        };
        if (!1 === group.attribute.visibleAll) return result;
        const transMatrix = group.transMatrix, newPoint = new vutils_1.Point(point.x, point.y);
        parentMatrix.transformPoint(newPoint, newPoint);
        const insideGroup = group.AABBBounds.containsPoint(newPoint);
        if (!insideGroup) return result;
        const groupPicked = !1 !== group.attribute.pickable && insideGroup;
        return parentMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), 
        !1 !== group.attribute.childrenPickable && group.forEachChildren((graphic => {
            if (graphic.isContainer) result = this.pickGroup(graphic, point, parentMatrix, params); else {
                const newPoint = new vutils_1.Point(point.x, point.y);
                parentMatrix.transformPoint(newPoint, newPoint), result.graphic = this.pickItem(graphic, newPoint, params);
            }
            return !!result.graphic || !!result.group;
        })), result.graphic || result.group || !groupPicked || (result.group = group), result;
    }
    pickItem(graphic, point, params) {
        return !1 === graphic.attribute.pickable ? null : graphic.AABBBounds.containsPoint(point) ? graphic : null;
    }
};

DefaultGlobalPickerService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(constants_1.Global)), __metadata("design:paramtypes", [ Object ]) ], DefaultGlobalPickerService), 
exports.DefaultGlobalPickerService = DefaultGlobalPickerService;
//# sourceMappingURL=global-picker-service.js.map

}, function(modId) { var map = {"../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767844, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasPickerService = void 0;

const contribution_provider_1 = require("../common/contribution-provider"), inversify_1 = require("inversify"), browser_1 = require("../canvas/contributions/browser"), constants_1 = require("./contributions/constants"), picker_service_1 = require("./picker-service"), render_1 = require("../render"), pick_interceptor_1 = require("./pick-interceptor"), constants_2 = require("../constants");

let DefaultCanvasPickerService = class extends picker_service_1.DefaultPickService {
    constructor(contributions, circlePicker, rectPicker, arcPicker, areaPicker, imagePicker, linePicker, pathPicker, symbolPicker, textPicker, polygonPicker, richtextPicker, drawContribution, global, pickItemInterceptorContributions) {
        super(global, pickItemInterceptorContributions), this.contributions = contributions, 
        this.circlePicker = circlePicker, this.rectPicker = rectPicker, this.arcPicker = arcPicker, 
        this.areaPicker = areaPicker, this.imagePicker = imagePicker, this.linePicker = linePicker, 
        this.pathPicker = pathPicker, this.symbolPicker = symbolPicker, this.textPicker = textPicker, 
        this.polygonPicker = polygonPicker, this.richtextPicker = richtextPicker, this.drawContribution = drawContribution, 
        this.global = global, this.pickItemInterceptorContributions = pickItemInterceptorContributions, 
        this.global.hooks.onSetEnv.tap("canvas-picker-service", ((_, env, global) => {
            this.configure(global, env);
        })), this.configure(this.global, this.global.env), this.pickerMap = new Map;
    }
    init() {
        this.contributions.getContributions().forEach((item => {
            this.pickerMap.set(item.numberType, item);
        })), super._init();
    }
    configure(global, env) {
        const options = {
            width: 100,
            height: 100,
            nativeCanvas: global.createCanvas({
                width: 100,
                height: 100
            }),
            id: "for-pick"
        };
        this.pickCanvas = new browser_1.BrowserCanvas(options), this.pickContext = this.pickCanvas.getContext("2d");
    }
    pickItem(graphic, point, params) {
        if (!1 === graphic.attribute.pickable) return null;
        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
            const drawContribution = this.InterceptorContributions[i];
            if (drawContribution.beforePickItem && drawContribution.beforePickItem(graphic, this, point, params)) return graphic;
        }
        const picker = this.pickerMap.get(graphic.numberType);
        return picker && picker.contains(graphic, point, params) ? graphic : null;
    }
};

__decorate([ (0, inversify_1.postConstruct)(), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0) ], DefaultCanvasPickerService.prototype, "init", null), 
DefaultCanvasPickerService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(constants_1.CanvasPickerContribution)), __param(1, (0, inversify_1.inject)(constants_1.CanvasCirclePicker)), __param(2, (0, 
inversify_1.inject)(constants_1.CanvasRectPicker)), __param(3, (0, inversify_1.inject)(constants_1.CanvasArcPicker)), __param(4, (0, 
inversify_1.inject)(constants_1.CanvasAreaPicker)), __param(5, (0, inversify_1.inject)(constants_1.CanvasImagePicker)), __param(6, (0, 
inversify_1.inject)(constants_1.CanvasLinePicker)), __param(7, (0, inversify_1.inject)(constants_1.CanvasPathPicker)), __param(8, (0, 
inversify_1.inject)(constants_1.CanvasSymbolPicker)), __param(9, (0, inversify_1.inject)(constants_1.CanvasTextPicker)), __param(10, (0, 
inversify_1.inject)(constants_1.CanvasPolygonPicker)), __param(11, (0, inversify_1.inject)(constants_1.CanvasRichTextPicker)), __param(12, (0, 
inversify_1.inject)(render_1.DrawContribution)), __param(13, (0, inversify_1.inject)(constants_2.Global)), __param(14, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(14, (0, 
inversify_1.named)(pick_interceptor_1.PickItemInterceptor)), __metadata("design:paramtypes", [ Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object ]) ], DefaultCanvasPickerService), 
exports.DefaultCanvasPickerService = DefaultCanvasPickerService;
//# sourceMappingURL=canvas-picker-service.js.map

}, function(modId) { var map = {"../common/contribution-provider":1689069767672,"../canvas/contributions/browser":1689069767845,"./contributions/constants":1689069767849,"./picker-service":1689069767840,"../render":1689069767850,"./pick-interceptor":1689069767842,"../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767845, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./canvas"), exports), __exportStar(require("./context"), exports), 
__exportStar(require("./conical-gradient"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./canvas":1689069767846,"./context":1689069767847,"./conical-gradient":1689069767753}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767846, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BrowserCanvas = void 0;

const inversify_1 = require("inversify"), application_1 = require("../../../application"), context_1 = require("./context"), DefaultConfig = {
    WIDTH: 500,
    HEIGHT: 500,
    DPR: 1
};

let BrowserCanvas = class {
    get displayWidth() {
        return this._pixelWidth / this._dpr;
    }
    get displayHeight() {
        return this._pixelHeight / this._dpr;
    }
    get id() {
        return this._id;
    }
    get x() {
        return this._x;
    }
    get y() {
        return this._y;
    }
    get nativeCanvas() {
        return this._nativeCanvas;
    }
    get width() {
        return this._pixelWidth;
    }
    set width(width) {
        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
    }
    get height() {
        return this._pixelHeight;
    }
    set height(height) {
        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
    }
    getContext(str) {
        return this._context;
    }
    get visiable() {
        return this._visiable;
    }
    set visiable(visiable) {
        this._visiable = visiable, visiable ? this.show() : this.hide();
    }
    get dpr() {
        return this._dpr;
    }
    set dpr(dpr) {
        this._dpr = dpr, this.resize(this.width, this.height);
    }
    constructor(params) {
        const {nativeCanvas: nativeCanvas, width: width = DefaultConfig.WIDTH, height: height = DefaultConfig.HEIGHT, dpr: dpr = DefaultConfig.DPR, container: container, x: x, y: y, canvasControled: canvasControled = !0} = params;
        if (this._x = null != x ? x : 0, this._y = null != y ? y : 0, this._pixelWidth = width * dpr, 
        this._pixelHeight = height * dpr, this._visiable = !1 !== params.visiable, this.controled = canvasControled, 
        "string" == typeof container) {
            const _c = application_1.application.global.getElementById(container);
            _c && (this._container = _c);
        } else this._container = container;
        this._displayWidth = width, this._displayHeight = height, this._dpr = dpr, this._nativeCanvas = nativeCanvas, 
        this._context = new context_1.BrowserContext2d(this, this._dpr), this._id = nativeCanvas.id, 
        this.initStyle();
    }
    initStyle() {
        if (!this.controled) return;
        const {nativeCanvas: nativeCanvas} = this;
        nativeCanvas.width = this._pixelWidth, nativeCanvas.height = this._pixelHeight;
        !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, this._x, this._y, this._displayWidth, this._displayHeight), 
        null != this.id && (nativeCanvas.id = this.id.toString()), this._container && this._container.appendChild(nativeCanvas), 
        this.visiable || this.hide();
    }
    applyPosition() {
        const canvas = this._nativeCanvas;
        canvas.style.position = "absolute", canvas.style.top = `${this._y}px`, canvas.style.left = `${this._x}px`;
    }
    getNativeCanvas() {
        return this._nativeCanvas;
    }
    resetStyle(params) {
        if (!this.controled) return;
        const {width: width = this._displayWidth, height: height = this._displayHeight, dpr: dpr = this._dpr, x: x = this._x, y: y = this._y} = params, {nativeCanvas: nativeCanvas} = this;
        nativeCanvas.width = width * dpr, nativeCanvas.height = height * dpr;
        !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, x, y, width, height), params.id && (nativeCanvas.id = params.id), 
        this.visiable || this.hide();
    }
    setCanvasStyle(canvas, x, y, w, h) {
        this.controled && (canvas.style.padding = "0", canvas.style.margin = "0", canvas.style.border = "0", 
        canvas.style.background = "transparent", canvas.style.width = `${w}px`, canvas.style.height = `${h}px`);
    }
    hide() {
        this._nativeCanvas && (this._nativeCanvas.style.display = "none");
    }
    show() {
        this._nativeCanvas && (this._nativeCanvas.style.display = "block");
    }
    resize(width, height) {
        if (!this.controled) return;
        this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, 
        this._displayHeight = height, this._nativeCanvas.style && (this._nativeCanvas.style.width = `${width}px`, 
        this._nativeCanvas.style.height = `${height}px`), this._nativeCanvas.width = this._pixelWidth, 
        this._nativeCanvas.height = this._pixelHeight;
        this._context.dpr = this._dpr;
    }
    toDataURL(mimeType, quality) {
        return "image/jpeg" === mimeType ? this._nativeCanvas.toDataURL(mimeType, quality) : "image/png" === mimeType ? this._nativeCanvas.toDataURL(mimeType) : this._nativeCanvas.toDataURL(mimeType, quality);
    }
    readPixels(x, y, w, h) {
        return this._context.getImageData(x, y, w, h);
    }
    convertToBlob(options) {
        throw new Error("暂未实现");
    }
    transferToImageBitmap() {
        throw new Error("暂未实现");
    }
    release(...params) {
        this.controled && this._nativeCanvas.parentElement && this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
    }
};

BrowserCanvas.env = "browser", BrowserCanvas = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", [ Object ]) ], BrowserCanvas), 
exports.BrowserCanvas = BrowserCanvas;
//# sourceMappingURL=canvas.js.map

}, function(modId) { var map = {"../../../application":1689069767703,"./context":1689069767847}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767847, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BrowserContext2d = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), graphic_1 = require("../../../graphic"), canvas_utils_1 = require("../../../common/canvas-utils"), application_1 = require("../../../application"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), conical_gradient_1 = require("./conical-gradient"), camera_1 = require("../../../core/camera"), text_1 = require("../../../common/text"), outP = [ 0, 0, 0 ], initMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, clockwise) => {
    if (clockwise) for (;endAngle > startAngle; ) endAngle -= vutils_1.pi2; else for (;endAngle < startAngle; ) endAngle += vutils_1.pi2;
    const step = vutils_1.pi / 3 * (endAngle > startAngle ? 1 : -1);
    let sa = startAngle, ea = sa;
    for (;ea !== endAngle; ) {
        ea = step > 0 ? Math.min(ea + step, endAngle) : Math.max(ea + step, endAngle);
        const delta = Math.abs(ea - sa), len = 4 * Math.tan(delta / 4) / 3, dir = ea < sa ? -1 : 1, c1 = Math.cos(sa), s1 = Math.sin(sa), c2 = Math.cos(ea), s2 = Math.sin(ea), x1 = c1 * rx + cx, y1 = s1 * ry + cy, x4 = c2 * rx + cx, y4 = s2 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;
        bezierPath.push([ x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4 ]), 
        sa = ea;
    }
};

let BrowserContext2d = class {
    set fillStyle(d) {
        this.nativeContext.fillStyle = d;
    }
    get fillStyle() {
        return this.nativeContext.fillStyle;
    }
    set font(d) {
        this.nativeContext.font = d;
    }
    get font() {
        return this.nativeContext.font;
    }
    set globalAlpha(d) {
        this.nativeContext.globalAlpha = d;
    }
    get globalAlpha() {
        return this.nativeContext.globalAlpha;
    }
    set lineCap(d) {
        this.nativeContext.lineCap = d;
    }
    get lineCap() {
        return this.nativeContext.lineCap;
    }
    set lineDashOffset(d) {
        this.nativeContext.lineDashOffset = d;
    }
    get lineDashOffset() {
        return this.nativeContext.lineDashOffset;
    }
    set lineJoin(d) {
        this.nativeContext.lineJoin = d;
    }
    get lineJoin() {
        return this.nativeContext.lineJoin;
    }
    set lineWidth(d) {
        this.nativeContext.lineWidth = d;
    }
    get lineWidth() {
        return this.nativeContext.lineWidth;
    }
    set miterLimit(d) {
        this.nativeContext.miterLimit = d;
    }
    get miterLimit() {
        return this.nativeContext.miterLimit;
    }
    set shadowBlur(d) {
        this.nativeContext.shadowBlur = d;
    }
    get shadowBlur() {
        return this.nativeContext.shadowBlur;
    }
    set shadowColor(d) {
        this.nativeContext.shadowColor = d;
    }
    get shadowColor() {
        return this.nativeContext.shadowColor;
    }
    set shadowOffsetX(d) {
        this.nativeContext.shadowOffsetX = d;
    }
    get shadowOffsetX() {
        return this.nativeContext.shadowOffsetX;
    }
    set shadowOffsetY(d) {
        this.nativeContext.shadowOffsetY = d;
    }
    get shadowOffsetY() {
        return this.nativeContext.shadowOffsetY;
    }
    set strokeStyle(d) {
        this.nativeContext.strokeStyle = d;
    }
    get strokeStyle() {
        return this.nativeContext.strokeStyle;
    }
    set textAlign(d) {
        this.nativeContext.textAlign = d;
    }
    get textAlign() {
        return this.nativeContext.textAlign;
    }
    set textBaseline(d) {
        this.nativeContext.textBaseline = d;
    }
    get textBaseline() {
        return this.nativeContext.textBaseline;
    }
    get inuse() {
        return !!this._inuse;
    }
    set inuse(use) {
        use !== !!this._inuse && (this._inuse = use, use ? (this.nativeContext.save(), this.reset()) : this.nativeContext.restore());
    }
    constructor(canvas, dpr) {
        this.fillAttributes = Object.assign(Object.assign({}, graphic_1.DefaultFillStyle), {
            opacity: 1
        }), this.strokeAttributes = Object.assign(Object.assign({}, graphic_1.DefaultStrokeStyle), {
            opacity: 1
        }), this.textAttributes = Object.assign(Object.assign({}, graphic_1.DefaultTextStyle), {
            opacity: 1
        }), this._clearShadowStyle = !1, this._clearFilterStyle = !1;
        const context = canvas.nativeCanvas.getContext("2d");
        if (!context) throw new Error("发生错误，获取2d上下文失败");
        this.nativeContext = context, this.canvas = canvas, this.matrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), 
        this.stack = [], this.dpr = dpr, this.applyedMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0);
    }
    reset() {
        this.stack.length && console.warn("可能存在bug，matrix没有清空"), this.matrix.setValue(1, 0, 0, 1, 0, 0), 
        this.applyedMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), this.stack.length = 0, 
        this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);
    }
    getCanvas() {
        return this.canvas;
    }
    getContext() {
        return this.nativeContext;
    }
    setTransformForCurrent(force = !1) {
        !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix.setValue(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f), 
        this.nativeContext.setTransform(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f));
    }
    get currentMatrix() {
        return this.matrix;
    }
    cloneMatrix(m) {
        return matrix_allocate_1.matrixAllocate.allocateByObj(m);
    }
    clear() {
        this.save(), this.resetTransform(), this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height), 
        this.restore();
    }
    restore() {
        this.nativeContext.restore(), this.stack.length > 0 && (matrix_allocate_1.matrixAllocate.free(this.matrix), 
        this.matrix = this.stack.pop(), this.setTransformForCurrent(!0));
    }
    highPerformanceRestore() {
        this.stack.length > 0 && (matrix_allocate_1.matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
    }
    rotate(rad, setTransform = !0) {
        this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
    }
    save() {
        const matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix), this.nativeContext.save();
    }
    highPerformanceSave() {
        const matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix);
    }
    scale(sx, sy, setTransform = !0) {
        this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
    }
    setScale(sx, sy, setTransform = !0) {
        this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
    }
    scalePoint(sx, sy, px, py, setTransform = !0) {
        this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), 
        setTransform && this.setTransformForCurrent();
    }
    setTransform(a, b, c, d, e, f, setTransform = !0, dpr = this.dpr) {
        this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
    }
    setTransformFromMatrix(matrix, setTransform = !0, dpr = this.dpr) {
        this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), 
        setTransform && this.setTransformForCurrent();
    }
    resetTransform(setTransform = !0, dpr = this.dpr) {
        this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
    }
    transform(a, b, c, d, e, f, setTransform = !0) {
        this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();
    }
    transformFromMatrix(matrix, setTransform) {
        this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), 
        setTransform && this.setTransformForCurrent();
    }
    translate(x, y, setTransform = !0) {
        this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
    }
    rotateDegrees(deg, setTransform = !0) {
        const rad = deg * Math.PI / 180;
        this.rotate(rad, setTransform);
    }
    rotateAbout(rad, x, y, setTransform = !0) {
        this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
    }
    rotateDegreesAbout(deg, x, y, setTransform = !0) {
        this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), 
        setTransform && this.setTransformForCurrent();
    }
    beginPath() {
        this.disableBeginPath || this.nativeContext.beginPath();
    }
    clip(path, fillRule) {
        path ? "string" == typeof path ? this.nativeContext.clip(path) : this.nativeContext.clip(path, fillRule) : this.nativeContext.clip();
    }
    arc(x, y, radius, startAngle, endAngle, anticlockwise, z) {
        if (z = z || 0, this.camera) {
            const arr = [];
            addArcToBezierPath(arr, startAngle, endAngle, x, y, radius, radius, anticlockwise);
            for (let i = 0; i < arr.length; ++i) {
                const bez = arr[i];
                this.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], z);
            }
        } else this.nativeContext.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    arcTo(x1, y1, x2, y2, radiusX) {
        this.nativeContext.arcTo(x1, y1, x2, y2, radiusX);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, z) {
        if (z = z || 0, this.camera) {
            let cp1z = z, cp2z = z;
            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ cp1x, cp1y, z ], this.modelMatrix), 
            cp1x = outP[0], cp1y = outP[1], cp1z = outP[2], (0, camera_1.transformMat4)(outP, [ cp2x, cp2y, z ], this.modelMatrix), 
            cp2x = outP[0], cp2y = outP[1], cp2z = outP[2], (0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), 
            x = outP[0], y = outP[1], z = outP[2]);
            let data = this.camera.vp(x, y, z);
            x = data.x, y = data.y, data = this.camera.vp(cp1x, cp1y, cp1z), cp1x = data.x, 
            cp1y = data.y, data = this.camera.vp(cp2x, cp2y, cp2z), cp2x = data.x, cp2y = data.y;
        }
        this.nativeContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    closePath() {
        this.nativeContext.closePath();
    }
    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        null == anticlockwise ? this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle) : this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
    }
    lineTo(x, y, z) {
        if (z = z || 0, this.camera) {
            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), 
            x = outP[0], y = outP[1], z = outP[2]);
            const data = this.camera.vp(x, y, z);
            x = data.x, y = data.y;
        }
        this.nativeContext.lineTo(x, y);
    }
    moveTo(x, y, z) {
        if (z = z || 0, this.camera) {
            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), 
            x = outP[0], y = outP[1], z = outP[2]);
            const data = this.camera.vp(x, y, z);
            x = data.x, y = data.y;
        }
        this.nativeContext.moveTo(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y, z) {
        if (z = z || 0, this.camera) {
            let cpz = z;
            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ cpx, cpy, z ], this.modelMatrix), 
            cpx = outP[0], cpy = outP[1], cpz = outP[2], (0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), 
            x = outP[0], y = outP[1], z = outP[2]);
            let data = this.camera.vp(x, y, z);
            x = data.x, y = data.y, data = this.camera.vp(cpx, cpy, cpz), cpx = data.x, cpy = data.y;
        }
        this.nativeContext.quadraticCurveTo(cpx, cpy, x, y);
    }
    rect(x, y, w, h, z) {
        z = z || 0, this.camera ? (this.moveTo(x, y, z), this.lineTo(x + w, y, z), this.lineTo(x + w, y + h, z), 
        this.lineTo(x, y + h, z), this.closePath()) : this.nativeContext.rect(x, y, w, h);
    }
    createImageData() {
        const a = arguments;
        return 2 === a.length ? this.nativeContext.createImageData(a[0], a[1]) : 1 === a.length ? this.nativeContext.createImageData(a[0]) : null;
    }
    createLinearGradient(x0, y0, x1, y1) {
        return this.nativeContext.createLinearGradient(x0, y0, x1, y1);
    }
    createPattern(image, repetition) {
        return 0 === image.width || 0 === image.height ? null : this.nativeContext.createPattern(image, repetition);
    }
    createRadialGradient(x0, y0, r0, x1, y1, r1) {
        return this.nativeContext.createRadialGradient(x0, y0, r0, x1, y1, r1);
    }
    createConicGradient(x, y, startAngle, endAngle) {
        let pattern, edit = !1;
        const ctx = this;
        return {
            stops: [],
            addColorStop(offset, color) {
                this.stops.push([ offset, color ]), edit = !0;
            },
            GetPattern(minW, minH, deltaAngle) {
                return edit && (deltaAngle || (deltaAngle = endAngle - startAngle), pattern = (0, 
                conical_gradient_1.createConicalGradient)(ctx, this.stops, x, y, deltaAngle, startAngle, endAngle, minW, minH), 
                edit = !1), pattern;
            }
        };
    }
    fill(path, fillRule) {
        this.disableFill || (path ? this.nativeContext.fill(path) : this.nativeContext.fill());
    }
    fillRect(x, y, width, height) {
        this.nativeContext.fillRect(x, y, width, height);
    }
    clearRect(x, y, w, h) {
        this.nativeContext.clearRect(x, y, w, h);
    }
    project(x, y, z) {
        if (z = z || 0, this.camera) {
            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), 
            x = outP[0], y = outP[1], z = outP[2]);
            const data = this.camera.vp(x, y, z);
            x = data.x, y = data.y;
        }
        return {
            x: x,
            y: y
        };
    }
    view(x, y, z) {
        return z = z || 0, this.camera ? (this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), 
        x = outP[0], y = outP[1], z = outP[2]), this.camera.view(x, y, z)) : [ x, y, z ];
    }
    fillText(text, x, y, z) {
        if (z = z || 0, this.camera) {
            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), 
            x = outP[0], y = outP[1], z = outP[2]);
            const data = this.camera.vp(x, y, z);
            x = data.x, y = data.y;
        }
        this.nativeContext.fillText(text, x, y);
    }
    getImageData(sx, sy, sw, sh) {
        return this.nativeContext.getImageData(sx, sy, sw, sh);
    }
    getLineDash() {
        return this.nativeContext.getLineDash();
    }
    isPointInPath(x, y) {
        return this.nativeContext.isPointInPath(x, y);
    }
    isPointInStroke(x, y) {
        return this.nativeContext.isPointInStroke(x, y);
    }
    measureText(text, method = application_1.application.global.measureTextMethod) {
        var _a, _b;
        return method && "native" !== method ? (this.mathTextMeasure || (this.mathTextMeasure = application_1.application.graphicUtil.createTextMeasureInstance({}, {}, (() => this.canvas))), 
        this.mathTextMeasure.textSpec.fontFamily = null !== (_a = this.fontFamily) && void 0 !== _a ? _a : graphic_1.DefaultTextStyle.fontFamily, 
        this.mathTextMeasure.textSpec.fontSize = null !== (_b = this.fontSize) && void 0 !== _b ? _b : graphic_1.DefaultTextStyle.fontSize, 
        this.mathTextMeasure._numberCharSize = null, this.mathTextMeasure._fullCharSize = null, 
        this.mathTextMeasure._letterCharSize = null, this.mathTextMeasure._specialCharSizeMap = {}, 
        this.mathTextMeasure.measure(text, method)) : this.nativeContext.measureText(text);
    }
    putImageData(imagedata, dx, dy) {
        this.nativeContext.putImageData(imagedata, dx, dy);
    }
    setLineDash(segments) {
        const a = arguments, _context = this.nativeContext;
        this.nativeContext.setLineDash ? _context.setLineDash(a[0]) : "mozDash" in _context ? _context.mozDash = a[0] : "webkitLineDash" in _context && (_context.webkitLineDash = a[0]);
    }
    stroke(path) {
        this.disableStroke || (path ? this.nativeContext.stroke(path) : this.nativeContext.stroke());
    }
    strokeRect(x, y, width, height) {
        this.nativeContext.strokeRect(x, y, width, height);
    }
    strokeText(text, x, y, z) {
        if (z = z || 0, this.camera) {
            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), 
            x = outP[0], y = outP[1], z = outP[2]);
            const data = this.camera.vp(x, y, z);
            x = data.x, y = data.y;
        }
        this.nativeContext.strokeText(text, x, y);
    }
    drawImage() {
        const _context = this.nativeContext, a = arguments;
        3 === a.length ? _context.drawImage(a[0], a[1], a[2]) : 5 === a.length ? _context.drawImage(a[0], a[1], a[2], a[3], a[4]) : 9 === a.length && _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
    }
    setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
        if (Array.isArray(defaultParams)) {
            if (defaultParams.length <= 1) return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams[0]);
            const dp = {};
            return defaultParams.forEach((p => {
                Object.assign(dp, p);
            })), this._setCommonStyle(params, attribute, offsetX, offsetY, dp);
        }
        return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams);
    }
    _setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.fillAttributes);
        const {fillOpacity: fillOpacity = defaultParams.fillOpacity, opacity: opacity = defaultParams.opacity, fill: fill = defaultParams.fill} = attribute;
        fillOpacity > 1e-12 && opacity > 1e-12 ? (_context.globalAlpha = fillOpacity * opacity, 
        _context.fillStyle = (0, canvas_utils_1.createColor)(this, fill, params, offsetX, offsetY)) : _context.globalAlpha = fillOpacity * opacity;
    }
    setShadowStyle(params, attribute, defaultParams) {
        if (Array.isArray(defaultParams)) {
            if (defaultParams.length <= 1) return this._setShadowStyle(params, defaultParams[0]);
            const dp = {};
            return defaultParams.forEach((p => {
                Object.assign(dp, p);
            })), this._setShadowStyle(params, attribute, dp);
        }
        return this._setShadowStyle(params, attribute, defaultParams);
    }
    _setShadowStyle(params, attribute, defaultParams) {
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.fillAttributes);
        const {opacity: opacity = defaultParams.opacity, shadowBlur: shadowBlur = defaultParams.shadowBlur, shadowColor: shadowColor = defaultParams.shadowColor, shadowOffsetX: shadowOffsetX = defaultParams.shadowOffsetX, shadowOffsetY: shadowOffsetY = defaultParams.shadowOffsetY, blur: blur = defaultParams.blur} = attribute;
        opacity <= 1e-12 || (shadowBlur || shadowOffsetX || shadowOffsetY ? (_context.shadowBlur = shadowBlur, 
        _context.shadowColor = shadowColor, _context.shadowOffsetX = shadowOffsetX, _context.shadowOffsetY = shadowOffsetY, 
        this._clearShadowStyle = !0) : this._clearShadowStyle && (_context.shadowBlur = 0, 
        _context.shadowOffsetX = 0, _context.shadowOffsetY = 0), blur ? (_context.filter = `blur(${blur}px)`, 
        this._clearFilterStyle = !0) : this._clearFilterStyle && (_context.filter = "blur(0px)", 
        this._clearFilterStyle = !1));
    }
    setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
        if (Array.isArray(defaultParams)) {
            if (defaultParams.length <= 1) return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams[0]);
            const dp = {};
            return defaultParams.forEach((p => {
                Object.assign(dp, p);
            })), this._setStrokeStyle(params, attribute, offsetX, offsetY, dp);
        }
        return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams);
    }
    _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.strokeAttributes);
        const {strokeOpacity: strokeOpacity = defaultParams.strokeOpacity, opacity: opacity = defaultParams.opacity} = attribute;
        if (strokeOpacity > 1e-12 && opacity > 1e-12) {
            const {lineWidth: lineWidth = defaultParams.lineWidth, stroke: stroke = defaultParams.stroke, lineJoin: lineJoin = defaultParams.lineJoin, lineDash: lineDash = defaultParams.lineDash, lineCap: lineCap = defaultParams.lineCap, miterLimit: miterLimit = defaultParams.miterLimit} = attribute;
            _context.globalAlpha = strokeOpacity * opacity, _context.lineWidth = (0, canvas_utils_1.getScaledStroke)(this, lineWidth, this.dpr), 
            _context.strokeStyle = (0, canvas_utils_1.createColor)(this, stroke, params, offsetX, offsetY), 
            _context.lineJoin = lineJoin, _context.setLineDash(lineDash), _context.lineCap = lineCap, 
            _context.miterLimit = miterLimit;
        }
    }
    setTextStyleWithoutAlignBaseline(params, defaultParams, z) {
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.textAttributes);
        const {scaleIn3d: scaleIn3d = defaultParams.scaleIn3d} = params;
        params.font ? _context.font = params.font : _context.font = (0, text_1.getContextFont)(params, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z));
        const {fontFamily: fontFamily = defaultParams.fontFamily, fontSize: fontSize = defaultParams.fontSize} = params;
        this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = "left", 
        _context.textBaseline = "alphabetic";
    }
    setTextStyle(params, defaultParams, z) {
        var _a, _b;
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = (0, 
        text_1.getContextFont)(params, defaultParams, this.camera && this.camera.getProjectionScale(z));
        const {fontFamily: fontFamily = defaultParams.fontFamily, fontSize: fontSize = defaultParams.fontSize} = params;
        this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, 
        _context.textBaseline = null !== (_b = params.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;
    }
    draw() {}
    clearMatrix(setTransform = !0, dpr = this.dpr) {
        this.setTransformFromMatrix(initMatrix, setTransform, dpr);
    }
    onlyTranslate(dpr = this.dpr) {
        return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
    }
    release(...params) {
        this.stack.forEach((m => matrix_allocate_1.matrixAllocate.free(m))), this.stack.length = 0;
    }
};

BrowserContext2d.env = "browser", BrowserContext2d = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", [ Object, Number ]) ], BrowserContext2d), 
exports.BrowserContext2d = BrowserContext2d;
//# sourceMappingURL=context.js.map

}, function(modId) { var map = {"../../../graphic":1689069767757,"../../../common/canvas-utils":1689069767755,"../../../application":1689069767703,"../../../allocator/matrix-allocate":1689069767808,"./conical-gradient":1689069767753,"../../../core/camera":1689069767848,"../../../common/text":1689069767760}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767848, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.OrthoCamera = exports.transformMat4 = exports.multiply = void 0;

const vutils_1 = require("@visactor/vutils"), matrix_allocate_1 = require("../allocator/matrix-allocate"), matrix_allocate_2 = require("../allocator/matrix-allocate");

function targetTo(out, eye, target, up) {
    const eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    let z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2], len = z0 * z0 + z1 * z1 + z2 * z2;
    len > 0 && (len = 1 / Math.sqrt(len), z0 *= len, z1 *= len, z2 *= len);
    let x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
    return len = x0 * x0 + x1 * x1 + x2 * x2, len > 0 && (len = 1 / Math.sqrt(len), 
    x0 *= len, x1 *= len, x2 *= len), out[0] = x0, out[1] = x1, out[2] = x2, out[3] = 0, 
    out[4] = z1 * x2 - z2 * x1, out[5] = z2 * x0 - z0 * x2, out[6] = z0 * x1 - z1 * x0, 
    out[7] = 0, out[8] = z0, out[9] = z1, out[10] = z2, out[11] = 0, out[12] = eyex, 
    out[13] = eyey, out[14] = eyez, out[15] = 1, out;
}

function lookAt(out, eye, center, up) {
    let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    const eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center[0], centery = center[1], centerz = center[2];
    return Math.abs(eyex - centerx) < vutils_1.epsilon && Math.abs(eyey - centery) < vutils_1.epsilon && Math.abs(eyez - centerz) < vutils_1.epsilon ? matrix_allocate_1.DefaultMat4Allocate.identity(out) : (z0 = eyex - centerx, 
    z1 = eyey - centery, z2 = eyez - centerz, len = 1 / Math.hypot(z0, z1, z2), z0 *= len, 
    z1 *= len, z2 *= len, x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0, 
    len = Math.hypot(x0, x1, x2), len ? (len = 1 / len, x0 *= len, x1 *= len, x2 *= len) : (x0 = 0, 
    x1 = 0, x2 = 0), y0 = z1 * x2 - z2 * x1, y1 = z2 * x0 - z0 * x2, y2 = z0 * x1 - z1 * x0, 
    len = Math.hypot(y0, y1, y2), len ? (len = 1 / len, y0 *= len, y1 *= len, y2 *= len) : (y0 = 0, 
    y1 = 0, y2 = 0), out[0] = x0, out[1] = y0, out[2] = z0, out[3] = 0, out[4] = x1, 
    out[5] = y1, out[6] = z1, out[7] = 0, out[8] = x2, out[9] = y2, out[10] = z2, out[11] = 0, 
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez), out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez), 
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez), out[15] = 1, out);
}

function ortho(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
    return out[0] = -2 * lr, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = -2 * bt, 
    out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 2 * nf, out[11] = 0, out[12] = (left + right) * lr, 
    out[13] = (top + bottom) * bt, out[14] = (far + near) * nf, out[15] = 1, out;
}

function multiply(out, a, b) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
    b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], 
    b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
    b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}

function transformMat4(out, a, m) {
    const x = a[0], y = a[1], z = a[2];
    let w = m[3] * x + m[7] * y + m[11] * z + m[15];
    return w = w || 1, out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w, out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w, 
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w, out;
}

exports.multiply = multiply, exports.transformMat4 = transformMat4;

class OrthoCamera {
    set params(params) {
        this._params = Object.assign({}, params), this._projectionMatrixCached = this.forceGetProjectionMatrix(), 
        this._viewMatrixCached = this.forceGetViewMatrix();
    }
    get params() {
        return Object.assign({}, this._params);
    }
    constructor(params) {
        this.params = params;
    }
    getViewMatrix() {
        return this._viewMatrixCached || (this._viewMatrixCached = matrix_allocate_2.mat4Allocate.allocate()), 
        this._viewMatrixCached;
    }
    forceGetViewMatrix() {
        this._viewMatrixCached || (this._viewMatrixCached = matrix_allocate_2.mat4Allocate.allocate());
        const {pos: pos, center: center, up: up} = this.params.viewParams;
        return lookAt(this._viewMatrixCached, pos, center, up), this._vp || (this._vp = matrix_allocate_2.mat4Allocate.allocate()), 
        this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), 
        this._viewMatrixCached;
    }
    getProjectionMatrix() {
        return this._projectionMatrixCached || (this._projectionMatrixCached = matrix_allocate_2.mat4Allocate.allocate()), 
        this._projectionMatrixCached;
    }
    forceGetProjectionMatrix() {
        this._projectionMatrixCached || (this._projectionMatrixCached = matrix_allocate_2.mat4Allocate.allocate());
        const {left: left, top: top, right: right, bottom: bottom} = this._params;
        return ortho(this._projectionMatrixCached, left, right, bottom, top, 0, -2e6), this._vp || (this._vp = matrix_allocate_2.mat4Allocate.allocate()), 
        this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), 
        this._projectionMatrixCached;
    }
    getField() {
        const {fieldRatio: fieldRatio = .8, fieldDepth: fieldDepth, left: left, right: right} = this._params;
        return (null != fieldDepth ? fieldDepth : right - left) * fieldRatio;
    }
    getProjectionScale(z) {
        const field = this.getField();
        return field / (field + z);
    }
    view(x, y, z) {
        const outP = [ 0, 0, 0 ];
        return transformMat4(outP, [ x, y, z ], this._viewMatrixCached), outP;
    }
    vp(x, y, z) {
        const outP = [ 0, 0, 0 ], {pos: pos} = this._params.viewParams;
        transformMat4(outP, [ x, y, z ], this._viewMatrixCached), x = outP[0], y = outP[1], 
        z = outP[2];
        const sizeProjection = this.getProjectionScale(z);
        return {
            x: x * sizeProjection + pos[0],
            y: y * sizeProjection + pos[1]
        };
    }
}

exports.OrthoCamera = OrthoCamera;
//# sourceMappingURL=camera.js.map
}, function(modId) { var map = {"../allocator/matrix-allocate":1689069767808}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767849, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.MathPickerContribution = exports.MathGlyphPicker = exports.MathPolygonPicker = exports.MathTextPicker = exports.MathSymbolPicker = exports.MathRectPicker = exports.MathPathPicker = exports.MathLinePicker = exports.MathImagePicker = exports.MathCirclePicker = exports.MathAreaPicker = exports.MathArcPicker = exports.CanvasPickerContribution = exports.CanvasGlyphPicker = exports.CanvasRichTextPicker = exports.CanvasPyramid3dPicker = exports.CanvasPolygonPicker = exports.CanvasTextPicker = exports.CanvasSymbolPicker = exports.CanvasRect3dPicker = exports.CanvasRectPicker = exports.CanvasPathPicker = exports.CanvasLinePicker = exports.CanvasImagePicker = exports.CanvasCirclePicker = exports.CanvasAreaPicker = exports.CanvasArc3dPicker = exports.CanvasArcPicker = void 0, 
exports.CanvasArcPicker = Symbol.for("CanvasArcPicker"), exports.CanvasArc3dPicker = Symbol.for("CanvasArc3dPicker"), 
exports.CanvasAreaPicker = Symbol.for("CanvasAreaPicker"), exports.CanvasCirclePicker = Symbol.for("CanvasCirclePicker"), 
exports.CanvasImagePicker = Symbol.for("CanvasImagePicker"), exports.CanvasLinePicker = Symbol.for("CanvasLinePicker"), 
exports.CanvasPathPicker = Symbol.for("CanvasPathPicker"), exports.CanvasRectPicker = Symbol.for("CanvasRectPicker"), 
exports.CanvasRect3dPicker = Symbol.for("CanvasRect3dPicker"), exports.CanvasSymbolPicker = Symbol.for("CanvasSymbolPicker"), 
exports.CanvasTextPicker = Symbol.for("CanvasTextPicker"), exports.CanvasPolygonPicker = Symbol.for("CanvasPolygonPicker"), 
exports.CanvasPyramid3dPicker = Symbol.for("CanvasPyramid3dPicker"), exports.CanvasRichTextPicker = Symbol.for("CanvasRichTextPicker"), 
exports.CanvasGlyphPicker = Symbol.for("CanvasGlyphPicker"), exports.CanvasPickerContribution = Symbol.for("CanvasPickerContribution"), 
exports.MathArcPicker = Symbol.for("MathArcPicker"), exports.MathAreaPicker = Symbol.for("MathAreaPicker"), 
exports.MathCirclePicker = Symbol.for("MathCirclePicker"), exports.MathImagePicker = Symbol.for("MathImagePicker"), 
exports.MathLinePicker = Symbol.for("MathLinePicker"), exports.MathPathPicker = Symbol.for("MathPathPicker"), 
exports.MathRectPicker = Symbol.for("MathRectPicker"), exports.MathSymbolPicker = Symbol.for("MathSymbolPicker"), 
exports.MathTextPicker = Symbol.for("MathTextPicker"), exports.MathPolygonPicker = Symbol.for("MathPolygonPicker"), 
exports.MathGlyphPicker = Symbol.for("MathGlyphPicker"), exports.MathPickerContribution = Symbol.for("MathPickerContribution");
//# sourceMappingURL=constants.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767850, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./render-service"), exports), __exportStar(require("./contributions/render"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./render-service":1689069767749,"./contributions/render":1689069767750}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767851, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMathPickerService = void 0;

const contribution_provider_1 = require("../common/contribution-provider"), inversify_1 = require("inversify"), picker_service_1 = require("./picker-service"), canvas_1 = require("../canvas"), constants_1 = require("./contributions/constants"), constants_2 = require("../constants"), pick_interceptor_1 = require("./pick-interceptor");

let DefaultMathPickerService = class extends picker_service_1.DefaultPickService {
    constructor(contributions, global, pickItemInterceptorContributions) {
        super(global, pickItemInterceptorContributions), this.contributions = contributions, 
        this.global = global, this.pickItemInterceptorContributions = pickItemInterceptorContributions, 
        this.global.hooks.onSetEnv.tap("math-picker-service", ((lastEnv, env, global) => {
            this.configure(global, env);
        })), this.configure(this.global, this.global.env), this.pickerMap = new Map;
    }
    init() {
        this.contributions.getContributions().forEach((item => {
            this.pickerMap.set(item.numberType, item);
        })), super._init();
    }
    configure(global, env) {
        this.pickContext = new canvas_1.EmptyContext2d(null, 1);
    }
    pickItem(graphic, point, params) {
        if (!1 === graphic.attribute.pickable) return null;
        const picker = this.pickerMap.get(graphic.numberType);
        return picker && picker.contains(graphic, point, params) ? graphic : null;
    }
};

__decorate([ (0, inversify_1.postConstruct)(), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0) ], DefaultMathPickerService.prototype, "init", null), 
DefaultMathPickerService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(constants_1.MathPickerContribution)), __param(1, (0, inversify_1.inject)(constants_2.Global)), __param(2, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(2, (0, 
inversify_1.named)(pick_interceptor_1.PickItemInterceptor)), __metadata("design:paramtypes", [ Object, Object, Object ]) ], DefaultMathPickerService), 
exports.DefaultMathPickerService = DefaultMathPickerService;
//# sourceMappingURL=math-picker-service.js.map

}, function(modId) { var map = {"../common/contribution-provider":1689069767672,"./picker-service":1689069767840,"../canvas":1689069767852,"./contributions/constants":1689069767849,"../constants":1689069767676,"./pick-interceptor":1689069767842}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767852, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./constants"), exports), __exportStar(require("./empty-context"), exports), 
__exportStar(require("./contributions/browser"), exports);
//# sourceMappingURL=index.js.map
}, function(modId) { var map = {"./constants":1689069767704,"./empty-context":1689069767853,"./contributions/browser":1689069767845}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767853, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.EmptyContext2d = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), util_1 = require("./util"), custom_path2d_1 = require("../common/custom-path2d"), canvas_utils_1 = require("../common/canvas-utils"), matrix_allocate_1 = require("../allocator/matrix-allocate"), initMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), globalPoint = {
    x: 0,
    y: 0
};

let EmptyContext2d = class {
    get nativeContext() {
        return this.path;
    }
    constructor(canvas, dpr) {
        this.matrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, 
        this.applyedMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), this.path = new custom_path2d_1.CustomPath2D;
    }
    getCanvas() {
        throw new Error("不支持getCanvas");
    }
    getContext() {
        throw new Error("不支持getContext");
    }
    setTransformForCurrent(force = !1) {
        !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix = this.cloneMatrix(this.matrix));
    }
    get currentMatrix() {
        return this.matrix;
    }
    cloneMatrix(m) {
        return matrix_allocate_1.matrixAllocate.allocateByObj(m);
    }
    clear() {
        this.save(), this.resetTransform(), this.restore();
    }
    restore() {
        this.stack.length > 0 && (matrix_allocate_1.matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), 
        this.setTransformForCurrent());
    }
    highPerformanceRestore() {
        this.stack.length > 0 && (matrix_allocate_1.matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
    }
    rotate(rad, setTransform = !0) {
        this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
    }
    save() {
        const matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix);
    }
    highPerformanceSave() {
        const matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix);
    }
    scale(sx, sy, setTransform = !0) {
        this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
    }
    setScale(sx, sy, setTransform = !0) {
        this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
    }
    scalePoint(sx, sy, px, py, setTransform = !0) {
        this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), 
        setTransform && this.setTransformForCurrent();
    }
    setTransform(a, b, c, d, e, f, setTransform = !0, dpr = this.dpr) {
        this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
    }
    setTransformFromMatrix(matrix, setTransform = !0, dpr = this.dpr) {
        this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), 
        setTransform && this.setTransformForCurrent();
    }
    resetTransform(setTransform = !0, dpr = this.dpr) {
        this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
    }
    transform(a, b, c, d, e, f, setTransform = !0) {
        this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();
    }
    transformFromMatrix(matrix, setTransform) {
        this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), 
        setTransform && this.setTransformForCurrent();
    }
    translate(x, y, setTransform = !0) {
        this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
    }
    rotateDegrees(deg, setTransform = !0) {
        const rad = deg * Math.PI / 180;
        this.rotate(rad, setTransform);
    }
    rotateAbout(rad, x, y, setTransform = !0) {
        this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
    }
    rotateDegreesAbout(deg, x, y, setTransform = !0) {
        this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), 
        setTransform && this.setTransformForCurrent();
    }
    beginPath() {
        this.path.clear();
    }
    clip(path, fillRule) {}
    arc(x, y, radius, startAngle, endAngle, anticlockwise) {
        this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    arcTo(x1, y1, x2, y2, radiusX) {
        this.path.arcTo(x1, y1, x2, y2, radiusX);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    closePath() {
        this.path.closePath();
    }
    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {}
    lineTo(x, y) {
        this.path.lineTo(x, y);
    }
    moveTo(x, y) {
        this.path.moveTo(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
        this.path.quadraticCurveTo(cpx, cpy, x, y);
    }
    rect(x, y, w, h) {
        this.path.rect(x, y, w, h);
    }
    createImageData(imageDataOrSw, sh) {
        return null;
    }
    createLinearGradient(x0, y0, x1, y1) {
        throw new Error("不支持createLinearGradient");
    }
    createPattern(image, repetition) {
        throw new Error("不支持createPattern");
    }
    createRadialGradient(x0, y0, r0, x1, y1, r1) {
        throw new Error("不支持createRadialGradient");
    }
    createConicGradient(x, y, startAngle, endAngle) {
        return null;
    }
    fill(path, fillRule) {}
    fillRect(x, y, width, height) {
        this.path.rect(x, y, width, height);
    }
    clearRect(x, y, w, h) {}
    fillText(text, x, y) {}
    getImageData(sx, sy, sw, sh) {
        return null;
    }
    getLineDash() {
        return [];
    }
    isPointInPath(x, y) {
        return this.matrix.transformPoint({
            x: x,
            y: y
        }, globalPoint), (0, util_1.contain)(this.path.commandList, globalPoint.x, globalPoint.y);
    }
    isPointInStroke(x, y) {
        if (!this.lineWidth) return !1;
        this.matrix.transformPoint({
            x: x,
            y: y
        }, globalPoint);
        const lineWidth = (0, canvas_utils_1.getScaledStroke)(this, this.lineWidth, this.dpr);
        return (0, util_1.containStroke)(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
    }
    measureText(text) {
        throw new Error("不支持measureText");
    }
    putImageData(imagedata, dx, dy) {
        throw new Error("不支持measureText");
    }
    setLineDash(segments) {}
    stroke(path) {}
    strokeRect(x, y, width, height) {
        this.path.rect(x, y, width, height);
    }
    strokeText(text, x, y) {}
    drawImage() {}
    setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {}
    _setCommonStyle(params, offsetX, offsetY, defaultParams) {}
    setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {}
    _setStrokeStyle(params, offsetX, offsetY, defaultParams) {}
    setTextStyleWithoutAlignBaseline(params, defaultParams) {}
    setTextStyle(params, defaultParams) {}
    draw() {}
    clearMatrix(setTransform = !0, dpr = this.dpr) {
        this.setTransformFromMatrix(initMatrix, setTransform, dpr);
    }
    onlyTranslate(dpr = this.dpr) {
        return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
    }
    release(...params) {
        this.stack.forEach((m => matrix_allocate_1.matrixAllocate.free(m))), this.stack.length = 0;
    }
};

EmptyContext2d = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", [ Object, Number ]) ], EmptyContext2d), 
exports.EmptyContext2d = EmptyContext2d;
//# sourceMappingURL=empty-context.js.map
}, function(modId) { var map = {"./util":1689069767701,"../common/custom-path2d":1689069767681,"../common/canvas-utils":1689069767755,"../allocator/matrix-allocate":1689069767808}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767854, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), contribution_provider_1 = require("../../common/contribution-provider"), arc_contribution_1 = require("./arc-contribution"), circle_contribution_1 = require("./circle-contribution"), graphic_service_1 = require("./graphic-service"), path_contribution_1 = require("./path-contribution"), rect_contribution_1 = require("./rect-contribution"), symbol_contribution_1 = require("./symbol-contribution"), constants_1 = require("../constants"), graphic_creator_1 = require("../graphic-creator");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(graphic_service_1.DefaultGraphicService).toSelf().inSingletonScope(), bind(constants_1.GraphicService).toService(graphic_service_1.DefaultGraphicService), 
    bind(rect_contribution_1.DefaultRectOuterBorderBoundsContribution).toSelf().inSingletonScope(), 
    bind(rect_contribution_1.RectBoundsContribution).toService(rect_contribution_1.DefaultRectOuterBorderBoundsContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, rect_contribution_1.RectBoundsContribution), 
    bind(symbol_contribution_1.DefaultSymbolOuterBorderBoundsContribution).toSelf().inSingletonScope(), 
    bind(symbol_contribution_1.SymbolBoundsContribution).toService(symbol_contribution_1.DefaultSymbolOuterBorderBoundsContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, symbol_contribution_1.SymbolBoundsContribution), 
    bind(circle_contribution_1.DefaultCircleOuterBorderBoundsContribution).toSelf().inSingletonScope(), 
    bind(circle_contribution_1.CircleBoundsContribution).toService(circle_contribution_1.DefaultCircleOuterBorderBoundsContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, circle_contribution_1.CircleBoundsContribution), 
    bind(arc_contribution_1.DefaultArcOuterBorderBoundsContribution).toSelf().inSingletonScope(), 
    bind(arc_contribution_1.ArcBoundsContribution).toService(arc_contribution_1.DefaultArcOuterBorderBoundsContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, arc_contribution_1.ArcBoundsContribution), 
    bind(path_contribution_1.DefaultPathOuterBorderBoundsContribution).toSelf().inSingletonScope(), 
    bind(path_contribution_1.PathBoundsContribution).toService(path_contribution_1.DefaultPathOuterBorderBoundsContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, path_contribution_1.PathBoundsContribution), 
    bind(constants_1.GraphicCreator).toConstantValue(graphic_creator_1.graphicCreator);
}));
//# sourceMappingURL=graphic-module.js.map

}, function(modId) { var map = {"../../common/contribution-provider":1689069767672,"./arc-contribution":1689069767806,"./circle-contribution":1689069767805,"./graphic-service":1689069767801,"./path-contribution":1689069767807,"./rect-contribution":1689069767802,"./symbol-contribution":1689069767804,"../constants":1689069767744,"../graphic-creator":1689069767809}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767855, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), plugin_service_1 = require("./plugin-service");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(plugin_service_1.DefaultPluginService).toSelf(), bind(plugin_service_1.PluginService).toService(plugin_service_1.DefaultPluginService);
}));
//# sourceMappingURL=plugin-modules.js.map

}, function(modId) { var map = {"./plugin-service":1689069767856}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767856, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultPluginService = exports.PluginService = void 0;

const inversify_1 = require("inversify");

exports.PluginService = Symbol.for("PluginService");

let DefaultPluginService = class {
    constructor() {
        this.onStartupFinishedPlugin = [], this.onRegisterPlugin = [], this.actived = !1;
    }
    active(stage) {
        this.stage = stage, this.actived = !0;
    }
    findPluginsByName(name) {
        const arr = [];
        return this.onStartupFinishedPlugin.forEach((plugin => {
            plugin.name === name && arr.push(plugin);
        })), this.onRegisterPlugin.forEach((plugin => {
            plugin.name === name && arr.push(plugin);
        })), arr;
    }
    register(plugin) {
        "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.push(plugin) : "onRegister" === plugin.activeEvent && (this.onRegisterPlugin.push(plugin), 
        plugin.activate(this));
    }
    release(...params) {
        this.onStartupFinishedPlugin.forEach((plugin => {
            plugin.deactivate(this);
        })), this.onStartupFinishedPlugin = [], this.onRegisterPlugin.forEach((plugin => {
            plugin.deactivate(this);
        })), this.onRegisterPlugin = [];
    }
};

DefaultPluginService = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", []) ], DefaultPluginService), 
exports.DefaultPluginService = DefaultPluginService;
//# sourceMappingURL=plugin-service.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767857, function(require, module, exports) {


var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

const modules_1 = __importDefault(require("./env/modules")), modules_2 = __importDefault(require("./window/modules")), modules_3 = __importDefault(require("./textMeasure/modules")), modules_4 = __importDefault(require("./layerHandler/modules"));

function load(container) {
    container.load(modules_1.default), container.load(modules_2.default), container.load(modules_3.default), 
    container.load(modules_4.default);
}

exports.default = load;
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"./env/modules":1689069767858,"./window/modules":1689069767868,"./textMeasure/modules":1689069767887,"./layerHandler/modules":1689069767888}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767858, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), contribution_provider_1 = require("../../../common/contribution-provider"), constants_1 = require("../../../constants"), browser_contribution_1 = require("./browser-contribution"), feishu_contribution_1 = require("./feishu-contribution"), taro_contribution_1 = require("./taro-contribution"), lynx_contribution_1 = require("./lynx-contribution"), node_contribution_1 = require("./node-contribution");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(browser_contribution_1.BrowserEnvContribution).toSelf().inSingletonScope(), 
    bind(constants_1.EnvContribution).toService(browser_contribution_1.BrowserEnvContribution), 
    bind(feishu_contribution_1.FeishuEnvContribution).toSelf().inSingletonScope(), bind(constants_1.EnvContribution).toService(feishu_contribution_1.FeishuEnvContribution), 
    bind(taro_contribution_1.TaroEnvContribution).toSelf().inSingletonScope(), bind(constants_1.EnvContribution).toService(taro_contribution_1.TaroEnvContribution), 
    bind(lynx_contribution_1.LynxEnvContribution).toSelf().inSingletonScope(), bind(constants_1.EnvContribution).toService(lynx_contribution_1.LynxEnvContribution), 
    bind(node_contribution_1.NodeEnvContribution).toSelf().inSingletonScope(), bind(constants_1.EnvContribution).toService(node_contribution_1.NodeEnvContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, constants_1.EnvContribution);
}));
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"../../../common/contribution-provider":1689069767672,"../../../constants":1689069767676,"./browser-contribution":1689069767859,"./feishu-contribution":1689069767861,"./taro-contribution":1689069767865,"./lynx-contribution":1689069767866,"./node-contribution":1689069767867}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767859, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BrowserEnvContribution = exports.createImageElement = void 0;

const inversify_1 = require("inversify"), generator_1 = require("../../../common/generator"), base_contribution_1 = require("./base-contribution"), vutils_1 = require("@visactor/vutils");

function createImageElement(src, isSvg = !1) {
    const img = document.createElement("img");
    if (img.crossOrigin = "anonymous", isSvg) {
        const data = new Blob([ src ], {
            type: "image/svg+xml"
        });
        src = window.URL.createObjectURL(data);
    }
    if (img.src = src, img.complete) return Promise.resolve(img);
    return new Promise(((resolve, reject) => {
        img.onload = () => {
            resolve(img);
        }, img.onerror = () => {
            reject(new Error("加载失败"));
        };
    }));
}

exports.createImageElement = createImageElement;

let BrowserEnvContribution = class extends base_contribution_1.BaseEnvContribution {
    constructor() {
        super(), this.type = "browser", this.supportEvent = !0;
        try {
            this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, 
            this.supportsMouseEvents = !!globalThis.MouseEvent;
        } catch (err) {
            this.supportsTouchEvents = !1, this.supportsPointerEvents = !1, this.supportsPointerEvents = !1;
        }
        this.applyStyles = !0;
    }
    mapToCanvasPoint(nativeEvent, domElement) {
        var _a;
        if (domElement) {
            const {clientX: x, clientY: y} = nativeEvent, rect = domElement.getBoundingClientRect(), nativeCanvas = null === (_a = domElement.getNativeHandler) || void 0 === _a ? void 0 : _a.call(domElement).nativeCanvas;
            let scaleX, scaleY;
            return nativeCanvas && (scaleX = rect.width / nativeCanvas.offsetWidth, scaleY = rect.height / nativeCanvas.offsetHeight), 
            {
                x: (x - rect.left) / ((0, vutils_1.isValidNumber)(scaleX) ? scaleX : 1),
                y: (y - rect.top) / ((0, vutils_1.isValidNumber)(scaleY) ? scaleX : 1)
            };
        }
        return {
            x: nativeEvent.offsetX,
            y: nativeEvent.offsetY
        };
    }
    loadImage(url) {
        return createImageElement(url, !1).then((img => ({
            data: img,
            loadState: "success"
        }))).catch((() => ({
            data: null,
            loadState: "fail"
        })));
    }
    loadSvg(url) {
        return createImageElement(url, !0).then((img => ({
            data: img,
            loadState: "success"
        }))).catch((() => ({
            data: null,
            loadState: "fail"
        })));
    }
    createCanvas(params) {
        var _a, _b;
        const canvas = document.createElement("canvas");
        params.id && (canvas.id = null !== (_a = params.id) && void 0 !== _a ? _a : generator_1.Generator.GenAutoIncrementId().toString());
        const dpr = null !== (_b = params.dpr) && void 0 !== _b ? _b : window.devicePixelRatio;
        return params.width && params.height && (canvas.style.width = `${params.width}px`, 
        canvas.style.height = `${params.height}px`, canvas.width = params.width * dpr, canvas.height = params.height * dpr), 
        canvas;
    }
    createOffscreenCanvas(params) {
        var _a;
        const dpr = null !== (_a = params.dpr) && void 0 !== _a ? _a : window.devicePixelRatio;
        return new OffscreenCanvas(params.width * dpr, params.height * dpr);
    }
    releaseCanvas(canvas) {
        let c;
        c = "string" == typeof canvas ? document.getElementById(canvas) : canvas, c && c.parentElement && c.parentElement.removeChild(c);
    }
    getDevicePixelRatio() {
        return window.devicePixelRatio;
    }
    getRequestAnimationFrame() {
        return window.requestAnimationFrame;
    }
    getCancelAnimationFrame() {
        return window.cancelAnimationFrame;
    }
    addEventListener(type, listener, options) {
        return document.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
        return document.removeEventListener(type, listener, options);
    }
    dispatchEvent(event) {
        return document.dispatchEvent(event);
    }
    getElementById(str) {
        return document.getElementById(str);
    }
    getRootElement() {
        return document.body;
    }
    getDocument() {
        return document;
    }
    release(...params) {}
};

BrowserEnvContribution = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", []) ], BrowserEnvContribution), 
exports.BrowserEnvContribution = BrowserEnvContribution;
//# sourceMappingURL=browser-contribution.js.map

}, function(modId) { var map = {"../../../common/generator":1689069767711,"./base-contribution":1689069767860}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767860, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseEnvContribution = void 0;

const inversify_1 = require("inversify");

let BaseEnvContribution = class {
    configure(service, ...p) {
        service.env === this.type && service.setActiveEnvContribution(this);
    }
    getElementById(str) {
        return document.getElementById(str);
    }
    getRootElement() {
        return document.body;
    }
    loadJson(url) {
        const jsonPromise = fetch(url).then((data => data.json()));
        return jsonPromise.then((json => ({
            data: json,
            state: "success"
        }))).catch((() => ({
            data: null,
            state: "fail"
        }))), jsonPromise;
    }
    loadArrayBuffer(url) {
        return fetch(url).then((data => data.arrayBuffer())).then((arrayBuffer => ({
            data: arrayBuffer,
            loadState: "success"
        }))).catch((() => ({
            data: null,
            loadState: "fail"
        })));
    }
    loadBlob(url) {
        return fetch(url).then((data => data.blob())).then((blob => ({
            data: blob,
            loadState: "success"
        }))).catch((() => ({
            data: null,
            loadState: "fail"
        })));
    }
};

BaseEnvContribution = __decorate([ (0, inversify_1.injectable)() ], BaseEnvContribution), 
exports.BaseEnvContribution = BaseEnvContribution;
//# sourceMappingURL=base-contribution.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767861, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.FeishuEnvContribution = void 0;

const inversify_1 = require("inversify"), kits_1 = require("../../../kits"), base_contribution_1 = require("./base-contribution");

function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList) {
    const dpr = tt.getSystemInfoSync().pixelRatio;
    canvasIdLists.forEach(((id, i) => {
        const ctx = tt.createCanvasContext(id);
        ctx.canvas = {
            width: domref.width * dpr,
            height: domref.height * dpr
        };
        const canvas = {
            width: domref.width,
            height: domref.height,
            offsetWidth: domref.width,
            offsetHeight: domref.height,
            id: null != id ? id : "",
            getContext: () => ctx,
            getBoundingClientRect: () => ({
                height: domref.height,
                width: domref.width
            })
        };
        canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas);
    }));
}

let FeishuEnvContribution = class extends base_contribution_1.BaseEnvContribution {
    constructor() {
        super(), this.type = "feishu", this.supportEvent = !0, this.canvasMap = new Map, 
        this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = !0;
        try {
            this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
        } catch (err) {
            this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;
        }
        this.applyStyles = !0;
    }
    configure(service, params) {
        service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList), 
        (0, kits_1.loadFeishuContributions)());
    }
    loadImage(url) {
        return Promise.resolve({
            data: url,
            loadState: "success"
        });
    }
    loadSvg(url) {
        return Promise.reject();
    }
    createCanvas(params) {
        const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
        return this.canvasIdx++, result;
    }
    createOffscreenCanvas(params) {}
    releaseCanvas(canvas) {}
    getDevicePixelRatio() {
        return tt.getSystemInfoSync().pixelRatio;
    }
    getRequestAnimationFrame() {
        return function(callback) {
            return setTimeout(callback, 1e3 / 60, !0);
        };
    }
    getCancelAnimationFrame() {
        return h => {
            clearTimeout(h);
        };
    }
    addEventListener(type, listener, options) {
        return null;
    }
    removeEventListener(type, listener, options) {
        return null;
    }
    dispatchEvent(event) {
        return null;
    }
    getElementById(str) {
        return this.canvasMap.get(str);
    }
    getRootElement() {
        return null;
    }
    getDocument() {
        return null;
    }
    release(...params) {}
    mapToCanvasPoint(event) {
        var _a;
        return (null === (_a = null == event ? void 0 : event.type) || void 0 === _a ? void 0 : _a.startsWith("mouse")) ? event : null;
    }
};

FeishuEnvContribution = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", []) ], FeishuEnvContribution), 
exports.FeishuEnvContribution = FeishuEnvContribution;
//# sourceMappingURL=feishu-contribution.js.map

}, function(modId) { var map = {"../../../kits":1689069767862,"./base-contribution":1689069767860}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767862, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./env"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./env":1689069767863}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767863, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.loadTaroContributions = exports.loadFeishuContributions = void 0;

const container_1 = require("../container"), picker_1 = require("../picker");

function loadFeishuContributions() {
    container_1.container.rebind(picker_1.PickerService).toService(picker_1.DefaultMathPickerService);
}

function loadTaroContributions() {
    container_1.container.rebind(picker_1.PickerService).toService(picker_1.DefaultMathPickerService);
}

exports.loadFeishuContributions = loadFeishuContributions, exports.loadTaroContributions = loadTaroContributions;
//# sourceMappingURL=env.js.map

}, function(modId) { var map = {"../container":1689069767702,"../picker":1689069767864}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767864, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./picker-service"), exports), __exportStar(require("./canvas-picker-service"), exports), 
__exportStar(require("./math-picker-service"), exports), __exportStar(require("./global-picker-service"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./picker-service":1689069767840,"./canvas-picker-service":1689069767844,"./math-picker-service":1689069767851,"./global-picker-service":1689069767843}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767865, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TaroEnvContribution = void 0;

const inversify_1 = require("inversify"), kits_1 = require("../../../kits"), base_contribution_1 = require("./base-contribution");

function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, taro, dpr) {
    canvasIdLists.forEach(((id, i) => {
        const ctx = taro.createCanvasContext(id);
        ctx.canvas = {
            width: domref.width * dpr,
            height: domref.height * dpr
        }, ctx.createRadialGradient || (ctx.createRadialGradient = (...cc) => ctx.createCircularGradient(...cc)), 
        !ctx.getImageData && taro.canvasGetImageData && (ctx.getImageData = (x, y, width, height) => new Promise(((resolve, reject) => {
            try {
                taro.canvasGetImageData({
                    canvasId: id,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    success(res) {
                        resolve(res);
                    }
                });
            } catch (err) {
                reject(err);
            }
        })));
        const canvas = {
            id: id,
            width: domref.width,
            height: domref.height,
            offsetWidth: domref.width,
            offsetHeight: domref.height,
            getContext: () => ctx,
            getBoundingClientRect: () => ({
                height: domref.height,
                width: domref.width
            })
        };
        return canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), 
        canvas;
    }));
}

let TaroEnvContribution = class extends base_contribution_1.BaseEnvContribution {
    constructor() {
        super(), this.type = "taro", this.supportEvent = !0, this.canvasMap = new Map, this.freeCanvasList = [], 
        this.canvasIdx = 0, this.supportsTouchEvents = !0;
        try {
            this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
        } catch (err) {
            this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;
        }
        this.applyStyles = !0;
    }
    configure(service, params) {
        service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.taro, params.pixelRatio), 
        this.taro = params.taro, this.pixelRatio = params.pixelRatio, (0, kits_1.loadTaroContributions)());
    }
    loadImage(url) {
        return Promise.resolve({
            data: url,
            loadState: "success"
        });
    }
    loadSvg(svgStr) {
        const _window = window || globalThis;
        if (_window.DOMParser) {
            const svg = (new _window.DOMParser).parseFromString(svgStr, "image/svg+xml").children[0], data = (new XMLSerializer).serializeToString(svg), url = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(data)}`;
            return Promise.resolve({
                data: url,
                loadState: "success"
            });
        }
        if (_window.Blob) {
            const data = new _window.Blob([ svgStr ], {
                type: "image/svg+xml"
            }), url = _window.URL.createObjectURL(data);
            return Promise.resolve({
                data: url,
                loadState: "success"
            });
        }
        return Promise.reject();
    }
    createCanvas(params) {
        const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
        return this.canvasIdx++, result;
    }
    createOffscreenCanvas(params) {}
    releaseCanvas(canvas) {}
    getDevicePixelRatio() {
        return this.pixelRatio;
    }
    getRequestAnimationFrame() {
        return requestAnimationFrame;
    }
    getCancelAnimationFrame() {
        return cancelAnimationFrame;
    }
    addEventListener(type, listener, options) {
        return null;
    }
    removeEventListener(type, listener, options) {
        return null;
    }
    dispatchEvent(event) {
        return null;
    }
    getElementById(str) {
        return this.canvasMap.get(str);
    }
    getRootElement() {
        return null;
    }
    getDocument() {
        return null;
    }
    release(...params) {}
};

TaroEnvContribution = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", []) ], TaroEnvContribution), 
exports.TaroEnvContribution = TaroEnvContribution;
//# sourceMappingURL=taro-contribution.js.map

}, function(modId) { var map = {"../../../kits":1689069767862,"./base-contribution":1689069767860}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767866, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LynxEnvContribution = void 0;

const inversify_1 = require("inversify"), kits_1 = require("../../../kits"), base_contribution_1 = require("./base-contribution");

function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList) {
    SystemInfo.pixelRatio;
    canvasIdLists.forEach(((id, i) => {
        const ctx = lynx.createCanvas(id).getContext("2d");
        ctx.draw = (a, b) => {
            b();
        };
        const canvas = {
            width: domref.width,
            height: domref.height,
            offsetWidth: domref.width,
            offsetHeight: domref.height,
            id: null != id ? id : "",
            getContext: () => ctx,
            getBoundingClientRect: () => ({
                height: domref.height,
                width: domref.width
            })
        };
        canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas);
    }));
}

let LynxEnvContribution = class extends base_contribution_1.BaseEnvContribution {
    constructor() {
        super(), this.type = "lynx", this.supportEvent = !0, this.canvasMap = new Map, this.freeCanvasList = [], 
        this.canvasIdx = 0, this.supportsTouchEvents = !0;
        try {
            this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
        } catch (err) {
            this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;
        }
        this.applyStyles = !0;
    }
    configure(service, params) {
        service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList), 
        (0, kits_1.loadFeishuContributions)());
    }
    loadImage(url) {
        return Promise.resolve({
            data: url,
            loadState: "success"
        });
    }
    loadSvg(url) {
        return Promise.reject();
    }
    createCanvas(params) {
        const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
        return this.canvasIdx++, result;
    }
    createOffscreenCanvas(params) {}
    releaseCanvas(canvas) {}
    getDevicePixelRatio() {
        return SystemInfo.pixelRatio;
    }
    getRequestAnimationFrame() {
        return function(callback) {
            return setTimeout(callback, 1e3 / 60, !0);
        };
    }
    getCancelAnimationFrame() {
        return h => {
            clearTimeout(h);
        };
    }
    addEventListener(type, listener, options) {
        return null;
    }
    removeEventListener(type, listener, options) {
        return null;
    }
    dispatchEvent(event) {
        return null;
    }
    getElementById(str) {
        return this.canvasMap.get(str);
    }
    getRootElement() {
        return null;
    }
    getDocument() {
        return null;
    }
    release(...params) {}
};

LynxEnvContribution = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", []) ], LynxEnvContribution), 
exports.LynxEnvContribution = LynxEnvContribution;
//# sourceMappingURL=lynx-contribution.js.map

}, function(modId) { var map = {"../../../kits":1689069767862,"./base-contribution":1689069767860}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767867, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.NodeEnvContribution = void 0;

const inversify_1 = require("inversify"), base_contribution_1 = require("./base-contribution");

let NodeEnvContribution = class extends base_contribution_1.BaseEnvContribution {
    constructor() {
        super(...arguments), this.type = "node", this._lastTime = 0, this.supportEvent = !1;
    }
    configure(service, pkg) {
        service.env === this.type && (service.setActiveEnvContribution(this), this.pkg = pkg);
    }
    loadJson(url) {
        const jsonPromise = fetch(url).then((data => data.json()));
        return jsonPromise.then((json => ({
            data: json,
            state: "success"
        }))).catch((() => ({
            data: null,
            state: "fail"
        }))), jsonPromise;
    }
    loadArrayBuffer(url) {
        return fetch(url).then((data => data.arrayBuffer())).then((arrayBuffer => ({
            data: arrayBuffer,
            loadState: "success"
        }))).catch((() => ({
            data: null,
            loadState: "fail"
        })));
    }
    loadImage(url) {
        const {loadImage: loadImage} = this.pkg;
        return loadImage ? loadImage(url).then((image => ({
            loadState: image ? "success" : "fail",
            data: image
        }))).catch((() => ({
            loadState: "fail",
            data: null
        }))) : Promise.reject(new Error("node-canvas loadImage could not be found!"));
    }
    loadSvg(svgStr) {
        const Resvg = this.pkg.Resvg;
        if (!Resvg) return Promise.reject(new Error("@resvg/resvg-js svgParser could not be found!"));
        const pngData = new Resvg(svgStr).render().asPng();
        return this.loadImage(pngData);
    }
    createCanvas(params) {
        return this.pkg.createCanvas(params.width, params.height);
    }
    releaseCanvas(canvas) {}
    getDevicePixelRatio() {
        return 1;
    }
    getRequestAnimationFrame() {
        return function(callback) {
            return setTimeout(callback, 1e3 / 60, !0);
        };
    }
    getCancelAnimationFrame() {
        return h => {
            clearTimeout(h);
        };
    }
    addEventListener(type, listener, options) {}
    removeEventListener(type, listener, options) {}
    getElementById(str) {
        return null;
    }
    getRootElement() {
        return null;
    }
    dispatchEvent(event) {}
    release(...params) {}
    createOffscreenCanvas(params) {}
};

NodeEnvContribution = __decorate([ (0, inversify_1.injectable)() ], NodeEnvContribution), 
exports.NodeEnvContribution = NodeEnvContribution;
//# sourceMappingURL=node-contribution.js.map

}, function(modId) { var map = {"./base-contribution":1689069767860}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767868, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), window_1 = require("../../window"), browser_contribution_1 = require("./browser-contribution"), feishu_contribution_1 = require("./feishu-contribution"), taro_contribution_1 = require("./taro-contribution"), lynx_contribution_1 = require("./lynx-contribution"), node_contribution_1 = require("./node-contribution");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(browser_contribution_1.BrowserWindowHandlerContribution).toSelf(), bind(window_1.WindowHandlerContribution).toDynamicValue((ctx => ctx.container.get(browser_contribution_1.BrowserWindowHandlerContribution))).whenTargetNamed(browser_contribution_1.BrowserWindowHandlerContribution.env), 
    bind(feishu_contribution_1.FeishuWindowHandlerContribution).toSelf(), bind(window_1.WindowHandlerContribution).toDynamicValue((ctx => ctx.container.get(feishu_contribution_1.FeishuWindowHandlerContribution))).whenTargetNamed(feishu_contribution_1.FeishuWindowHandlerContribution.env), 
    bind(taro_contribution_1.TaroWindowHandlerContribution).toSelf(), bind(window_1.WindowHandlerContribution).toDynamicValue((ctx => ctx.container.get(taro_contribution_1.TaroWindowHandlerContribution))).whenTargetNamed(taro_contribution_1.TaroWindowHandlerContribution.env), 
    bind(lynx_contribution_1.LynxWindowHandlerContribution).toSelf(), bind(window_1.WindowHandlerContribution).toDynamicValue((ctx => ctx.container.get(lynx_contribution_1.LynxWindowHandlerContribution))).whenTargetNamed(lynx_contribution_1.LynxWindowHandlerContribution.env), 
    bind(node_contribution_1.NodeWindowHandlerContribution).toSelf(), bind(window_1.WindowHandlerContribution).toDynamicValue((ctx => ctx.container.get(node_contribution_1.NodeWindowHandlerContribution))).whenTargetNamed(node_contribution_1.NodeWindowHandlerContribution.env);
}));
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"../../window":1689069767746,"./browser-contribution":1689069767869,"./feishu-contribution":1689069767871,"./taro-contribution":1689069767875,"./lynx-contribution":1689069767879,"./node-contribution":1689069767883}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767869, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BrowserWindowHandlerContribution = void 0;

const inversify_1 = require("inversify"), browser_1 = require("../../../canvas/contributions/browser"), generator_1 = require("../../../common/generator"), base_contribution_1 = require("./base-contribution"), constants_1 = require("../../../constants");

let BrowserWindowHandlerContribution = class extends base_contribution_1.BaseWindowHandlerContribution {
    get container() {
        return this.canvas.nativeCanvas.parentElement;
    }
    constructor(global) {
        super(), this.global = global, this.type = "browser";
    }
    getTitle() {
        return this.canvas.id.toString();
    }
    getWH() {
        return {
            width: this.canvas.width / (this.canvas.dpr || 1),
            height: this.canvas.height / (this.canvas.dpr || 1)
        };
    }
    getXY() {
        return this.canvas.nativeCanvas.getBoundingClientRect();
    }
    createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
    }
    createWindowByConfig(params) {
        const nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
        });
        let container;
        if (container = "string" == typeof params.container ? this.global.getElementById(params.container) : params.container ? params.container : this.global.getRootElement(), 
        !container) throw new Error("发生错误，containerId可能传入有误");
        params.offscreen ? container = null : container.appendChild(nativeCanvas);
        const options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            container: container,
            id: generator_1.Generator.GenAutoIncrementId().toString(),
            canvasControled: !0
        };
        this.canvas = new browser_1.BrowserCanvas(options);
    }
    createWindowByCanvas(params) {
        var _a;
        let canvas;
        if ("string" == typeof params.canvas) {
            if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        if (!canvas) throw new Error("发生错误，传入的canvas不正确");
        let width = params.width, height = params.height;
        if (null == width || null == height || !params.canvasControled) {
            const data = canvas.getBoundingClientRect();
            width = data.width, height = data.height;
        }
        let dpr = params.dpr;
        if (!1 === params.canvasControled && (dpr && console.warn("canvasControled为false后，dpr参数将无效"), 
        dpr = null), null == dpr) {
            dpr = null !== (_a = canvas.getContext("2d").pixelRatio) && void 0 !== _a ? _a : canvas.width / width;
        }
        this.canvas = new browser_1.BrowserCanvas({
            width: width,
            height: height,
            dpr: dpr,
            nativeCanvas: canvas,
            canvasControled: params.canvasControled
        });
    }
    releaseWindow() {
        this.canvas.release();
    }
    resizeWindow(width, height) {
        this.canvas.resize(width, height);
    }
    setDpr(dpr) {
        this.canvas.dpr = dpr;
    }
    getContext() {
        return this.canvas.getContext();
    }
    getNativeHandler() {
        return this.canvas;
    }
    getDpr() {
        return this.canvas.dpr;
    }
    addEventListener(type, listener, options) {
        return this.canvas.nativeCanvas.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
        return this.canvas.nativeCanvas.removeEventListener(type, listener, options);
    }
    dispatchEvent(event) {
        return this.canvas.nativeCanvas.dispatchEvent(event);
    }
    getStyle() {
        return this.canvas.nativeCanvas.style;
    }
    setStyle(style) {
        this.canvas.nativeCanvas.style = style;
    }
    getBoundingClientRect() {
        const c = this.canvas.nativeCanvas, wh = this.getWH();
        return c.parentElement ? this.canvas.nativeCanvas.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: wh.width,
            height: wh.height,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
    }
    clearViewBox(vb, color) {
        const context = this.getContext(), dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), 
        context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, 
        context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
    }
};

BrowserWindowHandlerContribution.env = "browser", BrowserWindowHandlerContribution = __decorate([ (0, 
inversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata("design:paramtypes", [ Object ]) ], BrowserWindowHandlerContribution), 
exports.BrowserWindowHandlerContribution = BrowserWindowHandlerContribution;
//# sourceMappingURL=browser-contribution.js.map

}, function(modId) { var map = {"../../../canvas/contributions/browser":1689069767845,"../../../common/generator":1689069767711,"./base-contribution":1689069767870,"../../../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767870, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseWindowHandlerContribution = void 0;

const inversify_1 = require("inversify"), generator_1 = require("../../../common/generator");

let BaseWindowHandlerContribution = class {
    constructor() {
        this._uid = generator_1.Generator.GenAutoIncrementId();
    }
    onChange(cb) {
        this._onChangeCb = cb;
    }
    configure(window, global) {
        global.env === this.type && window.setWindowHandler(this);
    }
    release(...params) {
        this.releaseWindow();
    }
};

BaseWindowHandlerContribution = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", []) ], BaseWindowHandlerContribution), 
exports.BaseWindowHandlerContribution = BaseWindowHandlerContribution;
//# sourceMappingURL=base-contribution.js.map

}, function(modId) { var map = {"../../../common/generator":1689069767711}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767871, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.FeishuWindowHandlerContribution = void 0;

const inversify_1 = require("inversify"), feishu_1 = require("../../../canvas/contributions/feishu"), generator_1 = require("../../../common/generator"), base_contribution_1 = require("./base-contribution"), constants_1 = require("../../../constants");

class MiniAppEventManager {
    constructor() {
        this.cache = {};
    }
    addEventListener(type, func) {
        type && func && (this.cache[type] = this.cache[type] || {
            listener: []
        }, this.cache[type].listener.push(func));
    }
    removeEventListener(type, func) {
        if (!type || !func) return;
        if (!this.cache[type]) return;
        const index = this.cache[type].listener.findIndex((f => f === func));
        index >= 0 && this.cache[type].listener.splice(index, 1);
    }
    cleanEvent() {
        this.cache = {};
    }
}

let FeishuWindowHandlerContribution = class extends base_contribution_1.BaseWindowHandlerContribution {
    get container() {
        return null;
    }
    constructor(global) {
        super(), this.global = global, this.type = "feishu", this.eventManager = new MiniAppEventManager;
    }
    getTitle() {
        return this.canvas.id.toString();
    }
    getWH() {
        return {
            width: this.canvas.width / (this.canvas.dpr || 1),
            height: this.canvas.height / (this.canvas.dpr || 1)
        };
    }
    getXY() {
        return {
            x: 0,
            y: 0
        };
    }
    createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
    }
    createWindowByConfig(params) {
        const nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
        }), options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: generator_1.Generator.GenAutoIncrementId().toString(),
            canvasControled: !1
        };
        this.canvas = new feishu_1.FeishuCanvas(options);
    }
    createWindowByCanvas(params) {
        let canvas;
        if ("string" == typeof params.canvas) {
            if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        let width = params.width, height = params.height;
        if (null == width || null == height || !params.canvasControled) {
            const data = canvas.getBoundingClientRect();
            width = data.width, height = data.height;
        }
        let dpr = params.dpr;
        null == dpr && (dpr = canvas.width / width), this.canvas = new feishu_1.FeishuCanvas({
            width: width,
            height: height,
            dpr: dpr,
            nativeCanvas: canvas,
            canvasControled: params.canvasControled
        });
    }
    releaseWindow() {}
    resizeWindow(width, height) {}
    setDpr(dpr) {
        this.canvas.dpr = dpr;
    }
    getContext() {
        return this.canvas.getContext();
    }
    getNativeHandler() {
        return this.canvas;
    }
    getDpr() {
        return this.canvas.dpr;
    }
    addEventListener(type, listener) {
        this.eventManager.addEventListener(type, listener);
    }
    removeEventListener(type, listener) {
        this.eventManager.removeEventListener(type, listener);
    }
    dispatchEvent(event) {
        const {type: type} = event;
        return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, 
        event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, 
        event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, 
        event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {}, 
        event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f => {
            f(event);
        })), !0);
    }
    getStyle() {
        return {};
    }
    setStyle(style) {}
    getBoundingClientRect() {
        const wh = this.getWH();
        return {
            x: 0,
            y: 0,
            width: wh.width,
            height: wh.height,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
    }
    clearViewBox(vb, color) {
        const context = this.getContext(), dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), 
        context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, 
        context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
    }
};

FeishuWindowHandlerContribution.env = "feishu", FeishuWindowHandlerContribution = __decorate([ (0, 
inversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata("design:paramtypes", [ Object ]) ], FeishuWindowHandlerContribution), 
exports.FeishuWindowHandlerContribution = FeishuWindowHandlerContribution;
//# sourceMappingURL=feishu-contribution.js.map

}, function(modId) { var map = {"../../../canvas/contributions/feishu":1689069767872,"../../../common/generator":1689069767711,"./base-contribution":1689069767870,"../../../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767872, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./canvas"), exports), __exportStar(require("./context"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./canvas":1689069767873,"./context":1689069767874}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767873, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.FeishuCanvas = void 0;

const inversify_1 = require("inversify"), context_1 = require("./context"), DefaultConfig = {
    WIDTH: 500,
    HEIGHT: 500,
    DPR: 1
};

let FeishuCanvas = class {
    get id() {
        return this._id;
    }
    get x() {
        return this._x;
    }
    get y() {
        return this._y;
    }
    get nativeCanvas() {
        return this._nativeCanvas;
    }
    get width() {
        return this._pixelWidth;
    }
    set width(width) {
        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
    }
    get height() {
        return this._pixelHeight;
    }
    set height(height) {
        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
    }
    get displayWidth() {
        return this._displayWidth;
    }
    get displayHeight() {
        return this._displayHeight;
    }
    getContext(str) {
        return this._context;
    }
    get visiable() {
        return this._visiable;
    }
    set visiable(visiable) {
        this._visiable = visiable, visiable ? this.show() : this.hide();
    }
    get dpr() {
        return this._dpr;
    }
    set dpr(dpr) {
        this._dpr = dpr;
    }
    constructor(params) {
        const {nativeCanvas: nativeCanvas, width: width = DefaultConfig.WIDTH, height: height = DefaultConfig.HEIGHT, dpr: dpr = DefaultConfig.DPR} = params, {x: x, y: y} = nativeCanvas.getBoundingClientRect ? nativeCanvas.getBoundingClientRect() : {
            x: 0,
            y: 0
        };
        this._x = x, this._y = y, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, 
        this._visiable = !1 !== params.visiable, this._displayWidth = width, this._displayHeight = height, 
        this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._context = new context_1.FeishuContext2d(this, this._dpr), 
        this._id = nativeCanvas.id;
    }
    getNativeCanvas() {
        return this._nativeCanvas;
    }
    resetStyle(params) {}
    applyPosition() {}
    hide() {}
    show() {}
    resize(width, height) {}
    toDataURL(mimeType, quality) {
        return "";
    }
    readPixels(x, y, w, h) {
        throw new Error("暂未实现");
    }
    convertToBlob(options) {
        throw new Error("暂未实现");
    }
    transferToImageBitmap() {
        throw new Error("暂未实现");
    }
    release(...params) {}
};

FeishuCanvas.env = "feishu", FeishuCanvas = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", [ Object ]) ], FeishuCanvas), 
exports.FeishuCanvas = FeishuCanvas;
//# sourceMappingURL=canvas.js.map

}, function(modId) { var map = {"./context":1689069767874}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767874, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.FeishuContext2d = void 0;

const inversify_1 = require("inversify"), browser_1 = require("../browser");

let FeishuContext2d = class extends browser_1.BrowserContext2d {
    get globalAlpha() {
        return this._globalAlpha;
    }
    set globalAlpha(ga) {
        this.nativeContext.globalAlpha = ga, this._globalAlpha = ga;
    }
    getImageData(sx, sy, sw, sh) {
        return new Promise(((resolve, reject) => {
            var _a;
            try {
                tt.canvasGetImageData({
                    canvasId: null !== (_a = this.canvas.nativeCanvas.id) && void 0 !== _a ? _a : this.canvas.id,
                    x: sx,
                    y: sy,
                    width: sw,
                    height: sh,
                    success(res) {
                        resolve(res);
                    }
                });
            } catch (err) {
                reject(err);
            }
        }));
    }
    draw() {
        const _context = this.nativeContext;
        this.drawPromise = new Promise((resolve => {
            _context.draw(!0, (() => {
                this.drawPromise = null, resolve(null);
            }));
        }));
    }
};

FeishuContext2d.env = "feishu", FeishuContext2d = __decorate([ (0, inversify_1.injectable)() ], FeishuContext2d), 
exports.FeishuContext2d = FeishuContext2d;
//# sourceMappingURL=context.js.map

}, function(modId) { var map = {"../browser":1689069767845}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767875, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TaroWindowHandlerContribution = void 0;

const inversify_1 = require("inversify"), taro_1 = require("../../../canvas/contributions/taro"), generator_1 = require("../../../common/generator"), base_contribution_1 = require("./base-contribution"), constants_1 = require("../../../constants");

class MiniAppEventManager {
    constructor() {
        this.cache = {};
    }
    addEventListener(type, func) {
        type && func && (this.cache[type] = this.cache[type] || {
            listener: []
        }, this.cache[type].listener.push(func));
    }
    removeEventListener(type, func) {
        if (!type || !func) return;
        if (!this.cache[type]) return;
        const index = this.cache[type].listener.findIndex((f => f === func));
        index >= 0 && this.cache[type].listener.splice(index, 1);
    }
    cleanEvent() {
        this.cache = {};
    }
}

let TaroWindowHandlerContribution = class extends base_contribution_1.BaseWindowHandlerContribution {
    get container() {
        return null;
    }
    constructor(global) {
        super(), this.global = global, this.type = "taro", this.eventManager = new MiniAppEventManager;
    }
    getTitle() {
        return this.canvas.id.toString();
    }
    getWH() {
        return {
            width: this.canvas.width / (this.canvas.dpr || 1),
            height: this.canvas.height / (this.canvas.dpr || 1)
        };
    }
    getXY() {
        return {
            x: 0,
            y: 0
        };
    }
    createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
    }
    createWindowByConfig(params) {
        const nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
        }), options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: generator_1.Generator.GenAutoIncrementId().toString(),
            canvasControled: !1
        };
        this.canvas = new taro_1.TaroCanvas(options);
    }
    createWindowByCanvas(params) {
        let canvas;
        if ("string" == typeof params.canvas) {
            if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        let width = params.width, height = params.height;
        if (null == width || null == height || !params.canvasControled) {
            const data = canvas.getBoundingClientRect();
            width = data.width, height = data.height;
        }
        let dpr = params.dpr;
        null == dpr && (dpr = canvas.width / width), this.canvas = new taro_1.TaroCanvas({
            width: width,
            height: height,
            dpr: dpr,
            nativeCanvas: canvas,
            canvasControled: params.canvasControled
        });
    }
    releaseWindow() {}
    resizeWindow(width, height) {}
    setDpr(dpr) {
        this.canvas.dpr = dpr;
    }
    getContext() {
        return this.canvas.getContext();
    }
    getNativeHandler() {
        return this.canvas;
    }
    getDpr() {
        return this.canvas.dpr;
    }
    addEventListener(type, listener) {
        this.eventManager.addEventListener(type, listener);
    }
    removeEventListener(type, listener) {
        this.eventManager.removeEventListener(type, listener);
    }
    dispatchEvent(event) {
        const {type: type} = event;
        return !!this.eventManager.cache[type] && (event.changedTouches.length > 0 && (event.changedTouches.forEach(((d, i) => {
            event.changedTouches[i] = Object.assign(Object.assign({}, event.changedTouches[i]), {
                offsetX: d.x,
                offsetY: d.y
            });
        })), event.offsetX = event.changedTouches[0].offsetX, event.offsetY = event.changedTouches[0].offsetY), 
        event.touches.length > 0 && event.touches.forEach(((d, i) => {
            event.touches[i] = Object.assign(Object.assign({}, event.touches[i]), {
                offsetX: d.x,
                offsetY: d.y
            });
        })), event.preventDefault = () => {}, event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f => {
            f(event);
        })), !0);
    }
    getStyle() {
        return {};
    }
    setStyle(style) {}
    getBoundingClientRect() {
        const wh = this.getWH();
        return {
            x: 0,
            y: 0,
            width: wh.width,
            height: wh.height,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
    }
    clearViewBox(vb, color) {
        const context = this.getContext(), dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), 
        context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, 
        context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
    }
};

TaroWindowHandlerContribution.env = "taro", TaroWindowHandlerContribution = __decorate([ (0, 
inversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata("design:paramtypes", [ Object ]) ], TaroWindowHandlerContribution), 
exports.TaroWindowHandlerContribution = TaroWindowHandlerContribution;
//# sourceMappingURL=taro-contribution.js.map

}, function(modId) { var map = {"../../../canvas/contributions/taro":1689069767876,"../../../common/generator":1689069767711,"./base-contribution":1689069767870,"../../../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767876, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./canvas"), exports), __exportStar(require("./context"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./canvas":1689069767877,"./context":1689069767878}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767877, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TaroCanvas = void 0;

const inversify_1 = require("inversify"), context_1 = require("./context"), DefaultConfig = {
    WIDTH: 500,
    HEIGHT: 500,
    DPR: 1
};

let TaroCanvas = class {
    get id() {
        return this._id;
    }
    get x() {
        return this._x;
    }
    get y() {
        return this._y;
    }
    get nativeCanvas() {
        return this._nativeCanvas;
    }
    get width() {
        return this._pixelWidth;
    }
    set width(width) {
        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
    }
    get height() {
        return this._pixelHeight;
    }
    set height(height) {
        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
    }
    get displayWidth() {
        return this._displayWidth;
    }
    get displayHeight() {
        return this._displayHeight;
    }
    getContext(str) {
        return this._context;
    }
    get visiable() {
        return this._visiable;
    }
    set visiable(visiable) {
        this._visiable = visiable, visiable ? this.show() : this.hide();
    }
    get dpr() {
        return this._dpr;
    }
    set dpr(dpr) {
        this._dpr = dpr;
    }
    constructor(params) {
        const {nativeCanvas: nativeCanvas, width: width = DefaultConfig.WIDTH, height: height = DefaultConfig.HEIGHT, dpr: dpr = DefaultConfig.DPR} = params, {x: x, y: y} = nativeCanvas.getBoundingClientRect ? nativeCanvas.getBoundingClientRect() : {
            x: 0,
            y: 0
        };
        this._x = x, this._y = y, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, 
        this._visiable = !1 !== params.visiable, this._displayWidth = width, this._displayHeight = height, 
        this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._context = new context_1.TaroContext2d(this, this._dpr), 
        this._id = nativeCanvas.id;
    }
    getNativeCanvas() {
        return this._nativeCanvas;
    }
    resetStyle(params) {}
    applyPosition() {}
    hide() {}
    show() {}
    resize(width, height) {}
    toDataURL(mimeType, quality) {
        return "";
    }
    readPixels(x, y, w, h) {
        throw new Error("暂未实现");
    }
    convertToBlob(options) {
        throw new Error("暂未实现");
    }
    transferToImageBitmap() {
        throw new Error("暂未实现");
    }
    release(...params) {}
};

TaroCanvas.env = "taro", TaroCanvas = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", [ Object ]) ], TaroCanvas), 
exports.TaroCanvas = TaroCanvas;
//# sourceMappingURL=canvas.js.map

}, function(modId) { var map = {"./context":1689069767878}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767878, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TaroContext2d = void 0;

const inversify_1 = require("inversify"), browser_1 = require("../browser"), canvas_utils_1 = require("../../../common/canvas-utils"), text_1 = require("../../../common/text");

let TaroContext2d = class extends browser_1.BrowserContext2d {
    get globalAlpha() {
        return this._globalAlpha;
    }
    set globalAlpha(ga) {
        this.nativeContext.setGlobalAlpha(ga), this._globalAlpha = ga;
    }
    draw() {
        this.nativeContext.draw();
    }
    strokeText(text, x, y) {}
    _setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.fillAttributes);
        const {fillOpacity: fillOpacity = defaultParams.fillOpacity, opacity: opacity = defaultParams.opacity, fill: fill = defaultParams.fill} = attribute;
        fillOpacity > 1e-12 && opacity > 1e-12 && (_context.setGlobalAlpha(fillOpacity * opacity), 
        _context.setFillStyle((0, canvas_utils_1.createColor)(this, fill, params, offsetX, offsetY)));
    }
    _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.strokeAttributes);
        const {strokeOpacity: strokeOpacity = defaultParams.strokeOpacity, opacity: opacity = defaultParams.opacity} = attribute;
        if (strokeOpacity > 1e-12 && opacity > 1e-12) {
            const {lineWidth: lineWidth = defaultParams.lineWidth, stroke: stroke = defaultParams.stroke, lineJoin: lineJoin = defaultParams.lineJoin, lineDash: lineDash = defaultParams.lineDash, lineCap: lineCap = defaultParams.lineCap, miterLimit: miterLimit = defaultParams.miterLimit} = attribute;
            _context.setGlobalAlpha(strokeOpacity * opacity), _context.setLineWidth((0, canvas_utils_1.getScaledStroke)(this, lineWidth, this.dpr)), 
            _context.setStrokeStyle((0, canvas_utils_1.createColor)(this, stroke, params, offsetX, offsetY)), 
            _context.setLineJoin(lineJoin), _context.setLineDash(lineDash), _context.setLineCap(lineCap), 
            _context.setMiterLimit(miterLimit);
        }
    }
    setTextStyleWithoutAlignBaseline(params, defaultParams) {
        var _a;
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = (0, 
        text_1.getContextFont)(params, defaultParams), _context.setFontSize(null !== (_a = params.fontSize) && void 0 !== _a ? _a : defaultParams.fontSize);
    }
    setTextStyle(params, defaultParams) {
        var _a, _b;
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = (0, 
        text_1.getContextFont)(params, defaultParams), _context.setTextAlign(null !== (_a = params.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign), 
        _context.setTextBaseline(null !== (_b = params.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline);
    }
    createConicGradient(x, y, startAngle, endAngle) {
        return null;
    }
};

TaroContext2d.env = "taro", TaroContext2d = __decorate([ (0, inversify_1.injectable)() ], TaroContext2d), 
exports.TaroContext2d = TaroContext2d;
//# sourceMappingURL=context.js.map

}, function(modId) { var map = {"../browser":1689069767845,"../../../common/canvas-utils":1689069767755,"../../../common/text":1689069767760}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767879, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LynxWindowHandlerContribution = void 0;

const inversify_1 = require("inversify"), lynx_1 = require("../../../canvas/contributions/lynx"), generator_1 = require("../../../common/generator"), base_contribution_1 = require("./base-contribution"), constants_1 = require("../../../constants");

class MiniAppEventManager {
    constructor() {
        this.cache = {};
    }
    addEventListener(type, func) {
        type && func && (this.cache[type] = this.cache[type] || {
            listener: []
        }, this.cache[type].listener.push(func));
    }
    removeEventListener(type, func) {
        if (!type || !func) return;
        if (!this.cache[type]) return;
        const index = this.cache[type].listener.findIndex((f => f === func));
        index >= 0 && this.cache[type].listener.splice(index, 1);
    }
    cleanEvent() {
        this.cache = {};
    }
}

let LynxWindowHandlerContribution = class extends base_contribution_1.BaseWindowHandlerContribution {
    get container() {
        return null;
    }
    constructor(global) {
        super(), this.global = global, this.type = "lynx", this.eventManager = new MiniAppEventManager;
    }
    getTitle() {
        return this.canvas.id.toString();
    }
    getWH() {
        return {
            width: this.canvas.width / (this.canvas.dpr || 1),
            height: this.canvas.height / (this.canvas.dpr || 1)
        };
    }
    getXY() {
        return {
            x: 0,
            y: 0
        };
    }
    createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
    }
    createWindowByConfig(params) {
        const nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
        }), options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: generator_1.Generator.GenAutoIncrementId().toString(),
            canvasControled: !1
        };
        this.canvas = new lynx_1.LynxCanvas(options);
    }
    createWindowByCanvas(params) {
        let canvas;
        if ("string" == typeof params.canvas) {
            if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        let width = params.width, height = params.height;
        if (null == width || null == height || !params.canvasControled) {
            const data = canvas.getBoundingClientRect();
            width = data.width, height = data.height;
        }
        let dpr = params.dpr;
        null == dpr && (dpr = canvas.width / width), this.canvas = new lynx_1.LynxCanvas({
            width: width,
            height: height,
            dpr: dpr,
            nativeCanvas: canvas,
            canvasControled: params.canvasControled
        });
    }
    releaseWindow() {}
    resizeWindow(width, height) {}
    setDpr(dpr) {
        this.canvas.dpr = dpr;
    }
    getContext() {
        return this.canvas.getContext();
    }
    getNativeHandler() {
        return this.canvas;
    }
    getDpr() {
        return this.canvas.dpr;
    }
    addEventListener(type, listener) {
        this.eventManager.addEventListener(type, listener);
    }
    removeEventListener(type, listener) {
        this.eventManager.removeEventListener(type, listener);
    }
    dispatchEvent(event) {
        const {type: type} = event;
        return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, 
        event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, 
        event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, 
        event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {}, 
        event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f => {
            f(event);
        })), !0);
    }
    getStyle() {
        return {};
    }
    setStyle(style) {}
    getBoundingClientRect() {
        const wh = this.getWH();
        return {
            x: 0,
            y: 0,
            width: wh.width,
            height: wh.height,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
    }
    clearViewBox(vb, color) {
        const context = this.getContext(), dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), 
        context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, 
        context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
    }
};

LynxWindowHandlerContribution.env = "lynx", LynxWindowHandlerContribution = __decorate([ (0, 
inversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata("design:paramtypes", [ Object ]) ], LynxWindowHandlerContribution), 
exports.LynxWindowHandlerContribution = LynxWindowHandlerContribution;
//# sourceMappingURL=lynx-contribution.js.map

}, function(modId) { var map = {"../../../canvas/contributions/lynx":1689069767880,"../../../common/generator":1689069767711,"./base-contribution":1689069767870,"../../../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767880, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./canvas"), exports), __exportStar(require("./context"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./canvas":1689069767881,"./context":1689069767882}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767881, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LynxCanvas = void 0;

const inversify_1 = require("inversify"), context_1 = require("./context"), DefaultConfig = {
    WIDTH: 500,
    HEIGHT: 500,
    DPR: 1
};

let LynxCanvas = class {
    get id() {
        return this._id;
    }
    get x() {
        return this._x;
    }
    get y() {
        return this._y;
    }
    get nativeCanvas() {
        return this._nativeCanvas;
    }
    get width() {
        return this._pixelWidth;
    }
    set width(width) {
        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
    }
    get height() {
        return this._pixelHeight;
    }
    set height(height) {
        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
    }
    get displayWidth() {
        return this._displayWidth;
    }
    get displayHeight() {
        return this._displayHeight;
    }
    getContext(str) {
        return this._context;
    }
    get visiable() {
        return this._visiable;
    }
    set visiable(visiable) {
        this._visiable = visiable, visiable ? this.show() : this.hide();
    }
    get dpr() {
        return this._dpr;
    }
    set dpr(dpr) {
        this._dpr = dpr;
    }
    constructor(params) {
        const {nativeCanvas: nativeCanvas, width: width = DefaultConfig.WIDTH, height: height = DefaultConfig.HEIGHT, dpr: dpr = DefaultConfig.DPR} = params, {x: x, y: y} = nativeCanvas.getBoundingClientRect ? nativeCanvas.getBoundingClientRect() : {
            x: 0,
            y: 0
        };
        this._x = x, this._y = y, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, 
        this._visiable = !1 !== params.visiable, this._displayWidth = width, this._displayHeight = height, 
        this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._context = new context_1.LynxContext2d(this, this._dpr), 
        this._id = nativeCanvas.id;
    }
    getNativeCanvas() {
        return this._nativeCanvas;
    }
    resetStyle(params) {}
    applyPosition() {}
    hide() {}
    show() {}
    resize(width, height) {}
    toDataURL(mimeType, quality) {
        return "";
    }
    readPixels(x, y, w, h) {
        throw new Error("暂未实现");
    }
    convertToBlob(options) {
        throw new Error("暂未实现");
    }
    transferToImageBitmap() {
        throw new Error("暂未实现");
    }
    release(...params) {}
};

LynxCanvas.env = "lynx", LynxCanvas = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", [ Object ]) ], LynxCanvas), 
exports.LynxCanvas = LynxCanvas;
//# sourceMappingURL=canvas.js.map

}, function(modId) { var map = {"./context":1689069767882}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767882, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LynxContext2d = void 0;

const inversify_1 = require("inversify"), browser_1 = require("../browser");

let LynxContext2d = class extends browser_1.BrowserContext2d {
    get globalAlpha() {
        return this._globalAlpha;
    }
    set globalAlpha(ga) {
        this.nativeContext.globalAlpha = ga, this._globalAlpha = ga;
    }
    setLineDash(segments) {
        const a = arguments, _context = this.nativeContext;
        if (this.nativeContext.setLineDash) {
            const lineDash = a[0];
            if (0 === lineDash[0] && 0 === lineDash[1]) return;
            _context.setLineDash(lineDash);
        }
    }
    draw() {
        const _context = this.nativeContext;
        this.drawPromise = new Promise((resolve => {
            _context.draw(!0, (() => {
                this.drawPromise = null, resolve(null);
            }));
        }));
    }
};

LynxContext2d.env = "lynx", LynxContext2d = __decorate([ (0, inversify_1.injectable)() ], LynxContext2d), 
exports.LynxContext2d = LynxContext2d;
//# sourceMappingURL=context.js.map

}, function(modId) { var map = {"../browser":1689069767845}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767883, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.NodeWindowHandlerContribution = void 0;

const inversify_1 = require("inversify"), node_1 = require("../../../canvas/contributions/node"), generator_1 = require("../../../common/generator"), base_contribution_1 = require("./base-contribution"), constants_1 = require("../../../constants");

let NodeWindowHandlerContribution = class extends base_contribution_1.BaseWindowHandlerContribution {
    get container() {
        return null;
    }
    constructor(global) {
        super(), this.global = global, this.type = "node";
    }
    getTitle() {
        return "";
    }
    getWH() {
        return {
            width: this.canvas.displayWidth,
            height: this.canvas.displayHeight
        };
    }
    getXY() {
        return {
            x: 0,
            y: 0
        };
    }
    createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
    }
    createWindowByConfig(params) {
        const nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
        }), options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: generator_1.Generator.GenAutoIncrementId().toString(),
            canvasControled: !0
        };
        this.canvas = new node_1.NodeCanvas(options);
    }
    createWindowByCanvas(params) {
        const canvas = params.canvas;
        let width = params.width, height = params.height;
        null != width && null != height && params.canvasControled || (width = canvas.width, 
        height = canvas.height), this.canvas = new node_1.NodeCanvas({
            width: width,
            height: height,
            dpr: 1,
            nativeCanvas: canvas,
            canvasControled: params.canvasControled
        });
    }
    releaseWindow() {
        this.canvas.release();
    }
    resizeWindow(width, height) {
        this.canvas.resize(width, height);
    }
    setDpr(dpr) {
        this.canvas.dpr = dpr;
    }
    getContext() {
        return this.canvas.getContext();
    }
    getNativeHandler() {
        return this.canvas;
    }
    getDpr() {
        return this.canvas.dpr;
    }
    getImageBuffer(type = "image/png") {
        return this.canvas.nativeCanvas.toBuffer(type);
    }
    addEventListener(type, listener, options) {}
    dispatchEvent(event) {
        return !0;
    }
    removeEventListener(type, listener, options) {}
    getStyle() {}
    setStyle(style) {}
    getBoundingClientRect() {
        return null;
    }
    clearViewBox(vb, color) {}
};

NodeWindowHandlerContribution.env = "node", NodeWindowHandlerContribution = __decorate([ (0, 
inversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata("design:paramtypes", [ Object ]) ], NodeWindowHandlerContribution), 
exports.NodeWindowHandlerContribution = NodeWindowHandlerContribution;
//# sourceMappingURL=node-contribution.js.map

}, function(modId) { var map = {"../../../canvas/contributions/node":1689069767884,"../../../common/generator":1689069767711,"./base-contribution":1689069767870,"../../../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767884, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./canvas"), exports), __exportStar(require("./context"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./canvas":1689069767885,"./context":1689069767886}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767885, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.NodeCanvas = void 0;

const inversify_1 = require("inversify"), context_1 = require("./context"), vutils_1 = require("@visactor/vutils"), DefaultConfig = {
    WIDTH: 500,
    HEIGHT: 500,
    DPR: 1
};

let NodeCanvas = class {
    get id() {
        return this._id;
    }
    get x() {
        return 0;
    }
    get y() {
        return 0;
    }
    get nativeCanvas() {
        return this._nativeCanvas;
    }
    get width() {
        return this._pixelWidth;
    }
    set width(width) {
        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
    }
    get displayWidth() {
        return this._pixelWidth / this._dpr;
    }
    get displayHeight() {
        return this._pixelHeight / this._dpr;
    }
    get height() {
        return this._pixelHeight;
    }
    set height(height) {
        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
    }
    getContext(str) {
        return this._context;
    }
    get visiable() {
        return this._visiable;
    }
    set visiable(visiable) {
        this._visiable = visiable, visiable ? this.show() : this.hide();
    }
    get dpr() {
        return this._dpr;
    }
    set dpr(dpr) {
        this._dpr = dpr, this.resize(this.width, this.height);
    }
    constructor(params) {
        const {nativeCanvas: nativeCanvas, width: width = DefaultConfig.WIDTH, height: height = DefaultConfig.HEIGHT, canvasControled: canvasControled = !0, dpr: dpr = DefaultConfig.DPR} = params;
        this._visiable = !1 !== params.visiable, this.controled = canvasControled, this._pixelWidth = width * dpr, 
        this._pixelHeight = height * dpr, this._displayWidth = width, this._displayHeight = height, 
        this._nativeCanvas = nativeCanvas, this._context = new context_1.NodeContext2d(this, params.dpr), 
        this._id = nativeCanvas.id, this._dpr = dpr;
    }
    applyPosition() {}
    getNativeCanvas() {
        return this._nativeCanvas;
    }
    resetStyle(params) {}
    hide() {}
    show() {}
    resize(width, height) {
        this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, 
        this._displayHeight = height, this._nativeCanvas && (this._nativeCanvas.width = this._pixelWidth, 
        this._nativeCanvas.height = this._pixelHeight);
    }
    toDataURL(mimeType, quality) {
        return "";
    }
    readPixels(x, y, w, h) {
        return this._context.getImageData(x, y, w, h);
    }
    convertToBlob(options) {
        throw new Error("暂未实现");
    }
    transferToImageBitmap() {
        throw new Error("暂未实现");
    }
    release(...params) {
        this._nativeCanvas.release && (0, vutils_1.isFunction)(this._nativeCanvas.release) && this._nativeCanvas.release();
    }
};

NodeCanvas.env = "node", NodeCanvas = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", [ Object ]) ], NodeCanvas), 
exports.NodeCanvas = NodeCanvas;
//# sourceMappingURL=canvas.js.map

}, function(modId) { var map = {"./context":1689069767886}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767886, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.NodeContext2d = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), browser_1 = require("../browser"), initMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0);

let NodeContext2d = class extends browser_1.BrowserContext2d {
    constructor(canvas, dpr) {
        super(canvas, dpr);
        const context = canvas.nativeCanvas.getContext("2d");
        if (!context) throw new Error("发生错误，获取2d上下文失败");
        this.nativeContext = context, this.canvas = canvas, this.matrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), 
        this.stack = [], this.dpr = null != dpr ? dpr : 1;
    }
    release(...params) {}
};

NodeContext2d.env = "node", NodeContext2d = __decorate([ (0, inversify_1.injectable)(), __metadata("design:paramtypes", [ Object, Number ]) ], NodeContext2d), 
exports.NodeContext2d = NodeContext2d;
//# sourceMappingURL=context.js.map

}, function(modId) { var map = {"../browser":1689069767845}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767887, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), contribution_provider_1 = require("../../../common/contribution-provider"), textMeasure_contribution_1 = require("./textMeasure-contribution");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(textMeasure_contribution_1.DefaultTextMeasureContribution).toSelf().inSingletonScope(), 
    bind(textMeasure_contribution_1.TextMeasureContribution).toService(textMeasure_contribution_1.DefaultTextMeasureContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, textMeasure_contribution_1.TextMeasureContribution);
}));
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"../../../common/contribution-provider":1689069767672,"./textMeasure-contribution":1689069767678}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767888, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), layer_1 = require("../../layer"), canvas2d_contribution_1 = require("./canvas2d-contribution"), offscreen2d_contribution_1 = require("./offscreen2d-contribution");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(canvas2d_contribution_1.CanvasLayerHandlerContribution).toSelf(), bind(offscreen2d_contribution_1.OffscreenLayerHandlerContribution).toSelf(), 
    bind(layer_1.LayerHandlerContribution).toService(canvas2d_contribution_1.CanvasLayerHandlerContribution);
}));
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"../../layer":1689069767706,"./canvas2d-contribution":1689069767889,"./offscreen2d-contribution":1689069767890}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767889, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CanvasLayerHandlerContribution = void 0;

const inversify_1 = require("inversify"), util_1 = require("../../../canvas/util"), constants_1 = require("../../../constants");

let CanvasLayerHandlerContribution = class {
    constructor(global) {
        this.global = global, this.offscreen = !1;
    }
    init(layer, window, params) {
        if (this.layer = layer, params.main) this.context = window.getContext(), this.canvas = this.context.getCanvas(); else {
            let nativeCanvas;
            nativeCanvas = params.canvasId ? this.global.getElementById(params.canvasId) : this.global.createCanvas({
                width: window.width,
                height: window.height
            });
            const windowCanvas = window.getContext().getCanvas().nativeCanvas, canvas = (0, 
            util_1.wrapCanvas)({
                nativeCanvas: nativeCanvas,
                width: window.width,
                height: window.height,
                dpr: window.dpr,
                canvasControled: !0,
                container: window.getContainer(),
                x: windowCanvas.offsetLeft,
                y: windowCanvas.offsetTop
            });
            canvas.applyPosition(), this.canvas = canvas, this.context = canvas.getContext();
        }
    }
    resize(w, h) {
        this.canvas.resize(w, h);
    }
    resizeView(w, h) {}
    render(group, params, userParams) {
        var _a;
        params.renderService.render(group, Object.assign(Object.assign({
            context: this.context,
            clear: null !== (_a = params.background) && void 0 !== _a ? _a : "#ffffff"
        }, params), userParams));
    }
    merge(layerHandlers) {
        layerHandlers.forEach((l => {
            const canvas = l.getContext().canvas.nativeCanvas;
            this.context.drawImage(canvas, 0, 0);
        }));
    }
    prepare(dirtyBounds, params) {}
    drawTo(target, group, params) {
        var _a;
        const context = target.getContext();
        params.renderService.render(group, Object.assign(Object.assign({
            context: context
        }, params), {
            clear: params.clear ? null !== (_a = params.background) && void 0 !== _a ? _a : "#fff" : void 0
        }));
    }
    getContext() {
        return this.context;
    }
    release() {
        this.canvas.release();
    }
};

CanvasLayerHandlerContribution = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(constants_1.Global)), __metadata("design:paramtypes", [ Object ]) ], CanvasLayerHandlerContribution), 
exports.CanvasLayerHandlerContribution = CanvasLayerHandlerContribution;
//# sourceMappingURL=canvas2d-contribution.js.map

}, function(modId) { var map = {"../../../canvas/util":1689069767701,"../../../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767890, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.OffscreenLayerHandlerContribution = void 0;

const inversify_1 = require("inversify"), util_1 = require("../../../canvas/util"), constants_1 = require("../../../constants");

let OffscreenLayerHandlerContribution = class {
    constructor(global) {
        this.global = global, this.offscreen = !0;
    }
    init(layer, window, params) {
        this.layer = layer;
        const nativeCanvas = this.global.createOffscreenCanvas({
            width: params.width,
            height: params.height,
            dpr: window.dpr
        }), canvas = (0, util_1.wrapCanvas)({
            nativeCanvas: nativeCanvas,
            width: params.width,
            height: params.height,
            dpr: window.dpr,
            canvasControled: !0
        });
        this.canvas = canvas, this.context = canvas.getContext();
    }
    resize(w, h) {
        this.canvas.resize(w, h);
    }
    resizeView(w, h) {
        this.canvas.resize(w, h);
    }
    render(group, params) {
        var _a;
        params.renderService.render(group, Object.assign(Object.assign({
            context: this.context
        }, params), {
            x: 0,
            y: 0,
            clear: null !== (_a = params.background) && void 0 !== _a ? _a : "#ffffff"
        }));
    }
    prepare(dirtyBounds, params) {}
    release() {
        this.canvas.release();
    }
    getContext() {
        return this.context;
    }
    drawTo(target, group, params) {
        const context = target.getContext(), targetDpr = target.dpr, {x: x = 0, y: y = 0, width: width = this.layer.viewWidth, height: height = this.layer.viewHeight} = params;
        context.nativeContext.save(), context.nativeContext.setTransform(targetDpr, 0, 0, targetDpr, 0, 0), 
        params.clear && context.clearRect(x, y, width, height), context.drawImage(this.canvas.nativeCanvas, 0, 0, this.canvas.width, this.canvas.height, x, y, width, height), 
        context.nativeContext.restore();
    }
    merge(layerHandlers) {}
};

OffscreenLayerHandlerContribution = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(constants_1.Global)), __metadata("design:paramtypes", [ Object ]) ], OffscreenLayerHandlerContribution), 
exports.OffscreenLayerHandlerContribution = OffscreenLayerHandlerContribution;
//# sourceMappingURL=offscreen2d-contribution.js.map

}, function(modId) { var map = {"../../../canvas/util":1689069767701,"../../../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767891, function(require, module, exports) {


var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

const module_1 = __importDefault(require("./render/module"));

function load(container) {
    container.load(module_1.default);
}

exports.default = load;
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"./render/module":1689069767892}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767892, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), contribution_provider_1 = require("../../../common/contribution-provider"), circle_render_1 = require("./circle-render"), rect_render_1 = require("./rect-render"), arc_render_1 = require("./arc-render"), draw_contribution_1 = require("./draw-contribution"), render_slector_1 = require("./render-slector"), symbol_render_1 = require("./symbol-render"), text_render_1 = require("./text-render"), path_render_1 = require("./path-render"), line_render_1 = require("./line-render"), area_render_1 = require("./area-render"), group_render_1 = require("./group-render"), polygon_render_1 = require("./polygon-render"), image_render_1 = require("./image-render"), incremental_draw_contribution_1 = require("./incremental-draw-contribution"), symbol_1 = require("./symbol"), draw_interceptor_1 = require("./draw-interceptor"), rect3d_render_1 = require("./rect3d-render"), incremental_line_render_1 = require("./incremental-line-render"), incremental_area_render_1 = require("./incremental-area-render"), richtext_render_1 = require("./richtext-render"), rect_contribution_render_1 = require("./contributions/rect-contribution-render"), symbol_contribution_render_1 = require("./contributions/symbol-contribution-render"), circle_contribution_render_1 = require("./contributions/circle-contribution-render"), arc_contribution_render_1 = require("./contributions/arc-contribution-render"), glyph_render_1 = require("./glyph-render"), image_contribution_render_1 = require("./contributions/image-contribution-render"), group_contribution_render_1 = require("./contributions/group-contribution-render"), arc3d_render_1 = require("./arc3d-render"), pyramid3d_render_1 = require("./pyramid3d-render"), polygon_contribution_render_1 = require("./contributions/polygon-contribution-render"), path_contribution_render_1 = require("./contributions/path-contribution-render"), area_contribution_render_1 = require("./contributions/area-contribution-render");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(draw_contribution_1.DefaultDrawContribution).toSelf(), bind(symbol_1.DrawContribution).toService(draw_contribution_1.DefaultDrawContribution), 
    bind(incremental_draw_contribution_1.DefaultIncrementalDrawContribution).toSelf(), 
    bind(symbol_1.IncrementalDrawContribution).toService(incremental_draw_contribution_1.DefaultIncrementalDrawContribution), 
    bind(render_slector_1.DefaultRenderSelector).toSelf(), bind(symbol_1.RenderSelector).toService(render_slector_1.DefaultRenderSelector), 
    bind(circle_render_1.DefaultCanvasCircleRender).toSelf().inSingletonScope(), bind(symbol_1.CircleRender).to(circle_render_1.DefaultCanvasCircleRender), 
    bind(symbol_1.GraphicRender).to(circle_render_1.DefaultCanvasCircleRender), bind(circle_contribution_render_1.DefaultCircleRenderContribution).toSelf().inSingletonScope(), 
    bind(circle_contribution_render_1.DefaultCircleBackgroundRenderContribution).toSelf().inSingletonScope(), 
    bind(circle_contribution_render_1.DefaultCircleTextureRenderContribution).toSelf().inSingletonScope(), 
    bind(circle_contribution_render_1.CircleRenderContribution).toService(circle_contribution_render_1.DefaultCircleRenderContribution), 
    bind(circle_contribution_render_1.CircleRenderContribution).toService(circle_contribution_render_1.DefaultCircleBackgroundRenderContribution), 
    bind(circle_contribution_render_1.CircleRenderContribution).toService(circle_contribution_render_1.DefaultCircleTextureRenderContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, circle_contribution_render_1.CircleRenderContribution), 
    bind(rect_render_1.DefaultCanvasRectRender).toSelf().inSingletonScope(), bind(symbol_1.RectRender).to(rect_render_1.DefaultCanvasRectRender), 
    bind(symbol_1.GraphicRender).to(rect_render_1.DefaultCanvasRectRender), bind(rect3d_render_1.DefaultCanvasRect3dRender).toSelf().inSingletonScope(), 
    bind(symbol_1.Rect3DRender).toService(rect3d_render_1.DefaultCanvasRect3dRender), 
    bind(symbol_1.GraphicRender).toService(symbol_1.Rect3DRender), bind(rect_contribution_render_1.DefaultRectRenderContribution).toSelf().inSingletonScope(), 
    bind(rect_contribution_render_1.DefaultRectBackgroundRenderContribution).toSelf().inSingletonScope(), 
    bind(rect_contribution_render_1.DefaultRectTextureRenderContribution).toSelf().inSingletonScope(), 
    bind(rect_contribution_render_1.SplitRectBeforeRenderContribution).toSelf().inSingletonScope(), 
    bind(rect_contribution_render_1.SplitRectAfterRenderContribution).toSelf().inSingletonScope(), 
    bind(rect_contribution_render_1.RectRenderContribution).toService(rect_contribution_render_1.DefaultRectRenderContribution), 
    bind(rect_contribution_render_1.RectRenderContribution).toService(rect_contribution_render_1.DefaultRectBackgroundRenderContribution), 
    bind(rect_contribution_render_1.RectRenderContribution).toService(rect_contribution_render_1.DefaultRectTextureRenderContribution), 
    bind(rect_contribution_render_1.RectRenderContribution).toService(rect_contribution_render_1.SplitRectBeforeRenderContribution), 
    bind(rect_contribution_render_1.RectRenderContribution).toService(rect_contribution_render_1.SplitRectAfterRenderContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, rect_contribution_render_1.RectRenderContribution), 
    bind(text_render_1.DefaultCanvasTextRender).toSelf().inSingletonScope(), bind(symbol_1.TextRender).to(text_render_1.DefaultCanvasTextRender), 
    bind(symbol_1.GraphicRender).to(text_render_1.DefaultCanvasTextRender), bind(path_render_1.DefaultCanvasPathRender).toSelf().inSingletonScope(), 
    bind(symbol_1.PathRender).to(path_render_1.DefaultCanvasPathRender), bind(symbol_1.GraphicRender).to(path_render_1.DefaultCanvasPathRender), 
    bind(path_contribution_render_1.DefaultPathBackgroundRenderContribution).toSelf().inSingletonScope(), 
    bind(path_contribution_render_1.DefaultPathTextureRenderContribution).toSelf().inSingletonScope(), 
    bind(path_contribution_render_1.PathRenderContribution).toService(path_contribution_render_1.DefaultPathBackgroundRenderContribution), 
    bind(path_contribution_render_1.PathRenderContribution).toService(path_contribution_render_1.DefaultPathTextureRenderContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, path_contribution_render_1.PathRenderContribution), 
    bind(symbol_render_1.DefaultCanvasSymbolRender).toSelf().inSingletonScope(), bind(symbol_1.SymbolRender).to(symbol_render_1.DefaultCanvasSymbolRender), 
    bind(symbol_1.GraphicRender).to(symbol_render_1.DefaultCanvasSymbolRender), bind(symbol_contribution_render_1.DefaultSymbolRenderContribution).toSelf().inSingletonScope(), 
    bind(symbol_contribution_render_1.DefaultSymbolBackgroundRenderContribution).toSelf().inSingletonScope(), 
    bind(symbol_contribution_render_1.DefaultSymbolTextureRenderContribution).toSelf().inSingletonScope(), 
    bind(symbol_contribution_render_1.SymbolRenderContribution).toService(symbol_contribution_render_1.DefaultSymbolRenderContribution), 
    bind(symbol_contribution_render_1.SymbolRenderContribution).toService(symbol_contribution_render_1.DefaultSymbolBackgroundRenderContribution), 
    bind(symbol_contribution_render_1.SymbolRenderContribution).toService(symbol_contribution_render_1.DefaultSymbolTextureRenderContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, symbol_contribution_render_1.SymbolRenderContribution), 
    bind(arc_render_1.DefaultCanvasArcRender).toSelf().inSingletonScope(), bind(symbol_1.ArcRender).to(arc_render_1.DefaultCanvasArcRender), 
    bind(symbol_1.GraphicRender).to(arc_render_1.DefaultCanvasArcRender), bind(arc3d_render_1.DefaultCanvasArc3DRender).toSelf().inSingletonScope(), 
    bind(symbol_1.Arc3dRender).toService(arc3d_render_1.DefaultCanvasArc3DRender), bind(symbol_1.GraphicRender).toService(symbol_1.Arc3dRender), 
    bind(arc_contribution_render_1.DefaultArcRenderContribution).toSelf().inSingletonScope(), 
    bind(arc_contribution_render_1.DefaultArcBackgroundRenderContribution).toSelf().inSingletonScope(), 
    bind(arc_contribution_render_1.DefaultArcTextureRenderContribution).toSelf().inSingletonScope(), 
    bind(arc_contribution_render_1.ArcRenderContribution).toService(arc_contribution_render_1.DefaultArcRenderContribution), 
    bind(arc_contribution_render_1.ArcRenderContribution).toService(arc_contribution_render_1.DefaultArcBackgroundRenderContribution), 
    bind(arc_contribution_render_1.ArcRenderContribution).toService(arc_contribution_render_1.DefaultArcTextureRenderContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, arc_contribution_render_1.ArcRenderContribution), 
    bind(line_render_1.DefaultCanvasLineRender).toSelf().inSingletonScope(), bind(symbol_1.LineRender).to(line_render_1.DefaultCanvasLineRender), 
    bind(symbol_1.GraphicRender).to(line_render_1.DefaultCanvasLineRender), bind(incremental_line_render_1.DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(), 
    bind(incremental_area_render_1.DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope(), 
    bind(area_render_1.DefaultCanvasAreaRender).toSelf().inSingletonScope(), bind(symbol_1.AreaRender).to(area_render_1.DefaultCanvasAreaRender), 
    bind(symbol_1.GraphicRender).to(area_render_1.DefaultCanvasAreaRender), bind(area_contribution_render_1.DefaultAreaBackgroundRenderContribution).toSelf().inSingletonScope(), 
    bind(area_contribution_render_1.DefaultAreaTextureRenderContribution).toSelf().inSingletonScope(), 
    bind(area_contribution_render_1.AreaRenderContribution).toService(area_contribution_render_1.DefaultAreaBackgroundRenderContribution), 
    bind(area_contribution_render_1.AreaRenderContribution).toService(area_contribution_render_1.DefaultAreaTextureRenderContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, area_contribution_render_1.AreaRenderContribution), 
    bind(group_render_1.DefaultCanvasGroupRender).toSelf().inSingletonScope(), bind(symbol_1.GroupRender).to(group_render_1.DefaultCanvasGroupRender), 
    bind(symbol_1.GraphicRender).to(group_render_1.DefaultCanvasGroupRender), bind(group_contribution_render_1.DefaultGroupBackgroundRenderContribution).toSelf().inSingletonScope(), 
    bind(group_contribution_render_1.GroupRenderContribution).toService(group_contribution_render_1.DefaultGroupBackgroundRenderContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, group_contribution_render_1.GroupRenderContribution), 
    bind(polygon_render_1.DefaultCanvasPolygonRender).toSelf().inSingletonScope(), bind(symbol_1.PolygonRender).to(polygon_render_1.DefaultCanvasPolygonRender), 
    bind(symbol_1.GraphicRender).to(polygon_render_1.DefaultCanvasPolygonRender), bind(polygon_contribution_render_1.DefaultPolygonBackgroundRenderContribution).toSelf().inSingletonScope(), 
    bind(polygon_contribution_render_1.DefaultPolygonTextureRenderContribution).toSelf().inSingletonScope(), 
    bind(polygon_contribution_render_1.PolygonRenderContribution).toService(polygon_contribution_render_1.DefaultPolygonBackgroundRenderContribution), 
    bind(polygon_contribution_render_1.PolygonRenderContribution).toService(polygon_contribution_render_1.DefaultPolygonTextureRenderContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, polygon_contribution_render_1.PolygonRenderContribution), 
    bind(glyph_render_1.DefaultCanvasGlyphRender).toSelf().inSingletonScope(), bind(symbol_1.GlyphRender).toService(glyph_render_1.DefaultCanvasGlyphRender), 
    bind(symbol_1.GraphicRender).toService(symbol_1.GlyphRender), bind(image_render_1.DefaultCanvasImageRender).toSelf().inSingletonScope(), 
    bind(symbol_1.ImageRender).toService(image_render_1.DefaultCanvasImageRender), bind(symbol_1.GraphicRender).toService(symbol_1.ImageRender), 
    bind(image_contribution_render_1.DefaultImageBackgroundRenderContribution).toSelf().inSingletonScope(), 
    bind(image_contribution_render_1.ImageRenderContribution).toService(image_contribution_render_1.DefaultImageBackgroundRenderContribution), 
    (0, contribution_provider_1.bindContributionProvider)(bind, image_contribution_render_1.ImageRenderContribution), 
    bind(richtext_render_1.DefaultCanvasRichTextRender).toSelf().inSingletonScope(), 
    bind(symbol_1.RichTextRender).toService(richtext_render_1.DefaultCanvasRichTextRender), 
    bind(symbol_1.GraphicRender).toService(symbol_1.RichTextRender), bind(pyramid3d_render_1.DefaultCanvasPyramid3dRender).toSelf().inSingletonScope(), 
    bind(symbol_1.Pyramid3dRender).toService(pyramid3d_render_1.DefaultCanvasPyramid3dRender), 
    bind(symbol_1.GraphicRender).toService(symbol_1.Pyramid3dRender), (0, contribution_provider_1.bindContributionProvider)(bind, symbol_1.GraphicRender), 
    bind(draw_interceptor_1.ShadowRootDrawItemInterceptorContribution).toSelf().inSingletonScope(), 
    bind(draw_interceptor_1.DrawItemInterceptor).toService(draw_interceptor_1.ShadowRootDrawItemInterceptorContribution), 
    bind(draw_interceptor_1.Canvas3DDrawItemInterceptor).toSelf().inSingletonScope(), 
    bind(draw_interceptor_1.DrawItemInterceptor).toService(draw_interceptor_1.Canvas3DDrawItemInterceptor), 
    (0, contribution_provider_1.bindContributionProvider)(bind, draw_interceptor_1.DrawItemInterceptor);
}));
//# sourceMappingURL=module.js.map

}, function(modId) { var map = {"../../../common/contribution-provider":1689069767672,"./circle-render":1689069767814,"./rect-render":1689069767824,"./arc-render":1689069767751,"./draw-contribution":1689069767893,"./render-slector":1689069767895,"./symbol-render":1689069767827,"./text-render":1689069767829,"./path-render":1689069767822,"./line-render":1689069767816,"./area-render":1689069767819,"./group-render":1689069767896,"./polygon-render":1689069767831,"./image-render":1689069767834,"./incremental-draw-contribution":1689069767897,"./symbol":1689069767836,"./draw-interceptor":1689069767894,"./rect3d-render":1689069767900,"./incremental-line-render":1689069767898,"./incremental-area-render":1689069767899,"./richtext-render":1689069767901,"./contributions/rect-contribution-render":1689069767826,"./contributions/symbol-contribution-render":1689069767828,"./contributions/circle-contribution-render":1689069767815,"./contributions/arc-contribution-render":1689069767754,"./glyph-render":1689069767902,"./contributions/image-contribution-render":1689069767835,"./contributions/group-contribution-render":1689069767838,"./arc3d-render":1689069767903,"./pyramid3d-render":1689069767904,"./contributions/polygon-contribution-render":1689069767833,"./contributions/path-contribution-render":1689069767823,"./contributions/area-contribution-render":1689069767820}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767893, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultDrawContribution = void 0;

const inversify_1 = require("inversify"), sort_1 = require("../../../common/sort"), contribution_provider_1 = require("../../../common/contribution-provider"), graphic_1 = require("../../../graphic"), vutils_1 = require("@visactor/vutils"), constants_1 = require("../../../core/constants"), container_1 = require("../../../container"), symbol_1 = require("./symbol"), draw_interceptor_1 = require("./draw-interceptor"), canvas_utils_1 = require("../../../common/canvas-utils");

let DefaultDrawContribution = class {
    constructor(contributions, renderSelector, layerService, drawItemInterceptorContributions) {
        this.contributions = contributions, this.renderSelector = renderSelector, this.layerService = layerService, 
        this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.currentRenderMap = new Map, 
        this.defaultRenderMap = new Map, this.styleRenderMap = new Map, this.dirtyBounds = new vutils_1.Bounds, 
        this.backupDirtyBounds = new vutils_1.Bounds;
    }
    init() {
        this.contributions.forEach((item => {
            if (item.style) {
                const map = this.styleRenderMap.get(item.style) || new Map;
                map.set(item.numberType, item), this.styleRenderMap.set(item.style, map);
            } else this.defaultRenderMap.set(item.numberType, item);
        })), this.InterceptorContributions = this.drawItemInterceptorContributions.getContributions().sort(((a, b) => a.order - b.order));
    }
    draw(renderService, drawContext) {
        drawContext.drawContribution = this, this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap, 
        this.currentRenderService = renderService;
        const {context: context, stage: stage, x: x = 0, y: y = 0, width: width, height: height} = drawContext;
        if (!context) return;
        const dirtyBounds = this.dirtyBounds.setValue(0, 0, width, height);
        if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {
            const b = (0, vutils_1.getRectIntersect)(dirtyBounds, stage.dirtyBounds, !1);
            dirtyBounds.x1 = Math.floor(b.x1), dirtyBounds.y1 = Math.floor(b.y1), dirtyBounds.x2 = Math.ceil(b.x2), 
            dirtyBounds.y2 = Math.ceil(b.y2);
        }
        this.backupDirtyBounds.copy(dirtyBounds), context.inuse = !0, context.clearMatrix(), 
        context.setTransformForCurrent(!0);
        const drawInArea = dirtyBounds.width() * context.dpr !== context.canvas.width || dirtyBounds.height() * context.dpr !== context.canvas.height;
        context.save(), context.translate(x, y, !0), drawInArea && (context.beginPath(), 
        context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height()), 
        context.clip()), stage.camera && (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), 
        this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)), this.clearScreen(renderService, context, drawContext), 
        context.save(), renderService.renderTreeRoots.sort(((a, b) => {
            var _a, _b;
            return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : graphic_1.DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : graphic_1.DefaultAttribute.zIndex);
        })).forEach((group => {
            this.renderGroup(group, drawContext);
        })), context.restore(), context.restore(), context.draw(), context.inuse = !1;
    }
    doRegister() {
        throw new Error("暂不支持");
    }
    _findNextGraphic(group) {
        let parent = group.parent, id = group._uid;
        for (;parent; ) {
            const g = (0, sort_1.findNextGraphic)(parent, id, graphic_1.DefaultAttribute.zIndex);
            if (g) return g;
            id = parent._uid, parent = parent.parent;
        }
        return null;
    }
    renderGroup(group, drawContext, skipSort) {
        if (drawContext.break || !1 === group.attribute.visibleAll) return;
        if (group.incremental && (null == drawContext.startAtId || drawContext.startAtId === group._uid)) return drawContext.break = !0, 
        void this._increaseRender(group, drawContext);
        if (!(0, vutils_1.isRectIntersect)(group.AABBBounds, this.dirtyBounds, !1)) return;
        const tempBounds = this.dirtyBounds.clone(), m = group.globalTransMatrix.getInverse();
        this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(m), this.renderItem(group, drawContext, {
            drawingCb: () => {
                var _a;
                skipSort ? group.forEachChildren((item => {
                    drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext) : this.renderItem(item, drawContext));
                })) : (0, sort_1.foreach)(group, graphic_1.DefaultAttribute.zIndex, (item => {
                    drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext) : this.renderItem(item, drawContext));
                }), !1, !!(null === (_a = drawContext.context) || void 0 === _a ? void 0 : _a.camera));
            }
        }), this.dirtyBounds.copy(tempBounds);
    }
    _increaseRender(group, drawContext) {
        const {layer: layer, stage: stage} = drawContext, {subLayers: subLayers} = layer;
        let incrementalLayer = subLayers.get(group._uid);
        incrementalLayer || (incrementalLayer = {
            layer: this.layerService.createLayer(stage),
            zIndex: subLayers.size,
            group: group
        }, subLayers.set(group._uid, incrementalLayer));
        const incrementalContext = incrementalLayer.layer.getNativeHandler().getContext(), idc = incrementalLayer.drawContribution || container_1.container.get(symbol_1.IncrementalDrawContribution);
        idc.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), 
        idc.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
            drawContribution: idc,
            clear: "transparent",
            layer: incrementalLayer.layer,
            context: incrementalContext,
            startAtId: group._uid,
            break: !1
        })), incrementalLayer.drawContribution = idc;
        const nextGraphic = this._findNextGraphic(group);
        if (nextGraphic) if (nextGraphic.isContainer && nextGraphic.incremental) this._increaseRender(nextGraphic, drawContext); else {
            let afterLayer = subLayers.get(nextGraphic._uid);
            afterLayer || (afterLayer = {
                layer: this.layerService.createLayer(stage),
                zIndex: subLayers.size
            }, subLayers.set(nextGraphic._uid, afterLayer));
            const afterContext = afterLayer.layer.getNativeHandler().getContext();
            this.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
                drawContribution: idc,
                clear: "transparent",
                layer: afterLayer.layer,
                context: afterContext,
                startAtId: nextGraphic._uid,
                break: !1
            }));
        }
    }
    getRenderContribution(graphic) {
        let renderer = this.renderSelector.selector(graphic);
        return renderer || (renderer = this.selectRenderByNumberType(graphic.numberType)), 
        renderer || (renderer = this.selectRenderByType(graphic.type)), renderer;
    }
    renderItem(graphic, drawContext, params) {
        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
            const drawContribution = this.InterceptorContributions[i];
            if (drawContribution.beforeDrawItem && drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params)) return;
        }
        const renderer = this.getRenderContribution(graphic);
        if (!renderer) return;
        if (!graphic.isContainer && !(0, vutils_1.isRectIntersect)(graphic.AABBBounds, this.dirtyBounds, !1)) return;
        const skipDraw = null != drawContext.startAtId && graphic._uid !== drawContext.startAtId;
        if (graphic._uid === drawContext.startAtId && (drawContext.startAtId = null), params && (params.skipDraw = skipDraw), 
        skipDraw ? graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params) : renderer.draw(graphic, this.currentRenderService, drawContext, params), 
        this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
            const drawContribution = this.InterceptorContributions[i];
            if (drawContribution.afterDrawItem && drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this)) return;
        }
    }
    selectRenderByType(type) {
        return console.warn("未知错误，不应该走到这里"), null;
    }
    selectRenderByNumberType(type) {
        return this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);
    }
    clearScreen(renderService, context, drawContext) {
        const {clear: clear} = drawContext;
        if (clear) {
            const canvas = context.getCanvas(), {width: width = canvas.width, height: height = canvas.height} = drawContext, x = 0, y = 0;
            context.clearRect(x, y, width, height), context.fillStyle = (0, canvas_utils_1.createColor)(context, clear, {
                AABBBounds: {
                    x1: x,
                    y1: y,
                    x2: x + width,
                    y2: y + height
                }
            }, 0, 0), context.fillRect(x, y, width, height);
        }
    }
};

__decorate([ (0, inversify_1.postConstruct)(), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0) ], DefaultDrawContribution.prototype, "init", null), 
DefaultDrawContribution = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.multiInject)(symbol_1.GraphicRender)), __param(1, (0, inversify_1.inject)(symbol_1.RenderSelector)), __param(2, (0, 
inversify_1.inject)(constants_1.LayerService)), __param(3, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(3, (0, 
inversify_1.named)(draw_interceptor_1.DrawItemInterceptor)), __metadata("design:paramtypes", [ Array, Object, Object, Object ]) ], DefaultDrawContribution), 
exports.DefaultDrawContribution = DefaultDrawContribution;
//# sourceMappingURL=draw-contribution.js.map

}, function(modId) { var map = {"../../../common/sort":1689069767841,"../../../common/contribution-provider":1689069767672,"../../../graphic":1689069767757,"../../../core/constants":1689069767747,"../../../container":1689069767702,"./symbol":1689069767836,"./draw-interceptor":1689069767894,"../../../common/canvas-utils":1689069767755}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767894, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Canvas3DDrawItemInterceptor = exports.ShadowRootDrawItemInterceptorContribution = exports.DrawItemInterceptor = void 0;

const inversify_1 = require("inversify"), vutils_1 = require("@visactor/vutils"), graphic_1 = require("../../../graphic"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), constants_1 = require("../../../graphic/constants");

exports.DrawItemInterceptor = Symbol.for("DrawItemInterceptor");

const tempDirtyBounds = new vutils_1.AABBBounds;

let ShadowRootDrawItemInterceptorContribution = class {
    constructor() {
        this.order = 1;
    }
    afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.shadowRoot) return !1;
        const {context: context} = drawContext;
        if (context.highPerformanceSave(), context.transformFromMatrix(graphic.transMatrix, !0), 
        drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
            tempDirtyBounds.copy(drawContribution.dirtyBounds);
            const m = graphic.globalTransMatrix.getInverse();
            drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m);
        }
        return drawContribution.renderGroup(graphic.shadowRoot, drawContext), context.highPerformanceRestore(), 
        drawContribution.dirtyBounds && drawContribution.backupDirtyBounds && drawContribution.dirtyBounds.copy(tempDirtyBounds), 
        !0;
    }
};

ShadowRootDrawItemInterceptorContribution = __decorate([ (0, inversify_1.injectable)() ], ShadowRootDrawItemInterceptorContribution), 
exports.ShadowRootDrawItemInterceptorContribution = ShadowRootDrawItemInterceptorContribution;

let Canvas3DDrawItemInterceptor = class {
    constructor() {
        this.order = 1;
    }
    beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.in3dMode || drawContext.in3dInterceptor) return !1;
        drawContext.in3dInterceptor = !0;
        const {context: context, stage: stage} = renderService.drawParams;
        context.canvas;
        context.save(), this.initCanvasCtx(context), context.camera = stage.camera;
        const m = context.currentMatrix;
        m.a /= context.dpr, m.b /= context.dpr, m.c /= context.dpr, m.d /= context.dpr, 
        m.e /= context.dpr, m.f /= context.dpr;
        const matrix = matrix_allocate_1.mat4Allocate.allocate();
        (0, graphic_1.mat3Tomat4)(matrix, m);
        const lastModelMatrix = context.modelMatrix;
        if (lastModelMatrix) {
            if (matrix) {
                const m = matrix_allocate_1.mat4Allocate.allocate();
                context.modelMatrix = (0, graphic_1.multiplyMat4Mat4)(m, lastModelMatrix, matrix);
            }
        } else context.modelMatrix = matrix;
        if (context.setTransform(1, 0, 0, 1, 0, 0, !0), graphic.isContainer) {
            let isPie = !1, is3d = !1;
            if (graphic.forEachChildren((c => (isPie = c.numberType === constants_1.ARC3D_NUMBER_TYPE, 
            !isPie))), graphic.forEachChildren((c => (is3d = !!c.findFace, !is3d))), isPie) {
                const children = graphic.getChildren(), sortedChildren = [ ...children ];
                sortedChildren.sort(((a, b) => {
                    var _a, _b, _c, _d;
                    let angle1 = ((null !== (_a = a.attribute.startAngle) && void 0 !== _a ? _a : 0) + (null !== (_b = a.attribute.endAngle) && void 0 !== _b ? _b : 0)) / 2, angle2 = ((null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0) + (null !== (_d = b.attribute.endAngle) && void 0 !== _d ? _d : 0)) / 2;
                    for (;angle1 < 0; ) angle1 += vutils_1.pi2;
                    for (;angle2 < 0; ) angle2 += vutils_1.pi2;
                    return angle2 - angle1;
                })), sortedChildren.forEach((c => {
                    c._next = null, c._prev = null;
                })), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c => {
                    graphic.appendChild(c);
                })), drawContext.hack_pieFace = "outside", drawContribution.renderGroup(graphic, drawContext), 
                drawContext.hack_pieFace = "inside", drawContribution.renderGroup(graphic, drawContext), 
                drawContext.hack_pieFace = "top", drawContribution.renderGroup(graphic, drawContext), 
                graphic.removeAllChild(), children.forEach((c => {
                    c._next = null, c._prev = null;
                })), children.forEach((c => {
                    graphic.appendChild(c);
                }));
            } else if (is3d) {
                const children = graphic.getChildren(), zChildren = children.map((g => ({
                    ave_z: g.findFace().vertices.map((v => {
                        var _a;
                        return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
                    })).reduce(((a, b) => a + b), 0),
                    g: g
                })));
                zChildren.sort(((a, b) => b.ave_z - a.ave_z)), graphic.removeAllChild(), zChildren.forEach((i => {
                    i.g._next = null, i.g._prev = null;
                })), graphic.update(), zChildren.forEach((i => {
                    graphic.add(i.g);
                })), drawContribution.renderGroup(graphic, drawContext, !0), graphic.removeAllChild(), 
                children.forEach((g => {
                    g._next = null, g._prev = null;
                })), graphic.update(), children.forEach((g => {
                    graphic.add(g);
                }));
            } else drawContribution.renderGroup(graphic, drawContext);
        } else drawContribution.renderItem(graphic, drawContext);
        return context.camera = null, context.restore(), context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), 
        context.modelMatrix = lastModelMatrix, drawContext.in3dInterceptor = !1, !0;
    }
    initCanvasCtx(context) {
        context.setTransformForCurrent();
    }
};

Canvas3DDrawItemInterceptor = __decorate([ (0, inversify_1.injectable)() ], Canvas3DDrawItemInterceptor), 
exports.Canvas3DDrawItemInterceptor = Canvas3DDrawItemInterceptor;
//# sourceMappingURL=draw-interceptor.js.map

}, function(modId) { var map = {"../../../graphic":1689069767757,"../../../allocator/matrix-allocate":1689069767808,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767895, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultRenderSelector = void 0;

const inversify_1 = require("inversify");

let DefaultRenderSelector = class {
    selector(graphic) {
        return null;
    }
};

DefaultRenderSelector = __decorate([ (0, inversify_1.injectable)() ], DefaultRenderSelector), 
exports.DefaultRenderSelector = DefaultRenderSelector;
//# sourceMappingURL=render-slector.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767896, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasGroupRender = void 0;

const inversify_1 = require("inversify"), graphic_1 = require("../../../graphic"), vutils_1 = require("@visactor/vutils"), contribution_provider_1 = require("../../../common/contribution-provider"), rect_1 = require("../../../common/shape/rect"), utils_1 = require("./utils"), group_contribution_render_1 = require("./contributions/group-contribution-render"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), constants_1 = require("../../../graphic/constants"), enums_1 = require("../../../common/enums");

let DefaultCanvasGroupRender = class {
    constructor(groupRenderContribitions) {
        this.groupRenderContribitions = groupRenderContribitions, this.numberType = constants_1.GROUP_NUMBER_TYPE;
    }
    drawShape(group, context, x, y, drawContext, params, fillCb, strokeCb) {
        const groupAttribute = (0, graphic_1.getTheme)(group, null == params ? void 0 : params.theme).group, {fill: fill = groupAttribute.fill, background: background, stroke: stroke = groupAttribute.stroke, opacity: opacity = groupAttribute.opacity, width: width = groupAttribute.width, height: height = groupAttribute.height, clip: clip = groupAttribute.clip, fillOpacity: fillOpacity = groupAttribute.fillOpacity, strokeOpacity: strokeOpacity = groupAttribute.strokeOpacity, cornerRadius: cornerRadius = groupAttribute.cornerRadius, path: path = groupAttribute.path, lineWidth: lineWidth = groupAttribute.lineWidth, visible: visible = groupAttribute.visible} = group.attribute, fVisible = (0, 
        utils_1.rectFillVisible)(opacity, fillOpacity, width, height), sVisible = (0, utils_1.rectStrokeVisible)(opacity, strokeOpacity, width, height), doFill = (0, 
        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);
        if (!group.valid || !visible) return;
        if (!clip) {
            if (!(doFill || doStroke || background)) return;
            if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
        }
        if (path && path.length && drawContext.drawContribution) {
            const disableFill = context.disableFill, disableStroke = context.disableStroke, disableBeginPath = context.disableBeginPath;
            context.disableFill = !0, context.disableStroke = !0, context.disableBeginPath = !0, 
            path.forEach((g => {
                drawContext.drawContribution.getRenderContribution(g).draw(g, drawContext.renderService, drawContext, params);
            })), context.disableFill = disableFill, context.disableStroke = disableStroke, context.disableBeginPath = disableBeginPath;
        } else 0 === cornerRadius || (0, vutils_1.isArray)(cornerRadius) && cornerRadius.every((num => 0 === num)) ? (context.beginPath(), 
        context.rect(x, y, width, height)) : (context.beginPath(), (0, rect_1.createRectPath)(context, x, y, width, height, cornerRadius));
        this._groupRenderContribitions || (this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || []);
        const doFillOrStroke = {
            doFill: doFill,
            doStroke: doStroke
        };
        this._groupRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb, doFillOrStroke);
        })), clip && context.clip(), context.setShadowStyle && context.setShadowStyle(group, group.attribute, groupAttribute), 
        doFillOrStroke.doFill && (fillCb ? fillCb(context, group.attribute, groupAttribute) : fVisible && (context.setCommonStyle(group, group.attribute, x, y, groupAttribute), 
        context.fill())), doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, group.attribute, groupAttribute) : sVisible && (context.setStrokeStyle(group, group.attribute, x, y, groupAttribute), 
        context.stroke())), this._groupRenderContribitions.forEach((c => {
            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb);
        }));
    }
    draw(group, renderService, drawContext, params) {
        const {context: context} = drawContext;
        if (!context) return;
        const {clip: clip} = group.attribute;
        clip ? context.save() : context.highPerformanceSave();
        const groupAttribute = (0, graphic_1.getTheme)(group, null == params ? void 0 : params.theme).group, lastModelMatrix = context.modelMatrix;
        if (context.camera) {
            const nextModelMatrix = matrix_allocate_1.mat4Allocate.allocate(), modelMatrix = matrix_allocate_1.mat4Allocate.allocate();
            (0, graphic_1.getModelMatrix)(modelMatrix, group, groupAttribute), lastModelMatrix ? (0, 
            graphic_1.multiplyMat4Mat4)(nextModelMatrix, lastModelMatrix, modelMatrix) : (0, 
            graphic_1.multiplyMat4Mat4)(nextModelMatrix, nextModelMatrix, modelMatrix), context.modelMatrix = nextModelMatrix, 
            matrix_allocate_1.mat4Allocate.free(modelMatrix), context.setTransform(1, 0, 0, 1, 0, 0, !0);
        } else context.transformFromMatrix(group.transMatrix, !0);
        context.beginPath(), params.skipDraw ? this.drawShape(group, context, 0, 0, drawContext, params, (() => !1), (() => !1)) : this.drawShape(group, context, 0, 0, drawContext);
        const {scrollX: scrollX = groupAttribute.scrollX, scrollY: scrollY = groupAttribute.scrollY} = group.attribute;
        let p;
        (scrollX || scrollY) && context.translate(scrollX, scrollY), params && params.drawingCb && (p = params.drawingCb()), 
        context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), 
        context.modelMatrix = lastModelMatrix, p && p.then ? p.then((() => {
            clip ? context.restore() : context.highPerformanceRestore();
        })) : clip ? context.restore() : context.highPerformanceRestore();
    }
};

DefaultCanvasGroupRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_1.named)(group_contribution_render_1.GroupRenderContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasGroupRender), 
exports.DefaultCanvasGroupRender = DefaultCanvasGroupRender;
//# sourceMappingURL=group-render.js.map

}, function(modId) { var map = {"../../../graphic":1689069767757,"../../../common/contribution-provider":1689069767672,"../../../common/shape/rect":1689069767825,"./utils":1689069767752,"./contributions/group-contribution-render":1689069767838,"../../../allocator/matrix-allocate":1689069767808,"../../../graphic/constants":1689069767744,"../../../common/enums":1689069767685}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767897, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}, __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultIncrementalDrawContribution = void 0;

const inversify_1 = require("inversify"), graphic_1 = require("../../../graphic"), constants_1 = require("../../../core/constants"), draw_contribution_1 = require("./draw-contribution"), tapable_1 = require("../../../tapable"), symbol_1 = require("./symbol"), incremental_line_render_1 = require("./incremental-line-render"), incremental_area_render_1 = require("./incremental-area-render"), draw_interceptor_1 = require("./draw-interceptor"), contribution_provider_1 = require("../../../common/contribution-provider"), sort_1 = require("../../../common/sort"), constants_2 = require("../../../constants");

var STATUS;

!function(STATUS) {
    STATUS[STATUS.NORMAL = 0] = "NORMAL", STATUS[STATUS.STOP = 1] = "STOP";
}(STATUS || (STATUS = {}));

let DefaultIncrementalDrawContribution = class extends draw_contribution_1.DefaultDrawContribution {
    constructor(contributions, renderSelector, lineRender, areaRender, layerService, drawItemInterceptorContributions) {
        super(contributions, renderSelector, layerService, drawItemInterceptorContributions), 
        this.contributions = contributions, this.renderSelector = renderSelector, this.lineRender = lineRender, 
        this.areaRender = areaRender, this.layerService = layerService, this.drawItemInterceptorContributions = drawItemInterceptorContributions, 
        this.rendering = !1, this.currFrameStartAt = 0, this.currentIdx = 0, this.status = STATUS.NORMAL, 
        this.checkingForDrawPromise = null, this.hooks = {
            completeDraw: new tapable_1.SyncHook([])
        };
    }
    init() {
        super.init(), this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender), 
        this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
    }
    draw(renderService, drawContext) {
        return __awaiter(this, void 0, void 0, (function*() {
            if (this.checkingForDrawPromise) return;
            this.lastRenderService = renderService, this.lastDrawContext = drawContext, this.checkingForDrawPromise = this.checkForDraw(drawContext);
            const skipDraw = yield this.checkingForDrawPromise;
            if (this.checkingForDrawPromise = null, skipDraw) return;
            this.currentRenderService = renderService;
            const {context: context, x: x = 0, y: y = 0} = drawContext;
            context && (context.inuse = !0, context.clearMatrix(), context.setTransformForCurrent(!0), 
            context.save(), drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext), 
            context.translate(x, y, !0), context.save(), renderService.renderTreeRoots.sort(((a, b) => {
                var _a, _b;
                return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : graphic_1.DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : graphic_1.DefaultAttribute.zIndex);
            })).forEach((group => {
                this.renderGroup(group, drawContext);
            })), this.hooks.completeDraw.tap("top-draw", (() => {
                context.restore(), context.restore(), context.draw(), context.inuse = !1, this.rendering = !1;
            })));
        }));
    }
    _increaseRender(group, drawContext) {
        return __awaiter(this, void 0, void 0, (function*() {
            this.rendering = !0, yield this._renderIncrementalGroup(group, drawContext);
        }));
    }
    _renderIncrementalGroup(group, drawContext) {
        return __awaiter(this, void 0, void 0, (function*() {
            this.count = group.count, yield new Promise((resolve => {
                this.renderItem(group, drawContext, {
                    drawingCb: () => __awaiter(this, void 0, void 0, (function*() {
                        if (2 !== group.count) yield (0, sort_1.foreachAsync)(group, graphic_1.DefaultAttribute.zIndex, ((item, i) => {
                            if (this.status === STATUS.STOP) return !0;
                            if (item.isContainer) return !1;
                            if (i < this.currentIdx) return !1;
                            const frameTail = this.currFrameStartAt + group.incremental;
                            return i < frameTail && (this.currentIdx = i + 1, this.renderItem(item, drawContext)), 
                            i === frameTail - 1 && (this.currFrameStartAt = this.currentIdx, this.waitToNextFrame());
                        })), resolve(!1); else {
                            const graphic = group.getChildAt(0);
                            if (graphic.incremental && graphic.attribute.segments) for (graphic.incrementalAt || (graphic.incrementalAt = 0); graphic.incrementalAt < graphic.attribute.segments.length; ) drawContext.multiGraphicOptions = {
                                startAtIdx: graphic.incrementalAt,
                                length: graphic.incremental
                            }, this.renderItem(graphic, drawContext), graphic.incrementalAt += graphic.incremental, 
                            yield this.waitToNextFrame(); else this.renderItem(graphic, drawContext);
                            resolve(!1);
                        }
                    }))
                });
            })), this.hooks.completeDraw.call();
        }));
    }
    waitToNextFrame() {
        return __awaiter(this, void 0, void 0, (function*() {
            return new Promise((resolve => {
                this.global.getRequestAnimationFrame()((() => {
                    resolve(!1);
                }));
            }));
        }));
    }
    checkForDraw(drawContext) {
        return __awaiter(this, void 0, void 0, (function*() {
            let skip = this.rendering;
            return drawContext.restartIncremental && (skip = !1, yield this.forceStop(), this.resetToInit()), 
            skip;
        }));
    }
    forceStop() {
        return __awaiter(this, void 0, void 0, (function*() {
            this.rendering && (this.status = STATUS.STOP, yield new Promise((resolve => {
                this.hooks.completeDraw.tap("stopCb", (() => {
                    this.status = STATUS.NORMAL, this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter((item => "stopCb" !== item.name)), 
                    resolve(!1);
                }));
            })));
        }));
    }
    resetToInit() {
        this.currFrameStartAt = 0, this.currentIdx = 0;
    }
    renderGroup(group, drawContext) {
        return __awaiter(this, void 0, void 0, (function*() {
            if (!drawContext.break && !1 !== group.attribute.visibleAll) return group.incremental && drawContext.startAtId === group._uid ? (yield this._increaseRender(group, drawContext), 
            void (drawContext.break = !0)) : void (yield new Promise((resolve => {
                this.renderItem(group, drawContext, {
                    drawingCb: () => __awaiter(this, void 0, void 0, (function*() {
                        yield (0, sort_1.foreachAsync)(group, graphic_1.DefaultAttribute.zIndex, (item => __awaiter(this, void 0, void 0, (function*() {
                            drawContext.break || item.isContainer && (yield this.renderGroup(item, drawContext));
                        })))), resolve(!1);
                    }))
                });
            })));
        }));
    }
};

__decorate([ (0, inversify_1.inject)(constants_2.Global), __metadata("design:type", Object) ], DefaultIncrementalDrawContribution.prototype, "global", void 0), 
DefaultIncrementalDrawContribution = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.multiInject)(symbol_1.GraphicRender)), __param(1, (0, inversify_1.inject)(symbol_1.RenderSelector)), __param(2, (0, 
inversify_1.inject)(incremental_line_render_1.DefaultIncrementalCanvasLineRender)), __param(3, (0, 
inversify_1.inject)(incremental_area_render_1.DefaultIncrementalCanvasAreaRender)), __param(4, (0, 
inversify_1.inject)(constants_1.LayerService)), __param(5, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(5, (0, 
inversify_1.named)(draw_interceptor_1.DrawItemInterceptor)), __metadata("design:paramtypes", [ Array, Object, Object, Object, Object, Object ]) ], DefaultIncrementalDrawContribution), 
exports.DefaultIncrementalDrawContribution = DefaultIncrementalDrawContribution;
//# sourceMappingURL=incremental-draw-contribution.js.map

}, function(modId) { var map = {"../../../graphic":1689069767757,"../../../core/constants":1689069767747,"./draw-contribution":1689069767893,"../../../tapable":1689069767673,"./symbol":1689069767836,"./incremental-line-render":1689069767898,"./incremental-area-render":1689069767899,"./draw-interceptor":1689069767894,"../../../common/contribution-provider":1689069767672,"../../../common/sort":1689069767841,"../../../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767898, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultIncrementalCanvasLineRender = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants"), utils_1 = require("./utils"), line_render_1 = require("./line-render"), render_curve_1 = require("../../../common/render-curve");

let DefaultIncrementalCanvasLineRender = class extends line_render_1.DefaultCanvasLineRender {
    constructor() {
        super(...arguments), this.numberType = constants_1.LINE_NUMBER_TYPE;
    }
    drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
        if (line.incremental && drawContext.multiGraphicOptions) {
            const {startAtIdx: startAtIdx, length: length} = drawContext.multiGraphicOptions, {segments: segments = []} = line.attribute;
            if (startAtIdx > segments.length) return;
            const lineAttribute = (0, theme_1.getTheme)(line).line, {fill: fill = lineAttribute.fill, stroke: stroke = lineAttribute.stroke, opacity: opacity = lineAttribute.opacity, fillOpacity: fillOpacity = lineAttribute.fillOpacity, strokeOpacity: strokeOpacity = lineAttribute.strokeOpacity, lineWidth: lineWidth = lineAttribute.lineWidth, visible: visible = lineAttribute.visible} = line.attribute, fVisible = (0, 
            utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, 
            utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);
            if (!line.valid || !visible) return;
            if (!doFill && !doStroke) return;
            if (!(fVisible || sVisible || fillCb || strokeCb)) return;
            const {context: context} = drawContext;
            for (let i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(line, context, segments[i - 1], segments[i], line.attribute.segments[i], [ lineAttribute, line.attribute ], x, y);
        } else super.drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb);
    }
    drawIncreaseSegment(line, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
        seg && (context.beginPath(), (0, render_curve_1.drawIncrementalSegments)(context.nativeContext, lastSeg, seg, {
            offsetX: offsetX,
            offsetY: offsetY
        }), context.setShadowStyle && context.setShadowStyle(line, attribute, defaultAttribute), 
        context.setStrokeStyle(line, attribute, offsetX, offsetY, defaultAttribute), context.stroke());
    }
};

DefaultIncrementalCanvasLineRender = __decorate([ (0, inversify_1.injectable)() ], DefaultIncrementalCanvasLineRender), 
exports.DefaultIncrementalCanvasLineRender = DefaultIncrementalCanvasLineRender;
//# sourceMappingURL=incremental-line-render.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744,"./utils":1689069767752,"./line-render":1689069767816,"../../../common/render-curve":1689069767818}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767899, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultIncrementalCanvasAreaRender = void 0;

const inversify_1 = require("inversify"), constants_1 = require("../../../graphic/constants"), theme_1 = require("../../../graphic/theme"), utils_1 = require("./utils"), area_render_1 = require("./area-render"), render_curve_1 = require("../../../common/render-curve");

let DefaultIncrementalCanvasAreaRender = class extends area_render_1.DefaultCanvasAreaRender {
    constructor() {
        super(...arguments), this.numberType = constants_1.AREA_NUMBER_TYPE;
    }
    drawShape(area, context, x, y, drawContext, params, fillCb) {
        if (area.incremental && drawContext.multiGraphicOptions) {
            const {startAtIdx: startAtIdx, length: length} = drawContext.multiGraphicOptions, {segments: segments = []} = area.attribute;
            if (startAtIdx > segments.length) return;
            const areaAttribute = (0, theme_1.getTheme)(area).area, {fill: fill = areaAttribute.fill, fillOpacity: fillOpacity = areaAttribute.fillOpacity, opacity: opacity = areaAttribute.opacity, visible: visible = areaAttribute.visible} = area.attribute, fVisible = (0, 
            utils_1.fillVisible)(opacity, fillOpacity), doFill = (0, utils_1.runFill)(fill);
            if (!area.valid || !visible) return;
            if (!doFill) return;
            if (!fVisible && !fillCb) return;
            for (let i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(area, context, segments[i - 1], segments[i], area.attribute.segments[i], [ areaAttribute, area.attribute ], x, y);
        } else super.drawShape(area, context, x, y, drawContext, params, fillCb);
    }
    drawIncreaseSegment(area, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
        seg && (context.beginPath(), (0, render_curve_1.drawIncrementalAreaSegments)(context.camera ? context : context.nativeContext, lastSeg, seg, {
            offsetX: offsetX,
            offsetY: offsetY
        }), context.setShadowStyle && context.setShadowStyle(area, attribute, defaultAttribute), 
        context.setCommonStyle(area, attribute, offsetX, offsetY, defaultAttribute), context.fill());
    }
};

DefaultIncrementalCanvasAreaRender = __decorate([ (0, inversify_1.injectable)() ], DefaultIncrementalCanvasAreaRender), 
exports.DefaultIncrementalCanvasAreaRender = DefaultIncrementalCanvasAreaRender;
//# sourceMappingURL=incremental-area-render.js.map

}, function(modId) { var map = {"../../../graphic/constants":1689069767744,"../../../graphic/theme":1689069767707,"./utils":1689069767752,"./area-render":1689069767819,"../../../common/render-curve":1689069767818}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767900, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasRect3dRender = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), utils_1 = require("./utils"), color_string_1 = require("../../../color-string"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), base_render_1 = require("./base-render"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasRect3dRender = class extends base_render_1.BaseRender {
    constructor() {
        super(...arguments), this.type = "rect3d", this.numberType = constants_1.RECT3D_NUMBER_TYPE;
    }
    drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        const rectAttribute = (0, theme_1.getTheme)(rect, null == params ? void 0 : params.theme).rect3d, {fill: fill = rectAttribute.fill, stroke: stroke = rectAttribute.stroke, width: width = rectAttribute.width, height: height = rectAttribute.height, opacity: opacity = rectAttribute.opacity, fillOpacity: fillOpacity = rectAttribute.fillOpacity, lineWidth: lineWidth = rectAttribute.lineWidth, strokeOpacity: strokeOpacity = rectAttribute.strokeOpacity, visible: visible = rectAttribute.visible} = rect.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, fVisible = (0, 
        utils_1.rectFillVisible)(opacity, fillOpacity, width, height), sVisible = (0, utils_1.rectStrokeVisible)(opacity, strokeOpacity, width, height), doFill = (0, 
        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);
        if (!rect.valid || !visible) return;
        if (!doFill && !doStroke) return;
        if (!(fVisible || sVisible || fillCb || strokeCb)) return;
        const {light: light, camera: camera} = drawContext.stage || {}, face3d = rect.findFace();
        if (!1 !== fill) {
            context.setCommonStyle(rect, rect.attribute, x, y, rectAttribute);
            let fc = fill;
            "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, fc, context, light, fillCb);
        }
        !1 !== stroke && (context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute), 
        this.stroke(x, y, z, face3d, context));
    }
    stroke(x, y, z, face3d, context) {
        const vertices = face3d.vertices;
        face3d.edges.forEach((edge => {
            const p1 = vertices[edge[0]], v1 = {
                x: x + p1[0],
                y: y + p1[1],
                z: z + p1[2]
            }, p2 = vertices[edge[1]], v2 = {
                x: x + p2[0],
                y: y + p2[1],
                z: z + p2[2]
            };
            context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), 
            context.stroke();
        }));
    }
    fill(x, y, z, face3d, fillColor, context, light, fillCb) {
        const rgbArray = color_string_1.colorString.get(fillColor).value, vertices = face3d.vertices, viewdVerticesZ = vertices.map((v => context.view(v[0], v[1], v[2])[2])), sortFace = [];
        face3d.polygons.forEach(((p, i) => {
            sortFace.push({
                faceIdx: i,
                polygon: p
            });
            const {polygon: polygon, normal: normal} = p, z1 = viewdVerticesZ[polygon[0]], z2 = viewdVerticesZ[polygon[1]], z3 = viewdVerticesZ[polygon[2]], z4 = viewdVerticesZ[polygon[3]];
            p.ave_z = z1 + z2 + z3 + z4;
        })), sortFace.sort(((a, b) => b.polygon.ave_z - a.polygon.ave_z)), sortFace.forEach((item => {
            const {polygon: polygon, normal: normal} = item.polygon, p1 = vertices[polygon[0]], p2 = vertices[polygon[1]], p3 = vertices[polygon[2]], p4 = vertices[polygon[3]], v1 = {
                x: x + p1[0],
                y: y + p1[1],
                z: z + p1[2]
            }, v2 = {
                x: x + p2[0],
                y: y + p2[1],
                z: z + p2[2]
            }, v3 = {
                x: x + p3[0],
                y: y + p3[1],
                z: z + p3[2]
            }, v4 = {
                x: x + p4[0],
                y: y + p4[1],
                z: z + p4[2]
            };
            context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), 
            context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), 
            fillCb ? fillCb(context, null, null) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, 
            context.fill());
        }));
    }
    draw(rect, renderService, drawContext) {
        const {context: context} = drawContext;
        if (!context) return;
        context.highPerformanceSave();
        const rectAttribute = (0, theme_1.getTheme)(rect).rect, data = this.transform(rect, rectAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        this.z = z, this.drawShape(rect, context, x, y, drawContext), this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), 
        context.modelMatrix = lastModelMatrix, context.highPerformanceRestore();
    }
};

DefaultCanvasRect3dRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasRect3dRender), 
exports.DefaultCanvasRect3dRender = DefaultCanvasRect3dRender;
//# sourceMappingURL=rect3d-render.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"./utils":1689069767752,"../../../color-string":1689069767741,"../../../allocator/matrix-allocate":1689069767808,"./base-render":1689069767817,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767901, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasRichTextRender = void 0;

const inversify_1 = require("inversify"), rect_1 = require("../../../common/shape/rect"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants"), utils_1 = require("./utils");

let DefaultCanvasRichTextRender = class {
    constructor() {
        this.numberType = constants_1.RICHTEXT_NUMBER_TYPE;
    }
    drawShape(richtext, context, x, y, drawContext) {
        const richtextAttribute = (0, theme_1.getTheme)(richtext).richtext, {width: width = richtextAttribute.width, height: height = richtextAttribute.height, opacity: opacity = richtextAttribute.opacity, fillOpacity: fillOpacity = richtextAttribute.fillOpacity, visible: visible = richtextAttribute.visible} = richtext.attribute;
        if (!richtext.valid || !visible) return;
        if (!(0, utils_1.fillVisible)(opacity, fillOpacity)) return;
        context.translate(x, y);
        richtext.getFrameCache().draw(context, this.drawIcon);
    }
    drawIcon(icon, context, x, y, baseline) {
        var _a;
        const richtextIconAttribute = (0, theme_1.getTheme)(icon).richtextIcon, {width: width = richtextIconAttribute.width, height: height = richtextIconAttribute.height, opacity: opacity = richtextIconAttribute.opacity, image: url, backgroundFill: backgroundFill = richtextIconAttribute.backgroundFill, backgroundFillOpacity: backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity, backgroundStroke: backgroundStroke = richtextIconAttribute.backgroundStroke, backgroundStrokeOpacity: backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity, backgroundRadius: backgroundRadius = richtextIconAttribute.backgroundRadius, margin: margin} = icon.attribute, {backgroundWidth: backgroundWidth = width, backgroundHeight: backgroundHeight = height} = icon.attribute;
        if (margin && (x += icon._marginArray[3], y += icon._marginArray[0]), icon._hovered) {
            const expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;
            0 === backgroundRadius ? (context.beginPath(), context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight)) : (context.beginPath(), 
            (0, rect_1.createRectPath)(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius)), 
            backgroundFill && (context.globalAlpha = backgroundFillOpacity, context.fillStyle = backgroundFill, 
            context.fill()), backgroundStroke && (context.globalAlpha = backgroundStrokeOpacity, 
            context.strokeStyle = backgroundStroke, context.stroke());
        }
        const res = url && (null === (_a = null == icon ? void 0 : icon.resources) || void 0 === _a ? void 0 : _a.get(url));
        res && "success" === res.state && (context.globalAlpha = opacity, context.drawImage(res.data, x, y, width, height));
    }
    draw(richtext, renderService, drawContext) {
        const {context: context} = drawContext;
        if (!context) return;
        context.highPerformanceSave();
        const richtextAttribute = (0, theme_1.getTheme)(richtext).richtext;
        let {x: x = richtextAttribute.x, y: y = richtextAttribute.y} = richtext.attribute;
        if (richtext.transMatrix.onlyTranslate()) {
            const point = richtext.getOffsetXY(richtextAttribute);
            x += point.x, y += point.y, context.setTransformForCurrent();
        } else x = 0, y = 0, context.transformFromMatrix(richtext.transMatrix, !0);
        this.drawShape(richtext, context, x, y, drawContext), context.highPerformanceRestore();
    }
};

DefaultCanvasRichTextRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasRichTextRender), 
exports.DefaultCanvasRichTextRender = DefaultCanvasRichTextRender;
//# sourceMappingURL=richtext-render.js.map

}, function(modId) { var map = {"../../../common/shape/rect":1689069767825,"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744,"./utils":1689069767752}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767902, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasGlyphRender = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasGlyphRender = class {
    constructor() {
        this.numberType = constants_1.GLYPH_NUMBER_TYPE;
    }
    drawShape(glyph, context, x, y, drawContext, params, fillCb, strokeCb) {
        drawContext.drawContribution && glyph.getSubGraphic().forEach((item => {
            const renderer = drawContext.drawContribution.getRenderContribution(item);
            renderer && renderer.drawShape && renderer.drawShape(item, context, x, y, drawContext, params, fillCb, strokeCb);
        }));
    }
    draw(glyph, renderService, drawContext, params) {
        const {context: context} = drawContext;
        if (!context) return;
        if (context.highPerformanceSave(), !drawContext.drawContribution) return;
        const glyphTheme = (0, theme_1.getTheme)(glyph), subGraphic = glyph.getSubGraphic();
        subGraphic.length && subGraphic.forEach((g => {
            drawContext.drawContribution.renderItem(g, drawContext, {
                theme: glyphTheme
            });
        })), context.highPerformanceRestore();
    }
};

DefaultCanvasGlyphRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasGlyphRender), 
exports.DefaultCanvasGlyphRender = DefaultCanvasGlyphRender;
//# sourceMappingURL=glyph-render.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767903, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasArc3DRender = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), utils_1 = require("./utils"), color_string_1 = require("../../../color-string"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), base_render_1 = require("./base-render"), constants_1 = require("../../../graphic/constants");

function drawArcPath(arc, context, cx, cy, z, outerRadius, innerRadius) {
    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = (0, 
    vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (outerRadius < innerRadius) {
        const temp = outerRadius;
        outerRadius = innerRadius, innerRadius = temp;
    }
    if (outerRadius <= vutils_1.epsilon) context.moveTo(cx, cy, z); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) context.moveTo(cx + outerRadius * (0, 
    vutils_1.cos)(startAngle), cy + outerRadius * (0, vutils_1.sin)(startAngle), z), 
    context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z), innerRadius > vutils_1.epsilon && (context.moveTo(cx + innerRadius * (0, 
    vutils_1.cos)(endAngle), cy + innerRadius * (0, vutils_1.sin)(endAngle), z), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z)); else {
        const {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle), xors = outerRadius * (0, 
        vutils_1.cos)(outerStartAngle), yors = outerRadius * (0, vutils_1.sin)(outerStartAngle), xire = innerRadius * (0, 
        vutils_1.cos)(innerEndAngle), yire = innerRadius * (0, vutils_1.sin)(innerEndAngle);
        outerDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z), 
        context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z)), 
        !(innerRadius > vutils_1.epsilon) || innerDeltaAngle < .001 ? (context.lineTo(cx + xire, cy + yire, z), 
        collapsedToLine = !0) : (context.lineTo(cx + xire, cy + yire, z), context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z));
    }
    return context.closePath(), collapsedToLine;
}

function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = (0, 
    vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (radius <= vutils_1.epsilon) context.moveTo(cx, cy, z1); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) context.moveTo(cx + radius * (0, 
    vutils_1.cos)(startAngle), cy + radius * (0, vutils_1.sin)(startAngle), z1), context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1), 
    context.lineTo(cx + radius * (0, vutils_1.cos)(endAngle), cy + radius * (0, vutils_1.sin)(endAngle), z2), 
    context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2); else {
        const {innerouterDeltaAngle: innerouterDeltaAngle, innerouterStartAngle: innerouterStartAngle, innerouterEndAngle: innerouterEndAngle} = getParsePadAngle(startAngle, endAngle), xors = radius * (0, 
        vutils_1.cos)(innerouterStartAngle), yors = radius * (0, vutils_1.sin)(innerouterStartAngle), xore = radius * (0, 
        vutils_1.cos)(innerouterEndAngle), yore = radius * (0, vutils_1.sin)(innerouterEndAngle);
        innerouterDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z1), 
        context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1), 
        context.lineTo(cx + xore, cy + yore, z2), context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2));
    }
    return context.closePath(), collapsedToLine;
}

let DefaultCanvasArc3DRender = class extends base_render_1.BaseRender {
    constructor() {
        super(...arguments), this.numberType = constants_1.ARC3D_NUMBER_TYPE;
    }
    drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        const arcAttribute = (0, theme_1.getTheme)(arc, null == params ? void 0 : params.theme).arc, {fill: fill = arcAttribute.fill, background: background, stroke: stroke = arcAttribute.stroke, opacity: opacity = arcAttribute.opacity, fillOpacity: fillOpacity = arcAttribute.fillOpacity, lineWidth: lineWidth = arcAttribute.lineWidth, strokeOpacity: strokeOpacity = arcAttribute.strokeOpacity, visible: visible = arcAttribute.visible} = arc.attribute, fVisible = (0, 
        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, 
        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth), z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
        if (!arc.valid || !visible) return;
        if (!(doFill || doStroke || background)) return;
        if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
        const {outerRadius: outerRadius = arcAttribute.outerRadius, innerRadius: innerRadius = arcAttribute.innerRadius, height: height = 10} = arc.attribute, rgbArray = color_string_1.colorString.get(fill).value, {light: light} = drawContext.stage || {}, face = drawContext.hack_pieFace, z_face = {
            top: z,
            bottom: z + height
        }, n_face = {
            top: [ 0, 1, 0 ],
            bottom: [ 0, -1, 0 ],
            outside: [ 1, 0, -1 ],
            inside: [ 1, 0, -1 ]
        };
        "bottom" === face || "top" === face ? (context.beginPath(), drawArcPath(arc, context, x, y, z_face[face], outerRadius, innerRadius), 
        context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute), 
        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), 
        doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.stroke()))) : "outside" !== face && "inside" !== face || ("inside" === face && (context.save(), 
        context.beginPath(), context.arc(x, y, innerRadius, 0, vutils_1.pi2, !0, z_face.top), 
        context.clip()), context.beginPath(), drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, "outside" === face ? outerRadius : innerRadius, ((startAngle, endAngle) => {
            const {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle);
            return "outside" === face ? {
                innerouterDeltaAngle: outerDeltaAngle,
                innerouterEndAngle: outerEndAngle,
                innerouterStartAngle: outerStartAngle
            } : {
                innerouterDeltaAngle: innerDeltaAngle,
                innerouterEndAngle: innerEndAngle,
                innerouterStartAngle: innerStartAngle
            };
        })), context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute), 
        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), 
        doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.stroke())), "inside" === face && context.restore());
    }
    draw(arc, renderService, drawContext, params) {
        const {context: context} = drawContext;
        if (!context) return;
        const arcAttribute = (0, theme_1.getTheme)(arc, null == params ? void 0 : params.theme).arc;
        context.save();
        const data = this.transform(arc, arcAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        this.z = z, (0, utils_1.drawPathProxy)(arc, context, x, y, drawContext, params) || (this.drawShape(arc, context, x, y, drawContext, params), 
        this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), 
        context.modelMatrix = lastModelMatrix), context.restore();
    }
};

DefaultCanvasArc3DRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasArc3DRender), 
exports.DefaultCanvasArc3DRender = DefaultCanvasArc3DRender;
//# sourceMappingURL=arc3d-render.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"./utils":1689069767752,"../../../color-string":1689069767741,"../../../allocator/matrix-allocate":1689069767808,"./base-render":1689069767817,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767904, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasPyramid3dRender = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants"), utils_1 = require("./utils"), color_string_1 = require("../../../color-string"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), base_render_1 = require("./base-render");

let DefaultCanvasPyramid3dRender = class extends base_render_1.BaseRender {
    constructor() {
        super(...arguments), this.type = "pyramid3d", this.numberType = constants_1.PYRAMID3D_NUMBER_TYPE;
    }
    drawShape(pyramid3d, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        const pyramidAttribute = (0, theme_1.getTheme)(pyramid3d, null == params ? void 0 : params.theme).polygon, {fill: fill = pyramidAttribute.fill, stroke: stroke = pyramidAttribute.stroke, opacity: opacity = pyramidAttribute.opacity, fillOpacity: fillOpacity = pyramidAttribute.fillOpacity, lineWidth: lineWidth = pyramidAttribute.lineWidth, strokeOpacity: strokeOpacity = pyramidAttribute.strokeOpacity, visible: visible = pyramidAttribute.visible, points: points, face: face = [ !0, !0, !0, !0, !0, !0 ]} = pyramid3d.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, fVisible = (0, 
        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, 
        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);
        if (!pyramid3d.valid || !visible || 4 !== points.length) return;
        if (!doFill && !doStroke) return;
        if (!(fVisible || sVisible || fillCb || strokeCb)) return;
        const {light: light, camera: camera} = drawContext.stage || {}, face3d = pyramid3d.findFace();
        if (!1 !== fill) {
            context.setCommonStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);
            let fc = fill;
            "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, face, fc, context, light, camera, pyramid3d, pyramidAttribute, fillCb);
        }
        !1 !== stroke && (context.setStrokeStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute), 
        this.stroke(x, y, z, face3d, context));
    }
    stroke(x, y, z, face3d, context) {
        const vertices = face3d.vertices;
        face3d.edges.forEach((p => {
            const p1 = vertices[p[0]], p2 = vertices[p[1]], v1 = {
                x: x + p1[0],
                y: y + p1[1],
                z: z + p1[2]
            }, v2 = {
                x: x + p2[0],
                y: y + p2[1],
                z: z + p2[2]
            };
            context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), 
            context.stroke();
        }));
    }
    fill(x, y, z, face3d, faces, fillColor, context, light, camera, pyramid3d, pyramid3dAttribute, fillCb) {
        const rgbArray = color_string_1.colorString.get(fillColor).value, vertices = face3d.vertices, viewdVerticesZ = vertices.map((v => context.view(v[0], v[1], v[2])[2])), sortFace = [];
        face3d.polygons.forEach(((p, i) => {
            if (!faces[i]) return;
            sortFace.push({
                faceIdx: i,
                polygon: p
            });
            const {polygon: polygon, normal: normal} = p, z1 = viewdVerticesZ[polygon[0]], z2 = viewdVerticesZ[polygon[1]], z3 = viewdVerticesZ[polygon[2]], z4 = viewdVerticesZ[polygon[3]];
            p.ave_z = z1 + z2 + z3 + z4;
        })), sortFace.sort(((a, b) => b.polygon.ave_z - a.polygon.ave_z)), sortFace.forEach((item => {
            const {polygon: polygon, normal: normal} = item.polygon, p1 = vertices[polygon[0]], p2 = vertices[polygon[1]], p3 = vertices[polygon[2]], p4 = vertices[polygon[3]], v1 = {
                x: x + p1[0],
                y: y + p1[1],
                z: z + p1[2]
            }, v2 = {
                x: x + p2[0],
                y: y + p2[1],
                z: z + p2[2]
            }, v3 = {
                x: x + p3[0],
                y: y + p3[1],
                z: z + p3[2]
            }, v4 = {
                x: x + p4[0],
                y: y + p4[1],
                z: z + p4[2]
            };
            context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), 
            context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), 
            fillCb ? fillCb(context, pyramid3d.attribute, pyramid3dAttribute) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, 
            context.fill());
        }));
    }
    draw(pyramid3d, renderService, drawContext) {
        const {context: context} = drawContext;
        if (!context) return;
        context.highPerformanceSave();
        const pyramid3dAttribute = (0, theme_1.getTheme)(pyramid3d).polygon, data = this.transform(pyramid3d, pyramid3dAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        this.z = z, this.drawShape(pyramid3d, context, x, y, drawContext), this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), 
        context.modelMatrix = lastModelMatrix, context.highPerformanceRestore();
    }
};

DefaultCanvasPyramid3dRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasPyramid3dRender), 
exports.DefaultCanvasPyramid3dRender = DefaultCanvasPyramid3dRender;
//# sourceMappingURL=pyramid3d-render.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744,"./utils":1689069767752,"../../../color-string":1689069767741,"../../../allocator/matrix-allocate":1689069767808,"./base-render":1689069767817}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767905, function(require, module, exports) {


var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

const module_1 = __importDefault(require("./canvas-picker/module")), module_2 = __importDefault(require("./math-picker/module"));

function load(container) {
    container.load(module_1.default), container.load(module_2.default);
}

exports.default = load;
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"./canvas-picker/module":1689069767906,"./math-picker/module":1689069767923}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767906, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), circle_picker_1 = require("./circle-picker"), rect_picker_1 = require("./rect-picker"), arc_picker_1 = require("./arc-picker"), area_picker_1 = require("./area-picker"), image_picker_1 = require("./image-picker"), line_picker_1 = require("./line-picker"), path_picker_1 = require("./path-picker"), symbol_picker_1 = require("./symbol-picker"), text_picker_1 = require("./text-picker"), constants_1 = require("../constants"), contribution_provider_1 = require("../../../common/contribution-provider"), polygon_picker_1 = require("./polygon-picker"), richtext_picker_1 = require("./richtext-picker"), glyph_picker_1 = require("./glyph-picker"), rect3d_picker_1 = require("./rect3d-picker"), pyramid3d_picker_1 = require("./pyramid3d-picker"), arc3d_picker_1 = require("./arc3d-picker");

exports.default = new inversify_1.ContainerModule(((bind, unbind, isBound, rebind) => {
    bind(circle_picker_1.DefaultCanvasCirclePicker).toSelf().inSingletonScope(), bind(constants_1.CanvasCirclePicker).toService(circle_picker_1.DefaultCanvasCirclePicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasCirclePicker), 
    bind(rect_picker_1.DefaultCanvasRectPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasRectPicker).toService(rect_picker_1.DefaultCanvasRectPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasRectPicker), 
    bind(rect3d_picker_1.DefaultCanvasRect3dPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasRect3dPicker).toService(rect3d_picker_1.DefaultCanvasRect3dPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasRect3dPicker), 
    bind(arc_picker_1.DefaultCanvasArcPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasArcPicker).toService(arc_picker_1.DefaultCanvasArcPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasArcPicker), 
    bind(area_picker_1.DefaultCanvasAreaPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasAreaPicker).toService(area_picker_1.DefaultCanvasAreaPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasAreaPicker), 
    bind(image_picker_1.DefaultCanvasImagePicker).toSelf().inSingletonScope(), bind(constants_1.CanvasImagePicker).toService(image_picker_1.DefaultCanvasImagePicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasImagePicker), 
    bind(line_picker_1.DefaultCanvasLinePicker).toSelf().inSingletonScope(), bind(constants_1.CanvasLinePicker).toService(line_picker_1.DefaultCanvasLinePicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasLinePicker), 
    bind(path_picker_1.DefaultCanvasPathPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasPathPicker).toService(path_picker_1.DefaultCanvasPathPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasPathPicker), 
    bind(symbol_picker_1.DefaultCanvasSymbolPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasSymbolPicker).toService(symbol_picker_1.DefaultCanvasSymbolPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasSymbolPicker), 
    bind(text_picker_1.DefaultCanvasTextPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasTextPicker).toService(text_picker_1.DefaultCanvasTextPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasTextPicker), 
    bind(polygon_picker_1.DefaultCanvasPolygonPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasPolygonPicker).toService(polygon_picker_1.DefaultCanvasPolygonPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasPolygonPicker), 
    bind(pyramid3d_picker_1.DefaultCanvasPyramid3dPicker).toSelf().inSingletonScope(), 
    bind(constants_1.CanvasPyramid3dPicker).toService(pyramid3d_picker_1.DefaultCanvasPyramid3dPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasPyramid3dPicker), 
    bind(arc3d_picker_1.DefaultCanvasArc3dPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasArc3dPicker).toService(arc3d_picker_1.DefaultCanvasArc3dPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasArc3dPicker), 
    bind(richtext_picker_1.DefaultCanvasRichTextPicker).toSelf().inSingletonScope(), 
    bind(constants_1.CanvasRichTextPicker).toService(richtext_picker_1.DefaultCanvasRichTextPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasRichTextPicker), 
    bind(glyph_picker_1.DefaultCanvasGlyphPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasGlyphPicker).toService(glyph_picker_1.DefaultCanvasGlyphPicker), 
    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasGlyphPicker), 
    (0, contribution_provider_1.bindContributionProvider)(bind, constants_1.CanvasPickerContribution);
}));
//# sourceMappingURL=module.js.map

}, function(modId) { var map = {"./circle-picker":1689069767907,"./rect-picker":1689069767908,"./arc-picker":1689069767909,"./area-picker":1689069767910,"./image-picker":1689069767911,"./line-picker":1689069767912,"./path-picker":1689069767914,"./symbol-picker":1689069767915,"./text-picker":1689069767916,"../constants":1689069767849,"../../../common/contribution-provider":1689069767672,"./polygon-picker":1689069767917,"./richtext-picker":1689069767918,"./glyph-picker":1689069767919,"./rect3d-picker":1689069767920,"./pyramid3d-picker":1689069767921,"./arc3d-picker":1689069767922}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767907, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasCirclePicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), canvas_utils_1 = require("../../../common/canvas-utils"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasCirclePicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = constants_1.CIRCLE_NUMBER_TYPE;
    }
    contains(circle, point, params) {
        if (!circle.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === circle.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const circleAttribute = (0, theme_1.getTheme)(circle).circle;
        let {x: x = circleAttribute.x, y: y = circleAttribute.y} = circle.attribute;
        if (pickContext.highPerformanceSave(), circle.transMatrix.onlyTranslate()) {
            const point = circle.getOffsetXY(circleAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(circle.transMatrix, !0);
        let picked = !1;
        return this.canvasRenderer.drawShape(circle, pickContext, x, y, {}, null, ((context, circleAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked)), ((context, circleAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), 
            picked = context.isPointInStroke(point.x, point.y), picked;
        })), pickContext.highPerformanceRestore(), picked;
    }
};

DefaultCanvasCirclePicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.CircleRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasCirclePicker), 
exports.DefaultCanvasCirclePicker = DefaultCanvasCirclePicker;
//# sourceMappingURL=circle-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../common/canvas-utils":1689069767755,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767908, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasRectPicker = void 0;

const vutils_1 = require("@visactor/vutils"), canvas_utils_1 = require("../../../common/canvas-utils"), inversify_1 = require("inversify"), graphic_1 = require("../../../graphic"), render_1 = require("../../../render"), constants_1 = require("../../../graphic/constants"), _bounds = new vutils_1.AABBBounds;

let DefaultCanvasRectPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "rect", this.numberType = constants_1.RECT_NUMBER_TYPE;
    }
    contains(rect, point, params) {
        if (!rect.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === rect.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const rectAttribute = (0, graphic_1.getTheme)(rect).rect, {cornerRadius: cornerRadius = rectAttribute.cornerRadius} = rect.attribute;
        let {x: x = rectAttribute.x, y: y = rectAttribute.y} = rect.attribute;
        pickContext.highPerformanceSave();
        let onlyTranslate = !0;
        if (rect.transMatrix.onlyTranslate()) {
            const point = rect.getOffsetXY(rectAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, onlyTranslate = !1, pickContext.transformFromMatrix(rect.transMatrix, !0);
        let picked = !0;
        if (!onlyTranslate || (0, vutils_1.isNumber)(cornerRadius, !0) && 0 !== cornerRadius || (0, 
        vutils_1.isArray)(cornerRadius) && cornerRadius.some((num => 0 !== num))) picked = !1, 
        this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, ((context, rectAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked)), ((context, rectAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), 
            picked = context.isPointInStroke(point.x, point.y), picked;
        })); else if (picked) {
            const {fill: fill = rectAttribute.fill, stroke: stroke = rectAttribute.stroke, lineWidth: lineWidth = rectAttribute.lineWidth} = rect.attribute;
            if (fill) picked = !0; else if (stroke) {
                const bounds = rect.AABBBounds;
                _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), 
                picked = !_bounds.containsPoint(point);
            }
        }
        return pickContext.highPerformanceRestore(), picked;
    }
};

DefaultCanvasRectPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.RectRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasRectPicker), 
exports.DefaultCanvasRectPicker = DefaultCanvasRectPicker;
//# sourceMappingURL=rect-picker.js.map

}, function(modId) { var map = {"../../../common/canvas-utils":1689069767755,"../../../graphic":1689069767757,"../../../render":1689069767850,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767909, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasArcPicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), canvas_utils_1 = require("../../../common/canvas-utils"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasArcPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = constants_1.ARC_NUMBER_TYPE;
    }
    contains(arc, point, params) {
        if (!arc.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === arc.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const arcAttribute = (0, theme_1.getTheme)(arc).arc;
        pickContext.highPerformanceSave();
        let {x: x = arcAttribute.x, y: y = arcAttribute.y} = arc.attribute;
        if (arc.transMatrix.onlyTranslate()) {
            const point = arc.getOffsetXY(arcAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(arc.transMatrix, !0);
        let picked = !1;
        return this.canvasRenderer.drawShape(arc, pickContext, x, y, {}, null, ((context, arcAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked)), ((context, arcAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), 
            picked = context.isPointInStroke(point.x, point.y), picked;
        })), pickContext.highPerformanceRestore(), picked;
    }
};

DefaultCanvasArcPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.ArcRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasArcPicker), 
exports.DefaultCanvasArcPicker = DefaultCanvasArcPicker;
//# sourceMappingURL=arc-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../common/canvas-utils":1689069767755,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767910, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasAreaPicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasAreaPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = constants_1.AREA_NUMBER_TYPE;
    }
    contains(area, point, params) {
        if (!area.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === area.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const areaAttribute = (0, theme_1.getTheme)(area).area;
        let {x: x = areaAttribute.x, y: y = areaAttribute.y} = area.attribute;
        if (pickContext.highPerformanceSave(), area.transMatrix.onlyTranslate()) {
            const point = area.getOffsetXY(areaAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(area.transMatrix, !0);
        let picked = !1;
        return this.canvasRenderer.drawShape(area, pickContext, x, y, {}, null, (context => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked))), pickContext.highPerformanceRestore(), picked;
    }
};

DefaultCanvasAreaPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.AreaRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasAreaPicker), 
exports.DefaultCanvasAreaPicker = DefaultCanvasAreaPicker;
//# sourceMappingURL=area-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767911, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasImagePicker = void 0;

const inversify_1 = require("inversify"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasImagePicker = class {
    constructor() {
        this.type = "image", this.numberType = constants_1.IMAGE_NUMBER_TYPE;
    }
    contains(image, point, params) {
        const {pickContext: pickContext} = null != params ? params : {};
        return !!pickContext && !!image.AABBBounds.containsPoint(point);
    }
};

DefaultCanvasImagePicker = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasImagePicker), 
exports.DefaultCanvasImagePicker = DefaultCanvasImagePicker;
//# sourceMappingURL=image-picker.js.map

}, function(modId) { var map = {"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767912, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasLinePicker = void 0;

const inversify_1 = require("inversify"), render_1 = require("../../../render"), theme_1 = require("../../../graphic/theme"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), canvas_utils_1 = require("../../../common/canvas-utils"), base_picker_1 = require("./base-picker"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasLinePicker = class extends base_picker_1.BasePicker {
    constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = constants_1.LINE_NUMBER_TYPE;
    }
    contains(line, point, params) {
        if (!line.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === line.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        pickContext.highPerformanceSave();
        const lineAttribute = (0, theme_1.getTheme)(line).line, data = this.transform(line, lineAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        let pickPoint = point;
        if (pickContext.camera) {
            pickPoint = point.clone();
            const globalMatrix = line.parent.globalTransMatrix;
            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, 
            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        let picked = !1;
        return this.canvasRenderer.drawShape(line, pickContext, x, y, {}, null, (context => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), 
        picked)), ((context, circleAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), 
            picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
        })), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), 
        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), 
        picked;
    }
};

DefaultCanvasLinePicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.LineRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasLinePicker), 
exports.DefaultCanvasLinePicker = DefaultCanvasLinePicker;
//# sourceMappingURL=line-picker.js.map

}, function(modId) { var map = {"../../../render":1689069767850,"../../../graphic/theme":1689069767707,"../../../allocator/matrix-allocate":1689069767808,"../../../common/canvas-utils":1689069767755,"./base-picker":1689069767913,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767913, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BasePicker = void 0;

const inversify_1 = require("inversify"), base_render_1 = require("../../../render/contributions/render/base-render");

let BasePicker = class extends base_render_1.BaseRender {};

BasePicker = __decorate([ (0, inversify_1.injectable)() ], BasePicker), exports.BasePicker = BasePicker;
//# sourceMappingURL=base-picker.js.map

}, function(modId) { var map = {"../../../render/contributions/render/base-render":1689069767817}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767914, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasPathPicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), canvas_utils_1 = require("../../../common/canvas-utils"), base_picker_1 = require("./base-picker"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasPathPicker = class extends base_picker_1.BasePicker {
    constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = constants_1.PATH_NUMBER_TYPE;
    }
    contains(path, point, params) {
        if (!path.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === path.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const pathAttribute = (0, theme_1.getTheme)(path).path;
        pickContext.highPerformanceSave();
        const data = this.transform(path, pathAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        let pickPoint = point;
        if (pickContext.camera) {
            pickPoint = point.clone();
            const globalMatrix = path.parent.globalTransMatrix;
            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, 
            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        let picked = !1;
        return this.canvasRenderer.drawShape(path, pickContext, x, y, {}, null, ((context, pathAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), 
        picked)), ((context, pathAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), 
            picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
        })), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), 
        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), 
        picked;
    }
};

DefaultCanvasPathPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.PathRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasPathPicker), 
exports.DefaultCanvasPathPicker = DefaultCanvasPathPicker;
//# sourceMappingURL=path-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../allocator/matrix-allocate":1689069767808,"../../../common/canvas-utils":1689069767755,"./base-picker":1689069767913,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767915, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasSymbolPicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), canvas_utils_1 = require("../../../common/canvas-utils"), base_picker_1 = require("./base-picker"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasSymbolPicker = class extends base_picker_1.BasePicker {
    constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = constants_1.SYMBOL_NUMBER_TYPE;
    }
    contains(symbol, point, params) {
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        if (!pickContext.camera) {
            if (!symbol.AABBBounds.containsPoint(point)) return !1;
            if ("imprecise" === symbol.attribute.pickMode) return !0;
        }
        pickContext.highPerformanceSave();
        const symbolAttribute = (0, theme_1.getTheme)(symbol).symbol, data = this.transform(symbol, symbolAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        let pickPoint = point;
        if (pickContext.camera) {
            pickPoint = point.clone();
            const globalMatrix = symbol.parent.globalTransMatrix;
            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, 
            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        let picked = !1;
        return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, ((context, symbolAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), 
        picked)), ((context, symbolAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), 
            picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
        })), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), 
        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), 
        picked;
    }
};

DefaultCanvasSymbolPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.SymbolRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasSymbolPicker), 
exports.DefaultCanvasSymbolPicker = DefaultCanvasSymbolPicker;
//# sourceMappingURL=symbol-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../allocator/matrix-allocate":1689069767808,"../../../common/canvas-utils":1689069767755,"./base-picker":1689069767913,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767916, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasTextPicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), base_picker_1 = require("./base-picker"), render_1 = require("../../../render"), text_1 = require("../../../common/text"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasTextPicker = class extends base_picker_1.BasePicker {
    constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "text", this.numberType = constants_1.TEXT_NUMBER_TYPE;
    }
    contains(text, point, params) {
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const bounds = text.AABBBounds;
        if (!pickContext.camera) return !!bounds.containsPoint(point);
        pickContext.highPerformanceSave();
        const textAttribute = (0, theme_1.getTheme)(text).text, {keepDirIn3d: keepDirIn3d = textAttribute.keepDirIn3d} = text.attribute, computed3dMatrix = !keepDirIn3d, data = this.transform(text, textAttribute, pickContext, computed3dMatrix), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        this.canvasRenderer.z = z;
        let pickPoint = point;
        if (pickContext.camera) {
            pickPoint = point.clone();
            const globalMatrix = text.parent.globalTransMatrix;
            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, 
            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        let picked = !1;
        return this.canvasRenderer.drawShape(text, pickContext, x, y, {}, null, ((context, symbolAttribute, themeAttribute) => {
            if (picked) return !0;
            const {fontSize: fontSize = textAttribute.fontSize, textBaseline: textBaseline = textAttribute.textBaseline, textAlign: textAlign = textAttribute.textAlign} = text.attribute, bounds = text.AABBBounds, height = bounds.height(), width = bounds.width(), offsetY = (0, 
            text_1.textLayoutOffsetY)(textBaseline, height, fontSize), offsetX = (0, text_1.textDrawOffsetX)(textAlign, width);
            return context.rect(offsetX + x, offsetY + y, width, height, z), picked = context.isPointInPath(pickPoint.x, pickPoint.y), 
            picked;
        }), ((context, symbolAttribute, themeAttribute) => picked)), this.canvasRenderer.z = 0, 
        pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), 
        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), 
        picked;
    }
};

DefaultCanvasTextPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.TextRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasTextPicker), 
exports.DefaultCanvasTextPicker = DefaultCanvasTextPicker;
//# sourceMappingURL=text-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"./base-picker":1689069767913,"../../../render":1689069767850,"../../../common/text":1689069767760,"../../../allocator/matrix-allocate":1689069767808,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767917, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasPolygonPicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), constants_1 = require("../../../graphic/constants");

let DefaultCanvasPolygonPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = constants_1.POLYGON_NUMBER_TYPE;
    }
    contains(polygon, point, params) {
        if (!polygon.AABBBounds.contains(point.x, point.y)) return !1;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const polygonAttribute = (0, theme_1.getTheme)(polygon).polygon;
        let {x: x = polygonAttribute.x, y: y = polygonAttribute.y} = polygon.attribute;
        if (pickContext.highPerformanceSave(), polygon.transMatrix.onlyTranslate()) {
            const point = polygon.getOffsetXY(polygonAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(polygon.transMatrix, !0);
        let picked = !1;
        return this.canvasRenderer.drawShape(polygon, pickContext, x, y, {}, null, ((context, pathAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked)), ((context, pathAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), 
            picked;
        })), pickContext.highPerformanceRestore(), picked;
    }
};

DefaultCanvasPolygonPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.PolygonRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasPolygonPicker), 
exports.DefaultCanvasPolygonPicker = DefaultCanvasPolygonPicker;
//# sourceMappingURL=polygon-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767918, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasRichTextPicker = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), constants_1 = require("../../../graphic/constants"), render_1 = require("../../../render"), _bounds = new vutils_1.AABBBounds;

let DefaultCanvasRichTextPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "richtext", this.numberType = constants_1.RICHTEXT_NUMBER_TYPE;
    }
    contains(richtext, point, params) {
        return !!richtext.AABBBounds.containsPoint(point);
    }
};

DefaultCanvasRichTextPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.RichTextRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasRichTextPicker), 
exports.DefaultCanvasRichTextPicker = DefaultCanvasRichTextPicker;
//# sourceMappingURL=richtext-picker.js.map

}, function(modId) { var map = {"../../../graphic/constants":1689069767744,"../../../render":1689069767850}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767919, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasGlyphPicker = void 0;

const inversify_1 = require("inversify"), constants_1 = require("../../../graphic/constants"), render_1 = require("../../../render");

let DefaultCanvasGlyphPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "glyph", this.numberType = constants_1.GLYPH_NUMBER_TYPE;
    }
    contains(glyph, point, params) {
        if (!glyph.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === glyph.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const pickerService = null == params ? void 0 : params.pickerService;
        if (pickerService) {
            let picked = !1;
            return glyph.getSubGraphic().forEach((g => {
                picked || (picked = !!pickerService.pickItem(g, point, params));
            })), picked;
        }
        return !1;
    }
};

DefaultCanvasGlyphPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.GlyphRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasGlyphPicker), 
exports.DefaultCanvasGlyphPicker = DefaultCanvasGlyphPicker;
//# sourceMappingURL=glyph-picker.js.map

}, function(modId) { var map = {"../../../graphic/constants":1689069767744,"../../../render":1689069767850}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767920, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasRect3dPicker = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), render_1 = require("../../../render"), base_picker_1 = require("./base-picker"), constants_1 = require("../../../graphic/constants"), _bounds = new vutils_1.AABBBounds;

let DefaultCanvasRect3dPicker = class extends base_picker_1.BasePicker {
    constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "rect3d", this.numberType = constants_1.RECT3D_NUMBER_TYPE;
    }
    contains(rect, point, params) {
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const rectAttribute = (0, theme_1.getTheme)(rect).rect;
        pickContext.highPerformanceSave();
        const data = this.transform(rect, rectAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        let pickPoint = point;
        if (pickContext.camera) {
            pickPoint = point.clone();
            const globalMatrix = rect.parent.globalTransMatrix;
            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, 
            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        let picked = !1;
        return this.canvasRenderer.drawShape(rect, pickContext, x, y, params, null, ((context, arc3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), 
        picked))), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), 
        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), 
        picked;
    }
};

DefaultCanvasRect3dPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.Rect3DRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasRect3dPicker), 
exports.DefaultCanvasRect3dPicker = DefaultCanvasRect3dPicker;
//# sourceMappingURL=rect3d-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../allocator/matrix-allocate":1689069767808,"../../../render":1689069767850,"./base-picker":1689069767913,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767921, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasPyramid3dPicker = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), base_picker_1 = require("./base-picker"), constants_1 = require("../../../graphic/constants"), _bounds = new vutils_1.AABBBounds;

let DefaultCanvasPyramid3dPicker = class extends base_picker_1.BasePicker {
    constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "pyramid3d", this.numberType = constants_1.PYRAMID3D_NUMBER_TYPE;
    }
    contains(pyramid3d, point, params) {
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const pyramid3dAttribute = (0, theme_1.getTheme)(pyramid3d).polygon;
        pickContext.highPerformanceSave();
        const data = this.transform(pyramid3d, pyramid3dAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        let pickPoint = point;
        if (pickContext.camera) {
            pickPoint = point.clone();
            const globalMatrix = pyramid3d.parent.globalTransMatrix;
            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, 
            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        let picked = !1;
        return this.canvasRenderer.drawShape(pyramid3d, pickContext, x, y, {}, null, ((context, pyramid3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), 
        picked)), ((context, pyramid3dAttribute, themeAttribute) => !1)), this.canvasRenderer.z = 0, 
        pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), 
        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), 
        picked;
    }
};

DefaultCanvasPyramid3dPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.Pyramid3dRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasPyramid3dPicker), 
exports.DefaultCanvasPyramid3dPicker = DefaultCanvasPyramid3dPicker;
//# sourceMappingURL=pyramid3d-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../allocator/matrix-allocate":1689069767808,"./base-picker":1689069767913,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767922, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasArc3dPicker = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), matrix_allocate_1 = require("../../../allocator/matrix-allocate"), base_picker_1 = require("./base-picker"), constants_1 = require("../../../graphic/constants"), _bounds = new vutils_1.AABBBounds;

let DefaultCanvasArc3dPicker = class extends base_picker_1.BasePicker {
    constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "arc3d", this.numberType = constants_1.ARC3D_NUMBER_TYPE;
    }
    contains(arc3d, point, params) {
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const arc3dAttribute = (0, theme_1.getTheme)(arc3d).arc;
        pickContext.highPerformanceSave();
        const data = this.transform(arc3d, arc3dAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;
        let pickPoint = point;
        if (pickContext.camera) {
            pickPoint = point.clone();
            const globalMatrix = arc3d.parent.globalTransMatrix;
            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, 
            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        let picked = !1;
        return this.canvasRenderer.drawShape(arc3d, pickContext, x, y, params, null, ((context, arc3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), 
        picked))), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), 
        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), 
        picked;
    }
};

DefaultCanvasArc3dPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.Arc3dRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultCanvasArc3dPicker), 
exports.DefaultCanvasArc3dPicker = DefaultCanvasArc3dPicker;
//# sourceMappingURL=arc3d-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../allocator/matrix-allocate":1689069767808,"./base-picker":1689069767913,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767923, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), path_picker_1 = require("./path-picker"), constants_1 = require("../constants"), contribution_provider_1 = require("../../../common/contribution-provider"), circle_picker_1 = require("./circle-picker"), rect_picker_1 = require("./rect-picker"), arc_picker_1 = require("./arc-picker"), area_picker_1 = require("./area-picker"), line_picker_1 = require("./line-picker"), symbol_picker_1 = require("./symbol-picker"), text_picker_1 = require("./text-picker"), polygon_picker_1 = require("./polygon-picker"), glyph_picker_1 = require("./glyph-picker");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(circle_picker_1.DefaultMathCirclePicker).toSelf().inSingletonScope(), bind(constants_1.MathCirclePicker).toService(circle_picker_1.DefaultMathCirclePicker), 
    bind(constants_1.MathPickerContribution).toService(constants_1.MathCirclePicker), 
    bind(rect_picker_1.DefaultMathRectPicker).toSelf().inSingletonScope(), bind(constants_1.MathRectPicker).toService(rect_picker_1.DefaultMathRectPicker), 
    bind(constants_1.MathPickerContribution).toService(constants_1.MathRectPicker), 
    bind(arc_picker_1.DefaultMathArcPicker).toSelf().inSingletonScope(), bind(constants_1.MathArcPicker).toService(arc_picker_1.DefaultMathArcPicker), 
    bind(constants_1.MathPickerContribution).toService(constants_1.MathArcPicker), bind(area_picker_1.DefaultMathAreaPicker).toSelf().inSingletonScope(), 
    bind(constants_1.MathAreaPicker).toService(area_picker_1.DefaultMathAreaPicker), 
    bind(constants_1.MathPickerContribution).toService(constants_1.MathAreaPicker), 
    bind(line_picker_1.DefaultMathLinePicker).toSelf().inSingletonScope(), bind(constants_1.MathLinePicker).toService(line_picker_1.DefaultMathLinePicker), 
    bind(constants_1.MathPickerContribution).toService(constants_1.MathLinePicker), 
    bind(path_picker_1.DefaultMathPathPicker).toSelf().inSingletonScope(), bind(constants_1.MathPathPicker).toService(path_picker_1.DefaultMathPathPicker), 
    bind(constants_1.MathPickerContribution).toService(constants_1.MathPathPicker), 
    bind(symbol_picker_1.DefaultMathSymbolPicker).toSelf().inSingletonScope(), bind(constants_1.MathSymbolPicker).toService(symbol_picker_1.DefaultMathSymbolPicker), 
    bind(constants_1.MathPickerContribution).toService(constants_1.MathSymbolPicker), 
    bind(text_picker_1.DefaultMathTextPicker).toSelf().inSingletonScope(), bind(constants_1.MathTextPicker).toService(text_picker_1.DefaultMathTextPicker), 
    bind(constants_1.MathPickerContribution).toService(constants_1.MathTextPicker), 
    bind(polygon_picker_1.DefaultMathPolygonPicker).toSelf().inSingletonScope(), bind(constants_1.MathPolygonPicker).toService(polygon_picker_1.DefaultMathPolygonPicker), 
    bind(constants_1.MathPickerContribution).toService(constants_1.MathPolygonPicker), 
    bind(glyph_picker_1.DefaultMathGlyphPicker).toSelf().inSingletonScope(), bind(constants_1.MathGlyphPicker).toService(glyph_picker_1.DefaultMathGlyphPicker), 
    bind(glyph_picker_1.DefaultMathGlyphPicker).toService(constants_1.MathGlyphPicker), 
    (0, contribution_provider_1.bindContributionProvider)(bind, constants_1.MathPickerContribution);
}));
//# sourceMappingURL=module.js.map

}, function(modId) { var map = {"./path-picker":1689069767924,"../constants":1689069767849,"../../../common/contribution-provider":1689069767672,"./circle-picker":1689069767925,"./rect-picker":1689069767926,"./arc-picker":1689069767927,"./area-picker":1689069767928,"./line-picker":1689069767929,"./symbol-picker":1689069767930,"./text-picker":1689069767931,"./polygon-picker":1689069767932,"./glyph-picker":1689069767933}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767924, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMathPathPicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), constants_1 = require("../../../graphic/constants");

let DefaultMathPathPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = constants_1.PATH_NUMBER_TYPE;
    }
    contains(path, point, params) {
        if (!path.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === path.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const pathAttribute = (0, theme_1.getTheme)(path).path;
        let {x: x = pathAttribute.x, y: y = pathAttribute.y} = path.attribute;
        if (pickContext.highPerformanceSave(), path.transMatrix.onlyTranslate()) {
            const point = path.getOffsetXY(pathAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(path.transMatrix, !0);
        let picked = !1;
        return this.canvasRenderer.drawShape(path, pickContext, x, y, {}, null, ((context, pathAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked)), ((context, pathAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), 
            picked;
        })), pickContext.highPerformanceRestore(), picked;
    }
};

DefaultMathPathPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.PathRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultMathPathPicker), 
exports.DefaultMathPathPicker = DefaultMathPathPicker;
//# sourceMappingURL=path-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767925, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMathCirclePicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), constants_1 = require("../../../graphic/constants");

let DefaultMathCirclePicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = constants_1.CIRCLE_NUMBER_TYPE;
    }
    contains(circle, point, params) {
        if (!circle.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === circle.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const circleAttribute = (0, theme_1.getTheme)(circle).circle;
        let {x: x = circleAttribute.x, y: y = circleAttribute.y} = circle.attribute;
        if (pickContext.highPerformanceSave(), circle.transMatrix.onlyTranslate()) {
            const point = circle.getOffsetXY(circleAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(circle.transMatrix, !0);
        let picked = !1;
        return this.canvasRenderer.drawShape(circle, pickContext, x, y, {}, null, ((context, circleAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked)), ((context, circleAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), 
            picked;
        })), pickContext.highPerformanceRestore(), picked;
    }
};

DefaultMathCirclePicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.CircleRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultMathCirclePicker), 
exports.DefaultMathCirclePicker = DefaultMathCirclePicker;
//# sourceMappingURL=circle-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767926, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMathRectPicker = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), constants_1 = require("../../../graphic/constants"), _bounds = new vutils_1.AABBBounds;

let DefaultMathRectPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "rect", this.numberType = constants_1.RECT_NUMBER_TYPE;
    }
    contains(rect, point, params) {
        if (!rect.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === rect.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const rectAttribute = (0, theme_1.getTheme)(rect).rect, {cornerRadius: cornerRadius = rectAttribute.cornerRadius} = rect.attribute;
        let {x: x = rectAttribute.x, y: y = rectAttribute.y} = rect.attribute;
        pickContext.highPerformanceSave();
        let onlyTranslate = !0;
        if (rect.transMatrix.onlyTranslate()) {
            const point = rect.getOffsetXY(rectAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, onlyTranslate = !1, pickContext.transformFromMatrix(rect.transMatrix, !0);
        let picked = !0;
        if (!onlyTranslate || (0, vutils_1.isNumber)(cornerRadius, !0) && 0 !== cornerRadius || (0, 
        vutils_1.isArray)(cornerRadius) && cornerRadius.some((num => 0 !== num))) picked = !1, 
        this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, ((context, rectAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked)), ((context, rectAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), 
            picked;
        })); else if (picked) {
            const {fill: fill = rectAttribute.fill, stroke: stroke = rectAttribute.stroke, lineWidth: lineWidth = rectAttribute.lineWidth} = rect.attribute;
            if (fill) picked = !0; else if (stroke) {
                const bounds = rect.AABBBounds;
                _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), 
                picked = !_bounds.containsPoint(point);
            }
        }
        return pickContext.highPerformanceRestore(), picked;
    }
};

DefaultMathRectPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.RectRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultMathRectPicker), 
exports.DefaultMathRectPicker = DefaultMathRectPicker;
//# sourceMappingURL=rect-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767927, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMathArcPicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), constants_1 = require("../../../graphic/constants");

let DefaultMathArcPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = constants_1.ARC_NUMBER_TYPE;
    }
    contains(arc, point, params) {
        if (!arc.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === arc.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const arcAttribute = (0, theme_1.getTheme)(arc).arc;
        pickContext.highPerformanceSave();
        let {x: x = arcAttribute.x, y: y = arcAttribute.y} = arc.attribute;
        if (arc.transMatrix.onlyTranslate()) {
            const point = arc.getOffsetXY(arcAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(arc.transMatrix, !0);
        let picked = !1;
        return this.canvasRenderer.drawShape(arc, pickContext, x, y, {}, null, ((context, arcAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked)), ((context, arcAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), 
            picked;
        })), pickContext.highPerformanceRestore(), picked;
    }
};

DefaultMathArcPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.ArcRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultMathArcPicker), 
exports.DefaultMathArcPicker = DefaultMathArcPicker;
//# sourceMappingURL=arc-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767928, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMathAreaPicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), constants_1 = require("../../../graphic/constants");

let DefaultMathAreaPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = constants_1.AREA_NUMBER_TYPE;
    }
    contains(area, point, params) {
        if (!area.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === area.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const areaAttribute = (0, theme_1.getTheme)(area).area;
        let {x: x = areaAttribute.x, y: y = areaAttribute.y} = area.attribute;
        if (pickContext.highPerformanceSave(), area.transMatrix.onlyTranslate()) {
            const point = area.getOffsetXY(areaAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(area.transMatrix, !0);
        let picked = !1;
        return this.canvasRenderer.drawShape(area, pickContext, x, y, {}, null, (context => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked))), pickContext.highPerformanceRestore(), picked;
    }
};

DefaultMathAreaPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.AreaRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultMathAreaPicker), 
exports.DefaultMathAreaPicker = DefaultMathAreaPicker;
//# sourceMappingURL=area-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767929, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMathLinePicker = void 0;

const inversify_1 = require("inversify"), render_1 = require("../../../render"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants");

let DefaultMathLinePicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = constants_1.LINE_NUMBER_TYPE;
    }
    contains(line, point, params) {
        if (!line.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === line.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const lineAttribute = (0, theme_1.getTheme)(line).line;
        let {x: x = lineAttribute.x, y: y = lineAttribute.y} = line.attribute;
        if (pickContext.highPerformanceSave(), line.transMatrix.onlyTranslate()) {
            const point = line.getOffsetXY(lineAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(line.transMatrix, !0);
        let picked = !1;
        return this.canvasRenderer.drawShape(line, pickContext, x, y, {}, null, (context => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked)), ((context, circleAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), 
            picked;
        })), pickContext.highPerformanceRestore(), picked;
    }
};

DefaultMathLinePicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.LineRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultMathLinePicker), 
exports.DefaultMathLinePicker = DefaultMathLinePicker;
//# sourceMappingURL=line-picker.js.map

}, function(modId) { var map = {"../../../render":1689069767850,"../../../graphic/theme":1689069767707,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767930, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMathSymbolPicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), constants_1 = require("../../../graphic/constants");

let DefaultMathSymbolPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = constants_1.SYMBOL_NUMBER_TYPE;
    }
    contains(symbol, point, params) {
        if (!symbol.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === symbol.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const symbolAttribute = (0, theme_1.getTheme)(symbol).symbol;
        let {x: x = symbolAttribute.x, y: y = symbolAttribute.y} = symbol.attribute;
        if (pickContext.highPerformanceSave(), symbol.transMatrix.onlyTranslate()) {
            const point = symbol.getOffsetXY(symbolAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(symbol.transMatrix, !0);
        let picked = !1;
        return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, ((context, symbolAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked)), ((context, symbolAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), 
            picked;
        })), pickContext.highPerformanceRestore(), picked;
    }
};

DefaultMathSymbolPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.SymbolRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultMathSymbolPicker), 
exports.DefaultMathSymbolPicker = DefaultMathSymbolPicker;
//# sourceMappingURL=symbol-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767931, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMathTextPicker = void 0;

const inversify_1 = require("inversify"), constants_1 = require("../../../graphic/constants");

let DefaultMathTextPicker = class {
    constructor() {
        this.type = "text", this.numberType = constants_1.TEXT_NUMBER_TYPE;
    }
    contains(text, point, params) {
        return !!text.AABBBounds.containsPoint(point);
    }
};

DefaultMathTextPicker = __decorate([ (0, inversify_1.injectable)() ], DefaultMathTextPicker), 
exports.DefaultMathTextPicker = DefaultMathTextPicker;
//# sourceMappingURL=text-picker.js.map

}, function(modId) { var map = {"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767932, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMathPolygonPicker = void 0;

const inversify_1 = require("inversify"), theme_1 = require("../../../graphic/theme"), render_1 = require("../../../render"), constants_1 = require("../../../graphic/constants");

let DefaultMathPolygonPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = constants_1.POLYGON_NUMBER_TYPE;
    }
    contains(polygon, point, params) {
        if (!polygon.AABBBounds.contains(point.x, point.y)) return !1;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const pathAttribute = (0, theme_1.getTheme)(polygon).polygon;
        let {x: x = pathAttribute.x, y: y = pathAttribute.y} = polygon.attribute;
        if (pickContext.highPerformanceSave(), polygon.transMatrix.onlyTranslate()) {
            const point = polygon.getOffsetXY(pathAttribute);
            x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(polygon.transMatrix, !0);
        let picked = !1;
        return this.canvasRenderer.drawShape(polygon, pickContext, x, y, {}, null, ((context, pathAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), 
        picked)), ((context, pathAttribute, themeAttribute) => {
            if (picked) return !0;
            const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;
            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), 
            picked;
        })), pickContext.highPerformanceRestore(), picked;
    }
};

DefaultMathPolygonPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.PolygonRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultMathPolygonPicker), 
exports.DefaultMathPolygonPicker = DefaultMathPolygonPicker;
//# sourceMappingURL=polygon-picker.js.map

}, function(modId) { var map = {"../../../graphic/theme":1689069767707,"../../../render":1689069767850,"../../../graphic/constants":1689069767744}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767933, function(require, module, exports) {


var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultMathGlyphPicker = void 0;

const inversify_1 = require("inversify"), constants_1 = require("../../../graphic/constants"), render_1 = require("../../../render");

let DefaultMathGlyphPicker = class {
    constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "glyph", this.numberType = constants_1.GLYPH_NUMBER_TYPE;
    }
    contains(glyph, point, params) {
        if (!glyph.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === glyph.attribute.pickMode) return !0;
        const {pickContext: pickContext} = null != params ? params : {};
        if (!pickContext) return !1;
        const pickerService = null == params ? void 0 : params.pickerService;
        if (pickerService) {
            let picked = !1;
            return glyph.getSubGraphic().forEach((g => {
                picked || (picked = !!pickerService.pickItem(g, point, params));
            })), picked;
        }
        return !1;
    }
};

DefaultMathGlyphPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, 
inversify_1.inject)(render_1.GlyphRender)), __metadata("design:paramtypes", [ Object ]) ], DefaultMathGlyphPicker), 
exports.DefaultMathGlyphPicker = DefaultMathGlyphPicker;
//# sourceMappingURL=glyph-picker.js.map

}, function(modId) { var map = {"../../../graphic/constants":1689069767744,"../../../render":1689069767850}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767934, function(require, module, exports) {


var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

const modules_1 = __importDefault(require("./browser/modules")), modules_2 = __importDefault(require("./taro/modules")), modules_3 = __importDefault(require("./feishu/modules")), modules_4 = __importDefault(require("./lynx/modules")), modules_5 = __importDefault(require("./node/modules"));

function load(container) {
    container.load(modules_1.default), container.load(modules_3.default), container.load(modules_2.default), 
    container.load(modules_4.default), container.load(modules_5.default);
}

exports.default = load;
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"./browser/modules":1689069767935,"./taro/modules":1689069767936,"./feishu/modules":1689069767937,"./lynx/modules":1689069767938,"./node/modules":1689069767939}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767935, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), canvas_1 = require("./canvas"), context_1 = require("./context"), constants_1 = require("../../constants");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(constants_1.CanvasFactory).toDynamicValue((() => params => new canvas_1.BrowserCanvas(params))).whenTargetNamed(canvas_1.BrowserCanvas.env), 
    bind(constants_1.Context2dFactory).toDynamicValue((() => (params, dpr) => new context_1.BrowserContext2d(params, dpr))).whenTargetNamed(context_1.BrowserContext2d.env);
}));
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"./canvas":1689069767846,"./context":1689069767847,"../../constants":1689069767704}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767936, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), canvas_1 = require("./canvas"), context_1 = require("./context"), constants_1 = require("../../constants");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(constants_1.CanvasFactory).toDynamicValue((() => params => new canvas_1.TaroCanvas(params))).whenTargetNamed(canvas_1.TaroCanvas.env), 
    bind(constants_1.Context2dFactory).toDynamicValue((() => (params, dpr) => new context_1.TaroContext2d(params, dpr))).whenTargetNamed(context_1.TaroContext2d.env);
}));
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"./canvas":1689069767877,"./context":1689069767878,"../../constants":1689069767704}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767937, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), canvas_1 = require("./canvas"), context_1 = require("./context"), constants_1 = require("../../constants");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(constants_1.CanvasFactory).toDynamicValue((() => params => new canvas_1.FeishuCanvas(params))).whenTargetNamed(canvas_1.FeishuCanvas.env), 
    bind(constants_1.Context2dFactory).toDynamicValue((() => (params, dpr) => new context_1.FeishuContext2d(params, dpr))).whenTargetNamed(context_1.FeishuContext2d.env);
}));
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"./canvas":1689069767873,"./context":1689069767874,"../../constants":1689069767704}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767938, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), canvas_1 = require("./canvas"), context_1 = require("./context"), constants_1 = require("../../constants");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(constants_1.CanvasFactory).toDynamicValue((() => params => new canvas_1.LynxCanvas(params))).whenTargetNamed(canvas_1.LynxCanvas.env), 
    bind(constants_1.Context2dFactory).toDynamicValue((() => (params, dpr) => new context_1.LynxContext2d(params, dpr))).whenTargetNamed(context_1.LynxContext2d.env);
}));
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"./canvas":1689069767881,"./context":1689069767882,"../../constants":1689069767704}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767939, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});

const inversify_1 = require("inversify"), canvas_1 = require("./canvas"), context_1 = require("./context"), constants_1 = require("../../constants");

exports.default = new inversify_1.ContainerModule((bind => {
    bind(constants_1.CanvasFactory).toDynamicValue((() => params => new canvas_1.NodeCanvas(params))).whenTargetNamed(canvas_1.NodeCanvas.env), 
    bind(constants_1.Context2dFactory).toDynamicValue((() => (params, dpr) => new context_1.NodeContext2d(params, dpr))).whenTargetNamed(context_1.NodeContext2d.env);
}));
//# sourceMappingURL=modules.js.map

}, function(modId) { var map = {"./canvas":1689069767885,"./context":1689069767886,"../../constants":1689069767704}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767940, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createStage = void 0;

const stage_1 = require("./core/stage");

function createStage(params) {
    return new stage_1.Stage(params);
}

exports.createStage = createStage;
//# sourceMappingURL=create.js.map
}, function(modId) { var map = {"./core/stage":1689069767941}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767941, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Stage = void 0;

const vutils_1 = require("@visactor/vutils"), window_1 = require("./window"), layer_1 = require("./layer"), event_1 = require("../event"), container_1 = require("../container"), render_1 = require("../render"), graphic_1 = require("../graphic"), picker_service_1 = require("../picker/picker-service"), plugin_service_1 = require("../plugins/plugin-service"), auto_render_plugin_1 = require("../plugins/builtin-plugin/auto-render-plugin"), _3dview_transform_plugin_1 = require("../plugins/builtin-plugin/3dview-transform-plugin"), incremental_auto_render_plugin_1 = require("../plugins/builtin-plugin/incremental-auto-render-plugin"), dirty_bounds_plugin_1 = require("../plugins/builtin-plugin/dirty-bounds-plugin"), default_ticker_1 = require("../animate/default-ticker"), tapable_1 = require("../tapable"), light_1 = require("./light"), camera_1 = require("./camera"), constants_1 = require("../constants"), DefaultConfig = {
    WIDTH: 500,
    HEIGHT: 500,
    X: 0,
    Y: 0,
    BACKGROUND: "white"
};

class Stage extends graphic_1.Group {
    set viewBox(b) {
        this._viewBox.setValue(b.x1, b.y1, b.x2, b.y2);
    }
    get viewBox() {
        return this._viewBox;
    }
    get x() {
        return this._viewBox.x1;
    }
    set x(x) {
        this._viewBox.translate(x - this._viewBox.x1, 0);
    }
    get y() {
        return this._viewBox.y1;
    }
    set y(y) {
        this._viewBox.translate(0, y - this._viewBox.y1);
    }
    get width() {
        return this.window.width;
    }
    set width(w) {
        this.resize(w, this.height);
    }
    get viewWidth() {
        return this._viewBox.width();
    }
    set viewWidth(w) {
        this.resizeView(w, this.viewHeight);
    }
    get viewHeight() {
        return this._viewBox.height();
    }
    set viewHeight(h) {
        this.resizeView(this.viewWidth, h);
    }
    get height() {
        return this.window.height;
    }
    set height(h) {
        this.resize(this.width, h);
    }
    get dpr() {
        return this.window.dpr;
    }
    set dpr(r) {
        this.setDpr(r);
    }
    get background() {
        var _a;
        return null !== (_a = this._background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND;
    }
    set background(b) {
        this._background = b;
    }
    get defaultLayer() {
        return this.at(0);
    }
    constructor(params) {
        var _a;
        super({}), this.beforeRender = stage => {
            this._beforeRender && this._beforeRender(stage);
        }, this.afterRender = stage => {
            this.renderCount++, this._afterRender && this._afterRender(stage), this._afterNextRenderCbs && this._afterNextRenderCbs.forEach((cb => cb(stage))), 
            this._afterNextRenderCbs = null;
        }, this.theme = new graphic_1.Theme, this.hooks = {
            beforeRender: new tapable_1.SyncHook([ "stage" ]),
            afterRender: new tapable_1.SyncHook([ "stage" ])
        }, this.global = container_1.container.get(constants_1.Global), this.window = container_1.container.get(window_1.Window), 
        this.renderService = container_1.container.get(render_1.RenderService), this.pickerService = container_1.container.get(picker_service_1.PickerService), 
        this.pluginService = container_1.container.get(plugin_service_1.PluginService), 
        this.pluginService.active(this), this.window.create({
            width: params.width,
            height: params.height,
            container: params.container,
            dpr: params.dpr || this.global.devicePixelRatio,
            canvasControled: !1 !== params.canvasControled,
            title: params.title || "",
            canvas: params.canvas
        }), this._viewBox = new vutils_1.AABBBounds, params.viewBox ? this._viewBox.setValue(params.viewBox.x1, params.viewBox.y1, params.viewBox.x2, params.viewBox.y2) : this._viewBox.setValue(0, 0, this.width, this.height), 
        this.renderCount = 0, this._subView = !(this._viewBox.width() === this.width && this._viewBox.height() === this.height), 
        this._background = null !== (_a = params.background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND, 
        this.appendChild(new layer_1.Layer(this, this.global, this.window, {
            main: !0
        })), this.nextFrameRenderLayerSet = new Set, this.willNextFrameRender = !1, this.stage = this, 
        this.renderStyle = params.renderStyle, this.global.supportEvent && (this.eventSystem = new event_1.EventSystem({
            targetElement: this.window,
            resolution: this.window.dpr || this.global.devicePixelRatio,
            rootNode: this,
            global: this.global,
            viewport: {
                viewBox: this._viewBox,
                get x() {
                    return this.viewBox.x1;
                },
                get y() {
                    return this.viewBox.y1;
                },
                get width() {
                    return this.viewBox.width();
                },
                get height() {
                    return this.viewBox.height();
                }
            }
        })), params.autoRender && this.enableAutoRender(), !1 === params.disableDirtyBounds && this.enableDirtyBounds(), 
        this.hooks.beforeRender.tap("constructor", this.beforeRender), this.hooks.afterRender.tap("constructor", this.afterRender), 
        this._beforeRender = params.beforeRender, this._afterRender = params.afterRender, 
        this.ticker = params.ticker || default_ticker_1.defaultTicker;
    }
    get3dOptions(options) {
        const {center: center = {
            x: this.width / 2,
            y: this.height / 2,
            z: 0,
            dx: 0,
            dy: 0,
            dz: 0
        }, light: light = {}, alpha: alpha = 0, beta: beta = 0, camera: camera, fieldRatio: fieldRatio = 1, fieldDepth: fieldDepth} = options;
        return Object.assign(Object.assign({}, options), {
            center: center,
            light: light,
            alpha: alpha,
            beta: beta,
            camera: camera,
            fieldRatio: fieldRatio,
            fieldDepth: fieldDepth
        });
    }
    set3dOptions(options) {
        var _a, _b, _c, _d, _e, _f;
        this.option3d = options;
        const options3d = this.get3dOptions(options), {light: light, center: center, camera: camera, alpha: alpha, beta: beta, fieldRatio: fieldRatio, fieldDepth: fieldDepth} = options3d, {dir: dir = [ 1, 1, -1 ], color: color = "white", ambient: ambient} = light, centerX = (null !== (_a = center.x) && void 0 !== _a ? _a : this.width / 2) + (null !== (_b = center.dx) && void 0 !== _b ? _b : 0), centerY = (null !== (_c = center.y) && void 0 !== _c ? _c : this.height / 2) + (null !== (_d = center.dy) && void 0 !== _d ? _d : 0), centerVec3 = [ centerX, centerY, (null !== (_e = center.z) && void 0 !== _e ? _e : 0) + (null !== (_f = center.dz) && void 0 !== _f ? _f : 0) ];
        let cameraX = 0, cameraY = 0, cameraZ = 0;
        camera || (cameraX = Math.sin(alpha) + centerX, cameraY = Math.sin(beta) + centerY, 
        cameraZ = Math.cos(alpha) * Math.cos(beta) * 1), this.light = new light_1.DirectionalLight(dir, color, ambient);
        const cameraParams = {
            left: 0,
            right: this.width,
            top: 0,
            bottom: this.height,
            fieldRatio: fieldRatio,
            fieldDepth: fieldDepth,
            viewParams: {
                pos: [ cameraX, cameraY, cameraZ ],
                center: centerVec3,
                up: [ 0, 1, 0 ]
            }
        };
        this.camera ? this.camera.params = cameraParams : this.camera = new camera_1.OrthoCamera(cameraParams), 
        options.enableView3dTransform && this.enableView3dTransform();
    }
    setBeforeRender(cb) {
        this._beforeRender = cb;
    }
    setAfterRender(cb) {
        this._afterRender = cb;
    }
    afterNextRender(cb) {
        this._afterNextRenderCbs || (this._afterNextRenderCbs = []), this._afterNextRenderCbs.push(cb);
    }
    enableView3dTransform() {
        this.view3dTranform || (this.view3dTranform = !0, this.pluginService.register(new _3dview_transform_plugin_1.ViewTransform3dPlugin));
    }
    disableView3dTranform() {
        this.view3dTranform && (this.view3dTranform = !1, this.pluginService.findPluginsByName("ViewTransform3dPlugin").forEach((plugin => {
            plugin.deactivate(this.pluginService);
        })));
    }
    enableAutoRender() {
        this.autoRender || (this.autoRender = !0, this.pluginService.register(new auto_render_plugin_1.AutoRenderPlugin));
    }
    disableAutoRender() {
        this.autoRender && (this.autoRender = !1, this.pluginService.findPluginsByName("AutoRenderPlugin").forEach((plugin => {
            plugin.deactivate(this.pluginService);
        })));
    }
    enableIncrementalAutoRender() {
        this.increaseAutoRender || (this.increaseAutoRender = !0, this.pluginService.register(new incremental_auto_render_plugin_1.IncrementalAutoRenderPlugin));
    }
    disableIncrementalAutoRender() {
        this.increaseAutoRender && (this.increaseAutoRender = !1, this.pluginService.findPluginsByName("IncrementalAutoRenderPlugin").forEach((plugin => {
            plugin.deactivate(this.pluginService);
        })));
    }
    enableDirtyBounds() {
        if (this.dirtyBounds) return;
        this.dirtyBounds = new vutils_1.Bounds;
        let plugin = this.pluginService.findPluginsByName("DirtyBoundsPlugin")[0];
        plugin || (plugin = new dirty_bounds_plugin_1.DirtyBoundsPlugin, this.pluginService.register(plugin)), 
        plugin.activate(this.pluginService);
    }
    disableDirtyBounds() {
        this.dirtyBounds && (this.dirtyBounds = null, this.pluginService.findPluginsByName("DirtyBoundsPlugin").forEach((plugin => {
            plugin.deactivate(this.pluginService);
        })));
    }
    tryUpdateAABBBounds() {
        const viewBox = this._viewBox;
        return this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2), 
        this._AABBBounds;
    }
    combineLayer(ILayer1, ILayer2) {
        throw new Error("暂不支持");
    }
    createLayer(canvasId) {
        const layer = new layer_1.Layer(this, this.global, this.window, {
            main: !1,
            canvasId: canvasId
        });
        return this.appendChild(layer), layer;
    }
    sortLayer(cb) {
        throw new Error("暂不支持");
    }
    removeLayer(ILayerId) {
        return this.removeChild(this.findChildByUid(ILayerId));
    }
    clearViewBox(color) {
        this.window.clearViewBox(this._viewBox, color);
    }
    render(layers, params) {
        this.ticker.start(), this.lastRenderparams = params, this.hooks.beforeRender.call(this), 
        (layers || this).forEach(((layer, i) => {
            layer.render({
                renderService: this.renderService,
                background: layer === this.defaultLayer ? this.background : void 0,
                updateBounds: !!this.dirtyBounds
            }, Object.assign({
                renderStyle: this.renderStyle
            }, params));
        })), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear(), this.hooks.afterRender.call(this);
    }
    combineLayersToWindow() {
        this.forEach(((layer, i) => {
            layer.combineTo(this.window, {
                clear: 0 === i,
                x: this.x,
                y: this.y,
                width: this.viewWidth,
                height: this.viewHeight,
                renderService: this.renderService,
                background: layer === this.defaultLayer ? this.background : void 0,
                updateBounds: !!this.dirtyBounds
            });
        }));
    }
    renderNextFrame(layers) {
        this.nextFrameRenderLayerSet.size !== this.childrenCount && (layers || this).forEach((layer => {
            this.nextFrameRenderLayerSet.add(layer);
        })), this.willNextFrameRender || (this.willNextFrameRender = !0, this.global.getRequestAnimationFrame()((() => {
            this._doRenderInThisFrame(), this.willNextFrameRender = !1;
        })));
    }
    _doRenderInThisFrame() {
        this.nextFrameRenderLayerSet.size && (this.ticker.start(), this.hooks.beforeRender.call(this), 
        this.forEach((layer => {
            this.nextFrameRenderLayerSet.has(layer) && layer.render({
                renderService: this.renderService,
                background: layer === this.defaultLayer ? this.background : void 0,
                updateBounds: !!this.dirtyBounds
            }, Object.assign({
                renderStyle: this.renderStyle
            }, this.lastRenderparams || {}));
        })), this.combineLayersToWindow(), this.hooks.afterRender.call(this), this.nextFrameRenderLayerSet.clear());
    }
    resizeWindow(w, h, rerender = !0) {
        this.window.resize(w, h), rerender && this.render();
    }
    resize(w, h, rerender = !0) {
        this.window.resize(w, h), this.forEachChildren((c => {
            c.resize(w, h);
        })), this._subView || this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), 
        this.camera && this.option3d && this.set3dOptions(this.option3d), rerender && this.render();
    }
    resizeView(w, h, rerender = !0) {
        this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), 
        this.forEachChildren((c => {
            c.resizeView(w, h);
        })), this.camera && (this.camera.params = Object.assign(Object.assign({}, this.camera.params), {
            right: this.width,
            bottom: this.height
        })), rerender && this.render();
    }
    setViewBox(x, y, w, h, rerender) {
        let isRerender = !0;
        "object" == typeof x ? (this.viewBox.setValue(x.x1, x.y1, x.x2, x.y2), !1 === y && (isRerender = !1)) : (this.viewBox.setValue(x, y, x + w, y + h), 
        !1 === rerender && (isRerender = !1)), this.forEachChildren((c => {
            c.resizeView(this.viewBox.width(), this.viewBox.height());
        })), isRerender && this.render();
    }
    setDpr(dpr) {
        this.forEachChildren((c => {
            c.setDpr(dpr);
        }));
    }
    setOrigin(x, y) {
        throw new Error("暂不支持");
    }
    export(type) {
        throw new Error("暂不支持");
    }
    pick(x, y) {
        const result = this.pickerService.pick(this.children, new vutils_1.Point(x, y), {
            bounds: this.AABBBounds
        });
        return !(!(null == result ? void 0 : result.graphic) && !(null == result ? void 0 : result.group)) && result;
    }
    startAnimate(t) {
        throw new Error("暂不支持");
    }
    setToFrame(t) {
        throw new Error("暂不支持");
    }
    release() {
        super.release(), this.eventSystem && this.eventSystem.release(), this.pluginService.release(), 
        this.forEach((layer => {
            layer.release();
        })), this.window.release();
    }
    setStage(stage) {}
    dirty(b, matrix) {
        matrix && b.transformWithMatrix(matrix), this.dirtyBounds.empty() && this.dirtyBounds.setValue(b.x1, b.y1, b.x2, b.y2), 
        this.dirtyBounds.union(b);
    }
    renderTo(window, params) {
        this.forEachChildren(((layer, i) => {
            layer.drawTo(window, Object.assign(Object.assign({}, params), {
                renderService: this.renderService,
                background: layer === this.defaultLayer ? this.background : void 0,
                clear: 0 === i,
                updateBounds: !!this.dirtyBounds
            }));
        }));
    }
    renderToNewWindow(fullImage = !0) {
        const window = container_1.container.get(window_1.Window);
        return fullImage ? window.create({
            width: this.viewWidth,
            height: this.viewHeight,
            dpr: this.window.dpr,
            canvasControled: !0,
            offscreen: !0,
            title: ""
        }) : window.create({
            width: Math.min(this.viewWidth, this.window.width - this.x),
            height: Math.min(this.viewHeight, this.window.height - this.y),
            dpr: this.window.dpr,
            canvasControled: !0,
            offscreen: !0,
            title: ""
        }), this.renderTo(window, {
            x: 0,
            y: 0,
            width: window.width,
            height: window.height
        }), window;
    }
    toCanvas(fullImage = !0) {
        const c = this.renderToNewWindow(fullImage).getNativeHandler();
        return c.nativeCanvas ? c.nativeCanvas : null;
    }
    setCursor(mode) {
        this._cursor = mode, this.eventSystem.setCursor(mode);
    }
    getCursor() {
        return this._cursor;
    }
}

exports.Stage = Stage;
//# sourceMappingURL=stage.js.map

}, function(modId) { var map = {"./window":1689069767746,"./layer":1689069767706,"../event":1689069767712,"../container":1689069767702,"../render":1689069767850,"../graphic":1689069767757,"../picker/picker-service":1689069767840,"../plugins/plugin-service":1689069767856,"../plugins/builtin-plugin/auto-render-plugin":1689069767942,"../plugins/builtin-plugin/3dview-transform-plugin":1689069767943,"../plugins/builtin-plugin/incremental-auto-render-plugin":1689069767944,"../plugins/builtin-plugin/dirty-bounds-plugin":1689069767945,"../animate/default-ticker":1689069767946,"../tapable":1689069767673,"./light":1689069767947,"./camera":1689069767848,"../constants":1689069767676}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767942, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.AutoRenderPlugin = void 0;

const generator_1 = require("../../common/generator"), application_1 = require("../../application");

class AutoRenderPlugin {
    constructor() {
        this.name = "AutoRenderPlugin", this.activeEvent = "onRegister", this._uid = generator_1.Generator.GenAutoIncrementId(), 
        this.key = this.name + this._uid;
    }
    activate(context) {
        this.pluginService = context, application_1.application.graphicService.hooks.onAttributeUpdate.tap(this.key, (graphic => {
            graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && graphic.stage.renderNextFrame();
        })), application_1.application.graphicService.hooks.onSetStage.tap(this.key, (graphic => {
            graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && graphic.stage.renderNextFrame();
        }));
    }
    deactivate(context) {
        application_1.application.graphicService.hooks.onAttributeUpdate.taps = application_1.application.graphicService.hooks.onAttributeUpdate.taps.filter((item => item.name !== this.key)), 
        application_1.application.graphicService.hooks.onSetStage.taps = application_1.application.graphicService.hooks.onSetStage.taps.filter((item => item.name !== this.key));
    }
}

exports.AutoRenderPlugin = AutoRenderPlugin;
//# sourceMappingURL=auto-render-plugin.js.map

}, function(modId) { var map = {"../../common/generator":1689069767711,"../../application":1689069767703}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767943, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ViewTransform3dPlugin = void 0;

const generator_1 = require("../../common/generator");

class ViewTransform3dPlugin {
    constructor() {
        this.name = "ViewTransform3dPlugin", this.activeEvent = "onRegister", this._uid = generator_1.Generator.GenAutoIncrementId(), 
        this.key = this.name + this._uid, this.onMouseDown = e => {
            this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = !0, 
            this.pageX = e.page.x, this.pageY = e.page.y);
        }, this.onMouseUp = e => {
            this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = !1);
        }, this.onMouseMove = e => {
            var _a, _b;
            const stage = this.pluginService.stage;
            if (this.option3d || (this.option3d = stage.option3d), this.option3d && this.mousedown) if (this.pageX && this.pageY) {
                const deltaX = e.page.x - this.pageX, deltaY = e.page.y - this.pageY;
                this.pageX = e.page.x, this.pageY = e.page.y;
                const angle1 = deltaX / 100, angle2 = deltaY / 100;
                this.option3d.alpha = (null !== (_a = this.option3d.alpha) && void 0 !== _a ? _a : 0) + angle1, 
                this.option3d.beta = (null !== (_b = this.option3d.beta) && void 0 !== _b ? _b : 0) + angle2, 
                stage.set3dOptions(this.option3d), stage.renderNextFrame();
            } else this.pageX = e.page.x, this.pageY = e.page.y;
        };
    }
    activate(context) {
        this.pluginService = context;
        const stage = context.stage;
        this.option3d = stage.option3d, stage.addEventListener("mousedown", this.onMouseDown), 
        stage.addEventListener("mouseup", this.onMouseUp), stage.addEventListener("mousemove", this.onMouseMove);
    }
    deactivate(context) {
        const stage = context.stage;
        stage.removeEventListener("mousedown", this.onMouseDown), stage.removeEventListener("mouseup", this.onMouseUp), 
        stage.removeEventListener("mousemove", this.onMouseMove);
    }
}

exports.ViewTransform3dPlugin = ViewTransform3dPlugin;
//# sourceMappingURL=3dview-transform-plugin.js.map

}, function(modId) { var map = {"../../common/generator":1689069767711}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767944, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.IncrementalAutoRenderPlugin = void 0;

const application_1 = require("../../application"), generator_1 = require("../../common/generator");

class IncrementalAutoRenderPlugin {
    constructor() {
        this.name = "IncrementalAutoRenderPlugin", this.activeEvent = "onRegister", this.nextFrameRenderGroupSet = new Set, 
        this.willNextFrameRender = !1, this.nextUserParams = {}, this._uid = generator_1.Generator.GenAutoIncrementId(), 
        this.key = this.name + this._uid;
    }
    activate(context) {
        this.pluginService = context, application_1.application.graphicService.hooks.onAddIncremental.tap(this.key, ((graphic, group, stage) => {
            graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && (this.nextUserParams.startAtId = group._uid, 
            this.renderNextFrame(group));
        })), application_1.application.graphicService.hooks.onClearIncremental.tap(this.key, ((group, stage) => {
            group.stage === context.stage && null != group.stage && (this.nextUserParams.startAtId = group._uid, 
            this.nextUserParams.restartIncremental = !0, this.renderNextFrame(group));
        }));
    }
    deactivate(context) {
        application_1.application.graphicService.hooks.onAddIncremental.taps = application_1.application.graphicService.hooks.onAddIncremental.taps.filter((item => item.name !== this.key)), 
        application_1.application.graphicService.hooks.onClearIncremental.taps = application_1.application.graphicService.hooks.onClearIncremental.taps.filter((item => item.name !== this.key));
    }
    renderNextFrame(group) {
        this.nextFrameRenderGroupSet.add(group), this.willNextFrameRender || (this.willNextFrameRender = !0, 
        application_1.application.global.getRequestAnimationFrame()((() => {
            this._doRenderInThisFrame(), this.willNextFrameRender = !1;
        })));
    }
    _doRenderInThisFrame() {
        const stage = this.pluginService.stage;
        this.nextFrameRenderGroupSet.size && (this.nextFrameRenderGroupSet.forEach((group => {
            const layer = group.layer;
            if (!layer || !group.layer.subLayers) return;
            const subLayer = group.layer.subLayers.get(group._uid);
            subLayer && subLayer.drawContribution && subLayer.drawContribution.draw(stage.renderService, Object.assign({
                x: stage.x,
                y: stage.y,
                width: layer.viewWidth,
                height: layer.viewHeight,
                stage: stage,
                layer: layer,
                clear: "transparent",
                renderService: stage.renderService,
                updateBounds: !1,
                startAtId: group._uid,
                context: subLayer.layer.getNativeHandler().getContext()
            }, this.nextUserParams));
        })), this.nextUserParams = {}, this.nextFrameRenderGroupSet.clear());
    }
}

exports.IncrementalAutoRenderPlugin = IncrementalAutoRenderPlugin;
//# sourceMappingURL=incremental-auto-render-plugin.js.map

}, function(modId) { var map = {"../../application":1689069767703,"../../common/generator":1689069767711}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767945, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DirtyBoundsPlugin = void 0;

const vutils_1 = require("@visactor/vutils"), generator_1 = require("../../common/generator"), application_1 = require("../../application"), globalBounds = new vutils_1.AABBBounds;

class DirtyBoundsPlugin {
    constructor() {
        this.name = "DirtyBoundsPlugin", this.activeEvent = "onRegister", this._uid = generator_1.Generator.GenAutoIncrementId(), 
        this.key = this.name + this._uid;
    }
    activate(context) {
        this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, (stage => {
            stage && stage === this.pluginService.stage && stage.dirtyBounds.clear();
        })), application_1.application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, ((graphic, stage, willUpdate, bounds) => {
            graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !graphic.shouldSelfChangeUpdateAABBBounds() || willUpdate && (globalBounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), 
            stage.dirty(globalBounds, graphic.parent && graphic.parent.globalTransMatrix)));
        })), application_1.application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, ((graphic, stage, bounds, params, selfChange) => {
            stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !selfChange || stage.dirty(params.globalAABBBounds));
        })), application_1.application.graphicService.hooks.onRemove.tap(this.key, (graphic => {
            const stage = graphic.stage;
            stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(graphic.globalAABBBounds);
        }));
    }
    deactivate(context) {
        application_1.application.graphicService.hooks.beforeUpdateAABBBounds.taps = application_1.application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter((item => item.name !== this.key)), 
        application_1.application.graphicService.hooks.afterUpdateAABBBounds.taps = application_1.application.graphicService.hooks.afterUpdateAABBBounds.taps.filter((item => item.name !== this.key)), 
        context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter((item => item.name !== this.key)), 
        application_1.application.graphicService.hooks.onRemove.taps = application_1.application.graphicService.hooks.onRemove.taps.filter((item => item.name !== this.key));
    }
}

exports.DirtyBoundsPlugin = DirtyBoundsPlugin;
//# sourceMappingURL=dirty-bounds-plugin.js.map

}, function(modId) { var map = {"../../common/generator":1689069767711,"../../application":1689069767703}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767946, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.defaultTicker = void 0;

const default_ticker_1 = require("./Ticker/default-ticker"), timeline_1 = require("./timeline");

exports.defaultTicker = new default_ticker_1.DefaultTicker, exports.defaultTicker.addTimeline(timeline_1.defaultTimeline);

const DEFAULT_TICKER_FPS = 60;

exports.defaultTicker.setFPS(60);
}, function(modId) { var map = {"./Ticker/default-ticker":1689069767730,"./timeline":1689069767733}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767947, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DirectionalLight = void 0;

const vutils_1 = require("@visactor/vutils"), color_string_1 = require("../color-string");

class DirectionalLight {
    constructor(dir, color, ambient = .8) {
        this.dir = dir, this.color = color, this.colorRgb = color_string_1.colorString.get(color).value, 
        this.colorRgb[0] /= 255, this.colorRgb[1] /= 255, this.colorRgb[2] /= 255, this.ambient = ambient;
        const length = (0, vutils_1.sqrt)(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
        this.formatedDir = [ dir[0] / length, dir[1] / length, dir[2] / length ];
    }
    computeColor(normal, color) {
        const lightDir = this.formatedDir, brightness = (0, vutils_1.min)((0, vutils_1.max)((normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2]) * (1 - this.ambient / 2), 0) + this.ambient, 1);
        let colorArray;
        if ((0, vutils_1.isString)(color)) {
            colorArray = color_string_1.colorString.get(color).value;
        } else colorArray = color;
        const lightColorArray = this.colorRgb;
        return color_string_1.colorString.to.rgb(lightColorArray[0] * colorArray[0] * brightness, lightColorArray[1] * colorArray[1] * brightness, lightColorArray[2] * colorArray[2] * brightness);
    }
}

exports.DirectionalLight = DirectionalLight;
//# sourceMappingURL=light.js.map

}, function(modId) { var map = {"../color-string":1689069767741}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767948, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./global"), exports), __exportStar(require("./common"), exports), 
__exportStar(require("./node-tree"), exports), __exportStar(require("./graphic"), exports), 
__exportStar(require("./graphic/index"), exports), __exportStar(require("./layer"), exports), 
__exportStar(require("./stage"), exports), __exportStar(require("./canvas"), exports), 
__exportStar(require("./context"), exports), __exportStar(require("./path"), exports), 
__exportStar(require("./color"), exports), __exportStar(require("./common"), exports), 
__exportStar(require("./animate"), exports), __exportStar(require("./camera"), exports), 
__exportStar(require("./matrix"), exports), __exportStar(require("./light"), exports), 
__exportStar(require("./curve"), exports), __exportStar(require("./graphic-service"), exports), 
__exportStar(require("./sync-hook"), exports), __exportStar(require("./allocator"), exports), 
__exportStar(require("./core"), exports), __exportStar(require("./event"), exports), 
__exportStar(require("./loader"), exports), __exportStar(require("./contribution"), exports), 
__exportStar(require("./render"), exports), __exportStar(require("./plugin"), exports), 
__exportStar(require("./picker"), exports), __exportStar(require("./text"), exports), 
__exportStar(require("./window"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./global":1689069767949,"./common":1689069767950,"./node-tree":1689069767951,"./graphic":1689069767952,"./graphic/index":1689069767953,"./layer":1689069767980,"./stage":1689069767981,"./canvas":1689069767982,"./context":1689069767983,"./path":1689069767984,"./color":1689069767985,"./animate":1689069767986,"./camera":1689069767987,"./matrix":1689069767988,"./light":1689069767989,"./curve":1689069767990,"./graphic-service":1689069767991,"./sync-hook":1689069767992,"./allocator":1689069767993,"./core":1689069767994,"./event":1689069767727,"./loader":1689069767995,"./contribution":1689069767996,"./render":1689069767997,"./plugin":1689069767998,"./picker":1689069767999,"./text":1689069768000,"./window":1689069768001}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767949, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=global.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767950, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=common.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767951, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=node-tree.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767952, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=graphic.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767953, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./creator"), exports), __exportStar(require("./theme"), exports), 
__exportStar(require("./arc"), exports), __exportStar(require("./arc3d"), exports), 
__exportStar(require("./area"), exports), __exportStar(require("./bounds"), exports), 
__exportStar(require("./circle"), exports), __exportStar(require("./ellipse"), exports), 
__exportStar(require("./face3d"), exports), __exportStar(require("./glyph"), exports), 
__exportStar(require("./group"), exports), __exportStar(require("./image"), exports), 
__exportStar(require("./isogon"), exports), __exportStar(require("./line"), exports), 
__exportStar(require("./path"), exports), __exportStar(require("./polygon"), exports), 
__exportStar(require("./polyline"), exports), __exportStar(require("./pyramid3d"), exports), 
__exportStar(require("./rect"), exports), __exportStar(require("./rect3d"), exports), 
__exportStar(require("./richText"), exports), __exportStar(require("./shadow-root"), exports), 
__exportStar(require("./svg"), exports), __exportStar(require("./symbol"), exports), 
__exportStar(require("./text"), exports), __exportStar(require("./util"), exports);
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./creator":1689069767954,"./theme":1689069767955,"./arc":1689069767956,"./arc3d":1689069767957,"./area":1689069767958,"./bounds":1689069767959,"./circle":1689069767960,"./ellipse":1689069767961,"./face3d":1689069767962,"./glyph":1689069767963,"./group":1689069767964,"./image":1689069767965,"./isogon":1689069767966,"./line":1689069767967,"./path":1689069767968,"./polygon":1689069767969,"./polyline":1689069767970,"./pyramid3d":1689069767971,"./rect":1689069767972,"./rect3d":1689069767973,"./richText":1689069767974,"./shadow-root":1689069767975,"./svg":1689069767976,"./symbol":1689069767977,"./text":1689069767978,"./util":1689069767979}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767954, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=creator.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767955, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=theme.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767956, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=arc.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767957, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=arc3d.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767958, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=area.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767959, function(require, module, exports) {


var params;

Object.defineProperty(exports, "__esModule", {
    value: !0
}), function(params) {
    params[params.W = 1] = "W", params[params.H = 2] = "H", params[params.WH = 3] = "WH";
}(params || (params = {}));
//# sourceMappingURL=bounds.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767960, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=circle.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767961, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=ellipse.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767962, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=face3d.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767963, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=glyph.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767964, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=group.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767965, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=image.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767966, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=isogon.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767967, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=line.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767968, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=path.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767969, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=polygon.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767970, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=polyline.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767971, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=pyramid3d.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767972, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=rect.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767973, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=rect3d.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767974, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=richText.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767975, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=shadow-root.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767976, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=svg.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767977, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=symbol.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767978, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=text.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767979, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=util.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767980, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=layer.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767981, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=stage.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767982, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=canvas.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767983, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=context.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767984, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.strCommandMap = void 0, exports.strCommandMap = [ "arc", "arcTo", "bezierCurveTo", "closePath", "ellipse", "lineTo", "moveTo", "quadraticCurveTo", "rect" ];
//# sourceMappingURL=path.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767985, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=color.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767986, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=animate.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767987, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=camera.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767988, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=matrix.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767989, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=light.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767990, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=curve.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767991, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=graphic-service.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767992, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=sync-hook.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767993, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=allocator.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767994, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=core.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767995, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=loader.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767996, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=contribution.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767997, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=render.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767998, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=plugin.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069767999, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=picker.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069768000, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=text.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069768001, function(require, module, exports) {


Object.defineProperty(exports, "__esModule", {
    value: !0
});
//# sourceMappingURL=window.js.map

}, function(modId) { var map = {}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069768002, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), __exportStar(require("./global"), exports), __exportStar(require("./window"), exports), 
__exportStar(require("./layer"), exports), __exportStar(require("./stage"), exports), 
__exportStar(require("./graphic-utils"), exports), __exportStar(require("./contributions"), exports), 
__exportStar(require("./layer-service"), exports), __exportStar(require("./constants"), exports), 
__exportStar(require("../interface/core"), exports);
//# sourceMappingURL=index.js.map
}, function(modId) { var map = {"./global":1689069767671,"./window":1689069767746,"./layer":1689069767706,"./stage":1689069767941,"./graphic-utils":1689069767677,"./contributions":1689069768003,"./layer-service":1689069767705,"./constants":1689069767747,"../interface/core":1689069767994}; return __REQUIRE__(map[modId], modId); })
__DEFINE__(1689069768003, function(require, module, exports) {


var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CanvasTextLayout = void 0, __exportStar(require("./env/base-contribution"), exports), 
__exportStar(require("./window/base-contribution"), exports);

var layout_1 = require("./textMeasure/layout");

Object.defineProperty(exports, "CanvasTextLayout", {
    enumerable: !0,
    get: function() {
        return layout_1.CanvasTextLayout;
    }
});
//# sourceMappingURL=index.js.map

}, function(modId) { var map = {"./env/base-contribution":1689069767860,"./window/base-contribution":1689069767870,"./textMeasure/layout":1689069767761}; return __REQUIRE__(map[modId], modId); })
return __REQUIRE__(1689069767668);
})()
//miniprogram-npm-outsideDeps=["reflect-metadata","inversify","@visactor/vutils"]
//# sourceMappingURL=index.js.map